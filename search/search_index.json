{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Pydantic Agent","text":"<p>A simple, extensible AI Agent framework built on pydantic-ai.</p>"},{"location":"#simple-agent-loop","title":"Simple Agent Loop","text":"<p>Thin wrapper around pydantic-ai with tool-calling support and automatic context management.</p>"},{"location":"#built-in-tools","title":"Built-in Tools","text":"<p>Filesystem, glob, grep, and bash operations with security controls.</p>"},{"location":"#mcp-integration","title":"MCP Integration","text":"<p>Connect to Model Context Protocol servers (stdio and SSE transports).</p>"},{"location":"#token-management","title":"Token Management","text":"<p>Track usage with tiktoken, estimate costs automatically.</p>"},{"location":"#context-compaction","title":"Context Compaction","text":"<p>5 strategies to manage long conversations without losing important context.</p>"},{"location":"#workflows","title":"Workflows","text":"<p>Orchestration patterns for multi-step execution (ReAct, Plan-Execute, etc.).</p>"},{"location":"#model-backends","title":"Model Backends","text":"<p>OpenAI-compatible adapter for Ollama, vLLM, LM Studio.</p>"},{"location":"#observability","title":"Observability","text":"<p>Structured logging, tracing, and OpenTelemetry hooks.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>from pydantic_agent import Agent, AgentSettings\n\n# Load settings from env vars, .env, ~/agents.env, config.toml\nsettings = AgentSettings()\n\n# Create agent using settings\nagent = Agent(settings=settings)\n\n# Run the agent - context and usage are tracked automatically\nresult = await agent.run(\"What files are in the current directory?\")\nprint(result.output)\n\n# Check usage and cost\nprint(agent.get_usage())  # TokenUsage(prompt_tokens=..., request_count=1)\nprint(agent.get_cost())   # Cost in USD\n</code></pre>"},{"location":"#installation","title":"Installation","text":"uv (recommended)pip <pre><code>uv add pydantic-agent\n</code></pre> <pre><code>pip install pydantic-agent\n</code></pre>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li> <p>:material-rocket-launch: Getting Started</p> <p>Install the package and run your first agent in under 5 minutes.</p> <p>:octicons-arrow-right-24: Quick Start</p> </li> <li> <p>:material-book-open-variant: User Guide</p> <p>Learn how to use all the features of Pydantic Agent.</p> <p>:octicons-arrow-right-24: User Guide</p> </li> <li> <p>:material-school: Tutorials</p> <p>Step-by-step guides for common use cases.</p> <p>:octicons-arrow-right-24: Tutorials</p> </li> <li> <p>:material-api: API Reference</p> <p>Complete reference for all classes and functions.</p> <p>:octicons-arrow-right-24: API Reference</p> </li> </ul>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to Pydantic Agent will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"[Unreleased]","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Documentation website with MkDocs Material theme</li> <li>Comprehensive API reference with mkdocstrings</li> <li>User guides and tutorials</li> <li>Architecture and concepts documentation</li> </ul>"},{"location":"changelog/#010-2024-xx-xx","title":"[0.1.0] - 2024-XX-XX","text":""},{"location":"changelog/#added_1","title":"Added","text":""},{"location":"changelog/#core","title":"Core","text":"<ul> <li><code>Agent</code> class wrapping pydantic-ai with enterprise features</li> <li><code>AgentConfig</code> for agent behavior configuration</li> <li><code>AgentResult</code> wrapper for run results</li> <li>Automatic context tracking across runs</li> <li>Built-in token counting and usage tracking</li> <li>Cost estimation for API calls</li> </ul>"},{"location":"changelog/#configuration","title":"Configuration","text":"<ul> <li><code>AgentSettings</code> with multi-source configuration loading</li> <li>Environment variable support (<code>AGENTS_*</code> prefix)</li> <li><code>.env</code> file support (project and user-wide)</li> <li>TOML and YAML configuration file support</li> <li><code>ModelBackendSettings</code> for model connection</li> <li><code>LoggingConfig</code>, <code>ErrorRecoveryConfig</code>, etc.</li> </ul>"},{"location":"changelog/#context-management","title":"Context Management","text":"<ul> <li><code>ContextManager</code> for conversation context</li> <li><code>CompactionConfig</code> for compaction settings</li> <li>5 compaction strategies:</li> <li><code>sliding_window</code> - Remove oldest messages</li> <li><code>summarize_older</code> - LLM summarization</li> <li><code>selective_pruning</code> - Remove tool pairs</li> <li><code>importance_scoring</code> - LLM-based scoring</li> <li><code>hybrid</code> - Combined strategies</li> <li>Auto-compaction when thresholds reached</li> </ul>"},{"location":"changelog/#token-tracking","title":"Token Tracking","text":"<ul> <li><code>TokenCounter</code> using tiktoken</li> <li><code>UsageTracker</code> for per-request tracking</li> <li><code>CostEstimator</code> with default model pricing</li> <li><code>TokenUsage</code>, <code>UsageRecord</code>, <code>CostBreakdown</code> data classes</li> </ul>"},{"location":"changelog/#workflows","title":"Workflows","text":"<ul> <li><code>Workflow</code> abstract base class</li> <li><code>WorkflowConfig</code> for workflow settings</li> <li><code>WorkflowHooks</code> for lifecycle callbacks</li> <li><code>WorkflowState</code>, <code>WorkflowStep</code>, <code>WorkflowResult</code></li> <li><code>ReActWorkflow</code> implementation:</li> <li>Thought-Action-Observation loop</li> <li><code>ReActConfig</code> with reasoning settings</li> <li><code>ReActState</code> with scratchpad</li> <li><code>ReActHooks</code> for ReAct-specific callbacks</li> </ul>"},{"location":"changelog/#built-in-tools","title":"Built-in Tools","text":"<ul> <li>Filesystem: <code>read_file</code>, <code>write_file</code>, <code>list_directory</code>, etc.</li> <li>Search: <code>glob_search</code>, <code>grep_search</code></li> <li>Shell: <code>run_bash</code></li> <li><code>FilesystemSecurity</code> for sandboxing</li> <li><code>ToolRegistry</code> for tool management</li> </ul>"},{"location":"changelog/#mcp-integration","title":"MCP Integration","text":"<ul> <li><code>MCPClientManager</code> for server connections</li> <li><code>MCPServerConfig</code> for server configuration</li> <li><code>MCPAuthConfig</code> for authentication</li> <li>Stdio and SSE transport support</li> </ul>"},{"location":"changelog/#model-backends","title":"Model Backends","text":"<ul> <li><code>OpenAICompatibleBackend</code> for OpenAI-compatible APIs</li> <li>Factory functions: <code>create_ollama_backend</code>, <code>create_vllm_backend</code>, <code>create_lmstudio_backend</code></li> <li><code>ModelProfile</code> for model capabilities</li> <li><code>get_profile()</code> for model info lookup</li> </ul>"},{"location":"changelog/#error-handling","title":"Error Handling","text":"<ul> <li>Custom exception hierarchy (<code>AgentError</code>, <code>ModelBackendError</code>, etc.)</li> <li><code>CircuitBreaker</code> for preventing cascading failures</li> <li><code>create_retry_decorator</code> for retry logic</li> <li><code>ErrorRecoveryConfig</code> with retry levels</li> </ul>"},{"location":"changelog/#observability","title":"Observability","text":"<ul> <li><code>setup_logging</code> with text/JSON formats</li> <li><code>AgentLogger</code> with sensitive data redaction</li> <li><code>RequestTracer</code> for request tracing</li> <li><code>OTelIntegration</code> for OpenTelemetry support</li> </ul>"},{"location":"changelog/#dependencies","title":"Dependencies","text":"<ul> <li>pydantic-ai &gt;= 0.0.49</li> <li>pydantic &gt;= 2.0</li> <li>pydantic-settings &gt;= 2.0</li> <li>httpx &gt;= 0.27</li> <li>tenacity &gt;= 8.0</li> <li>tiktoken &gt;= 0.7</li> <li>Optional: OpenTelemetry packages</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>Thank you for your interest in contributing to Pydantic Agent!</p>"},{"location":"contributing/#development-setup","title":"Development Setup","text":""},{"location":"contributing/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.12 or later</li> <li>uv package manager</li> </ul>"},{"location":"contributing/#clone-and-install","title":"Clone and Install","text":"<pre><code># Clone the repository\ngit clone https://github.com/sequenzia/pydantic-agent.git\ncd pydantic-agent\n\n# Install dependencies\nuv sync --group dev\n\n# Verify installation\nuv run pytest --version\n</code></pre>"},{"location":"contributing/#development-workflow","title":"Development Workflow","text":""},{"location":"contributing/#running-tests","title":"Running Tests","text":"<pre><code># Run all tests\nuv run pytest\n\n# Run with coverage\nuv run pytest --cov=pydantic_agent\n\n# Run specific test file\nuv run pytest tests/unit/test_config.py\n\n# Run tests matching pattern\nuv run pytest -k \"test_agent\"\n</code></pre>"},{"location":"contributing/#code-quality","title":"Code Quality","text":"<pre><code># Format code\nuv run ruff format\n\n# Check formatting\nuv run ruff format --check\n\n# Lint code\nuv run ruff check\n\n# Auto-fix lint issues\nuv run ruff check --fix\n\n# Type checking (when configured)\nuv run ty check\n</code></pre>"},{"location":"contributing/#documentation","title":"Documentation","text":"<pre><code># Install docs dependencies\nuv sync --group docs\n\n# Serve docs locally\nuv run mkdocs serve\n\n# Build docs\nuv run mkdocs build\n</code></pre>"},{"location":"contributing/#code-standards","title":"Code Standards","text":""},{"location":"contributing/#python-style","title":"Python Style","text":"<ul> <li>Python 3.12+ features are welcome</li> <li>Type annotations on all public APIs</li> <li>Google-style docstrings for documentation</li> <li>ruff for linting and formatting (line-length 100)</li> </ul>"},{"location":"contributing/#example-docstring","title":"Example Docstring","text":"<pre><code>def calculate_cost(tokens: int, model: str) -&gt; float:\n    \"\"\"\n    Calculate the cost for token usage.\n\n    Args:\n        tokens: Number of tokens used\n        model: Model identifier (e.g., \"gpt-4o\")\n\n    Returns:\n        Estimated cost in USD\n\n    Raises:\n        ValueError: If model is not recognized\n\n    Example:\n        &gt;&gt;&gt; calculate_cost(1000, \"gpt-4o\")\n        0.0025\n    \"\"\"\n</code></pre>"},{"location":"contributing/#testing-guidelines","title":"Testing Guidelines","text":"<ul> <li>Use <code>pytest</code> for all tests</li> <li>Use <code>TestModel</code> from pydantic-ai for deterministic testing</li> <li>Block real model requests in tests (see <code>conftest.py</code>)</li> <li>Use <code>respx</code> for HTTP mocking</li> <li>Target 90% code coverage</li> </ul> <pre><code>from pydantic_ai.models.test import TestModel\nfrom pydantic_ai import models\n\n# Block real requests\nmodels.ALLOW_MODEL_REQUESTS = False\n\ndef test_agent_with_test_model():\n    agent = Agent(TestModel())\n    result = agent.run_sync(\"Hello\")\n    assert result.output == \"test response\"\n</code></pre>"},{"location":"contributing/#commit-messages","title":"Commit Messages","text":"<p>Use Conventional Commits:</p> <pre><code>feat: add new compaction strategy\nfix: handle empty message list\ndocs: update API reference\ntest: add workflow tests\nrefactor: simplify token counting\n</code></pre>"},{"location":"contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Fork the repository</li> <li>Create a feature branch (<code>git checkout -b feature/my-feature</code>)</li> <li>Make your changes</li> <li>Add tests for new functionality</li> <li>Run tests and linting (<code>uv run pytest &amp;&amp; uv run ruff check</code>)</li> <li>Commit with a descriptive message</li> <li>Push to your fork</li> <li>Open a pull request</li> </ol>"},{"location":"contributing/#pr-checklist","title":"PR Checklist","text":"<ul> <li>[ ] Tests pass (<code>uv run pytest</code>)</li> <li>[ ] Linting passes (<code>uv run ruff check</code>)</li> <li>[ ] Coverage maintained at 90%+</li> <li>[ ] Documentation updated if needed</li> <li>[ ] Commit messages follow conventions</li> </ul>"},{"location":"contributing/#project-structure","title":"Project Structure","text":"<pre><code>src/pydantic_agent/\n\u251c\u2500\u2500 agent/           # Core agent\n\u251c\u2500\u2500 config/          # Configuration\n\u251c\u2500\u2500 context/         # Context management\n\u251c\u2500\u2500 tokens/          # Token tracking\n\u251c\u2500\u2500 workflows/       # Workflow orchestration\n\u251c\u2500\u2500 tools/           # Built-in tools\n\u251c\u2500\u2500 mcp/             # MCP integration\n\u251c\u2500\u2500 backends/        # Model backends\n\u251c\u2500\u2500 observability/   # Logging/tracing\n\u2514\u2500\u2500 errors/          # Error handling\n\ntests/\n\u251c\u2500\u2500 unit/            # Unit tests\n\u251c\u2500\u2500 integration/     # Integration tests\n\u251c\u2500\u2500 fixtures/        # Test fixtures\n\u2514\u2500\u2500 conftest.py      # Pytest configuration\n\ndocs/\n\u251c\u2500\u2500 getting-started/ # Getting started guides\n\u251c\u2500\u2500 user-guide/      # User guides\n\u251c\u2500\u2500 tutorials/       # Tutorials\n\u251c\u2500\u2500 concepts/        # Concept explanations\n\u2514\u2500\u2500 api/             # API reference\n</code></pre>"},{"location":"contributing/#getting-help","title":"Getting Help","text":"<ul> <li>Issues: GitHub Issues</li> <li>Discussions: GitHub Discussions</li> </ul>"},{"location":"contributing/#license","title":"License","text":"<p>By contributing, you agree that your contributions will be licensed under the MIT License.</p>"},{"location":"api/","title":"API Reference","text":"<p>Complete reference for all Pydantic Agent classes and functions.</p>"},{"location":"api/#main-package","title":"Main Package","text":"<pre><code>from pydantic_agent import (\n    # Core\n    Agent,\n    AgentConfig,\n    AgentResult,\n    AgentSettings,\n\n    # Context\n    CompactionConfig,\n    CompactionResult,\n    ContextState,\n\n    # Tokens\n    CostBreakdown,\n    TokenUsage,\n    UsageRecord,\n\n    # Workflows\n    Workflow,\n    WorkflowConfig,\n    WorkflowHooks,\n    WorkflowResult,\n    WorkflowState,\n    WorkflowStep,\n)\n</code></pre>"},{"location":"api/#module-reference","title":"Module Reference","text":""},{"location":"api/#core","title":"Core","text":"Module Description Agent Core agent class and configuration Config Settings and configuration classes"},{"location":"api/#features","title":"Features","text":"Module Description Context Context management and compaction Tokens Token counting and cost estimation Workflows Workflow orchestration Tools Built-in tools"},{"location":"api/#integration","title":"Integration","text":"Module Description MCP Model Context Protocol integration Backends Model backend adapters"},{"location":"api/#infrastructure","title":"Infrastructure","text":"Module Description Errors Exceptions and error handling Observability Logging and tracing"},{"location":"api/#import-patterns","title":"Import Patterns","text":""},{"location":"api/#recommended-imports","title":"Recommended Imports","text":"<pre><code># Core functionality\nfrom pydantic_agent import Agent, AgentConfig, AgentSettings\n\n# Tools\nfrom pydantic_agent.tools import read_file, write_file, run_bash\n\n# Workflows\nfrom pydantic_agent.workflows import ReActWorkflow, ReActConfig\n\n# Context (advanced)\nfrom pydantic_agent.context import ContextManager, CompactionConfig\n\n# MCP\nfrom pydantic_agent.mcp import MCPClientManager, MCPServerConfig\n\n# Backends\nfrom pydantic_agent.backends import create_ollama_backend, get_profile\n</code></pre>"},{"location":"api/agent/","title":"Agent Module","text":"<p>The core agent module provides the main <code>Agent</code> class and related configuration.</p>"},{"location":"api/agent/#classes","title":"Classes","text":"Class Description Agent Main agent class wrapping pydantic-ai AgentConfig Configuration for agent behavior AgentResult Result from agent execution"},{"location":"api/agent/#quick-example","title":"Quick Example","text":"<pre><code>from pydantic_agent import Agent, AgentConfig, AgentSettings\n\n# Simple usage\nagent = Agent(\"gpt-4o\")\nresult = agent.run_sync(\"Hello!\")\n\n# With configuration\nconfig = AgentConfig(\n    system_prompt=\"You are helpful.\",\n    max_iterations=15,\n)\nagent = Agent(\"gpt-4o\", config=config)\n\n# With settings\nsettings = AgentSettings()\nagent = Agent(settings=settings)\n</code></pre>"},{"location":"api/agent/#imports","title":"Imports","text":"<pre><code>from pydantic_agent import Agent, AgentConfig, AgentResult\nfrom pydantic_agent.agent import Agent, AgentConfig, AgentResult\n</code></pre>"},{"location":"api/agent/agent/","title":"Agent","text":"<p>The main agent class that wraps pydantic-ai with additional features.</p>"},{"location":"api/agent/agent/#quick-example","title":"Quick Example","text":"<pre><code>from pydantic_agent import Agent, AgentSettings\n\nsettings = AgentSettings()\nagent = Agent(\"gpt-4o\", settings=settings)\n\n# Run agent\nresult = await agent.run(\"Hello!\")\nprint(result.output)\n\n# Check usage\nprint(agent.get_usage())\nprint(agent.get_cost())\n</code></pre>"},{"location":"api/agent/agent/#api-reference","title":"API Reference","text":""},{"location":"api/agent/agent/#pydantic_agent.agent.core.Agent","title":"Agent","text":"<pre><code>Agent(\n    model: str | Model | None = None,\n    *,\n    tools: Sequence[Callable[..., Any] | ToolDefinition]\n    | None = None,\n    system_prompt: str = \"\",\n    deps_type: type[DepsT] | None = None,\n    output_type: type[OutputT] | None = None,\n    config: AgentConfig | None = None,\n    settings: AgentSettings | None = None,\n)\n</code></pre> <p>               Bases: <code>Generic[DepsT, OutputT]</code></p> <p>AI Agent with tool-calling capabilities.</p> <p>This is a thin wrapper around pydantic-ai's Agent class that adds: - Configuration via AgentSettings - Context management and compaction - Token usage tracking - Enhanced observability</p> Example <p>from pydantic_agent import Agent</p> <p>agent = Agent( ...     \"openai:gpt-4\", ...     system_prompt=\"You are a helpful assistant.\", ... ) result = await agent.run(\"Hello, world!\") print(result.output)</p> <p>Initialize the agent.</p> PARAMETER DESCRIPTION <code>model</code> <p>Model to use (string identifier or Model instance). If not provided, uses settings.model_backend configuration.</p> <p> TYPE: <code>str | Model | None</code> DEFAULT: <code>None</code> </p> <code>tools</code> <p>Optional list of tools to register.</p> <p> TYPE: <code>Sequence[Callable[..., Any] | ToolDefinition] | None</code> DEFAULT: <code>None</code> </p> <code>system_prompt</code> <p>System prompt for the agent.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>deps_type</code> <p>Type of dependencies for tool calls.</p> <p> TYPE: <code>type[DepsT] | None</code> DEFAULT: <code>None</code> </p> <code>output_type</code> <p>Expected output type.</p> <p> TYPE: <code>type[OutputT] | None</code> DEFAULT: <code>None</code> </p> <code>config</code> <p>Agent execution configuration.</p> <p> TYPE: <code>AgentConfig | None</code> DEFAULT: <code>None</code> </p> <code>settings</code> <p>Full agent settings (for model backend, etc.).</p> <p> TYPE: <code>AgentSettings | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If neither model nor settings is provided.</p> Source code in <code>src/pydantic_agent/agent/core.py</code> <pre><code>def __init__(\n    self,\n    model: str | Model | None = None,\n    *,\n    tools: Sequence[Callable[..., Any] | ToolDefinition] | None = None,\n    system_prompt: str = \"\",\n    deps_type: type[DepsT] | None = None,\n    output_type: type[OutputT] | None = None,\n    config: AgentConfig | None = None,\n    settings: AgentSettings | None = None,\n) -&gt; None:\n    \"\"\"Initialize the agent.\n\n    Args:\n        model: Model to use (string identifier or Model instance).\n            If not provided, uses settings.model_backend configuration.\n        tools: Optional list of tools to register.\n        system_prompt: System prompt for the agent.\n        deps_type: Type of dependencies for tool calls.\n        output_type: Expected output type.\n        config: Agent execution configuration.\n        settings: Full agent settings (for model backend, etc.).\n\n    Raises:\n        ValueError: If neither model nor settings is provided.\n    \"\"\"\n    self._config = config or AgentConfig(system_prompt=system_prompt)\n    self._settings = settings or AgentSettings()\n\n    # Determine model name and whether to use settings for connection config\n    if model is None:\n        if settings is None:\n            raise ValueError(\"Either 'model' or 'settings' must be provided\")\n        model_name: str | None = self._settings.model_backend.model\n    elif isinstance(model, str):\n        model_name = model\n    else:\n        # model is already a Model instance\n        model_name = None\n\n    # Construct model using settings connection config when applicable\n    if model_name is not None and settings is not None:\n        from pydantic_ai.models.openai import OpenAIChatModel\n        from pydantic_ai.providers.openai import OpenAIProvider\n\n        model = OpenAIChatModel(\n            model_name,\n            provider=OpenAIProvider(\n                base_url=self._settings.model_backend.base_url,\n                api_key=(\n                    self._settings.model_backend.api_key.get_secret_value()\n                    if self._settings.model_backend.api_key\n                    else None\n                ),\n            ),\n        )\n\n    # Create the underlying pydantic-ai agent\n    agent_kwargs: dict[str, Any] = {\n        \"system_prompt\": self._config.system_prompt,\n    }\n\n    if tools:\n        agent_kwargs[\"tools\"] = list(tools)\n\n    if deps_type:\n        agent_kwargs[\"deps_type\"] = deps_type\n\n    if output_type:\n        agent_kwargs[\"output_type\"] = output_type\n\n    self._agent: PydanticAgent[DepsT, OutputT] = PydanticAgent(model, **agent_kwargs)\n\n    # Store model name for cost estimation\n    self._model_name = model_name\n\n    # Initialize token tracking (always on)\n    tokenizer_cfg = self._config.tokenizer or self._settings.tokenizer\n    self._token_counter = TokenCounter(config=tokenizer_cfg)\n    self._usage_tracker = UsageTracker(cost_rates=self._settings.cost_rates)\n    self._cost_estimator = CostEstimator(custom_rates=self._settings.cost_rates)\n\n    # Initialize context manager (if enabled)\n    if self._config.track_context:\n        context_cfg = self._config.context or self._settings.context\n        self._context_manager: ContextManager | None = ContextManager(\n            config=context_cfg,\n            token_counter=self._token_counter,\n        )\n        if self._config.system_prompt:\n            self._context_manager.set_system_prompt(self._config.system_prompt)\n    else:\n        self._context_manager = None\n</code></pre>"},{"location":"api/agent/agent/#pydantic_agent.agent.core.Agent.run","title":"run  <code>async</code>","text":"<pre><code>run(\n    prompt: str,\n    *,\n    deps: DepsT | None = None,\n    message_history: list[ModelMessage] | None = None,\n    usage_limits: UsageLimits | None = None,\n) -&gt; AgentResult[OutputT]\n</code></pre> <p>Run the agent with the given prompt.</p> PARAMETER DESCRIPTION <code>prompt</code> <p>User prompt to process.</p> <p> TYPE: <code>str</code> </p> <code>deps</code> <p>Optional dependencies for tool calls.</p> <p> TYPE: <code>DepsT | None</code> DEFAULT: <code>None</code> </p> <code>message_history</code> <p>Optional message history for context. If None and context tracking is enabled, uses internal context.</p> <p> TYPE: <code>list[ModelMessage] | None</code> DEFAULT: <code>None</code> </p> <code>usage_limits</code> <p>Optional usage limits.</p> <p> TYPE: <code>UsageLimits | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>AgentResult[OutputT]</code> <p>AgentResult containing the output and metadata.</p> Source code in <code>src/pydantic_agent/agent/core.py</code> <pre><code>async def run(\n    self,\n    prompt: str,\n    *,\n    deps: DepsT | None = None,\n    message_history: list[ModelMessage] | None = None,\n    usage_limits: UsageLimits | None = None,\n) -&gt; AgentResult[OutputT]:\n    \"\"\"Run the agent with the given prompt.\n\n    Args:\n        prompt: User prompt to process.\n        deps: Optional dependencies for tool calls.\n        message_history: Optional message history for context.\n            If None and context tracking is enabled, uses internal context.\n        usage_limits: Optional usage limits.\n\n    Returns:\n        AgentResult containing the output and metadata.\n    \"\"\"\n    kwargs: dict[str, Any] = {}\n    if deps is not None:\n        kwargs[\"deps\"] = deps\n    if usage_limits is not None:\n        kwargs[\"usage_limits\"] = usage_limits\n\n    # Determine message history to use\n    if message_history is not None:\n        # Explicit history provided - use it\n        kwargs[\"message_history\"] = message_history\n    elif self._context_manager is not None:\n        # Use internal context (convert to pydantic-ai format)\n        internal_messages = self._context_manager.get_messages()\n        if internal_messages:\n            kwargs[\"message_history\"] = dicts_to_model_messages(internal_messages)\n\n    result = await self._agent.run(prompt, **kwargs)\n    wrapped_result = AgentResult(result)\n\n    # Post-run tracking\n    await self._post_run_hook(wrapped_result)\n\n    return wrapped_result\n</code></pre>"},{"location":"api/agent/agent/#pydantic_agent.agent.core.Agent.run_sync","title":"run_sync","text":"<pre><code>run_sync(\n    prompt: str,\n    *,\n    deps: DepsT | None = None,\n    message_history: list[ModelMessage] | None = None,\n    usage_limits: UsageLimits | None = None,\n) -&gt; AgentResult[OutputT]\n</code></pre> <p>Run the agent synchronously.</p> PARAMETER DESCRIPTION <code>prompt</code> <p>User prompt to process.</p> <p> TYPE: <code>str</code> </p> <code>deps</code> <p>Optional dependencies for tool calls.</p> <p> TYPE: <code>DepsT | None</code> DEFAULT: <code>None</code> </p> <code>message_history</code> <p>Optional message history for context. If None and context tracking is enabled, uses internal context.</p> <p> TYPE: <code>list[ModelMessage] | None</code> DEFAULT: <code>None</code> </p> <code>usage_limits</code> <p>Optional usage limits.</p> <p> TYPE: <code>UsageLimits | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>AgentResult[OutputT]</code> <p>AgentResult containing the output and metadata.</p> Source code in <code>src/pydantic_agent/agent/core.py</code> <pre><code>def run_sync(\n    self,\n    prompt: str,\n    *,\n    deps: DepsT | None = None,\n    message_history: list[ModelMessage] | None = None,\n    usage_limits: UsageLimits | None = None,\n) -&gt; AgentResult[OutputT]:\n    \"\"\"Run the agent synchronously.\n\n    Args:\n        prompt: User prompt to process.\n        deps: Optional dependencies for tool calls.\n        message_history: Optional message history for context.\n            If None and context tracking is enabled, uses internal context.\n        usage_limits: Optional usage limits.\n\n    Returns:\n        AgentResult containing the output and metadata.\n    \"\"\"\n    kwargs: dict[str, Any] = {}\n    if deps is not None:\n        kwargs[\"deps\"] = deps\n    if usage_limits is not None:\n        kwargs[\"usage_limits\"] = usage_limits\n\n    # Determine message history to use\n    if message_history is not None:\n        # Explicit history provided - use it\n        kwargs[\"message_history\"] = message_history\n    elif self._context_manager is not None:\n        # Use internal context (convert to pydantic-ai format)\n        internal_messages = self._context_manager.get_messages()\n        if internal_messages:\n            kwargs[\"message_history\"] = dicts_to_model_messages(internal_messages)\n\n    result = self._agent.run_sync(prompt, **kwargs)\n    wrapped_result = AgentResult(result)\n\n    # Post-run tracking\n    self._post_run_hook_sync(wrapped_result)\n\n    return wrapped_result\n</code></pre>"},{"location":"api/agent/agent/#pydantic_agent.agent.core.Agent.run_stream","title":"run_stream  <code>async</code>","text":"<pre><code>run_stream(\n    prompt: str,\n    *,\n    deps: DepsT | None = None,\n    message_history: list[ModelMessage] | None = None,\n    usage_limits: UsageLimits | None = None,\n) -&gt; AsyncIterator[StreamedRunResult[OutputT]]\n</code></pre> <p>Run the agent with streaming output.</p> PARAMETER DESCRIPTION <code>prompt</code> <p>User prompt to process.</p> <p> TYPE: <code>str</code> </p> <code>deps</code> <p>Optional dependencies for tool calls.</p> <p> TYPE: <code>DepsT | None</code> DEFAULT: <code>None</code> </p> <code>message_history</code> <p>Optional message history for context. If None and context tracking is enabled, uses internal context.</p> <p> TYPE: <code>list[ModelMessage] | None</code> DEFAULT: <code>None</code> </p> <code>usage_limits</code> <p>Optional usage limits.</p> <p> TYPE: <code>UsageLimits | None</code> DEFAULT: <code>None</code> </p> YIELDS DESCRIPTION <code>AsyncIterator[StreamedRunResult[OutputT]]</code> <p>StreamedRunResult with streaming response events.</p> Note <p>Usage and context tracking occurs after the stream is consumed.</p> Source code in <code>src/pydantic_agent/agent/core.py</code> <pre><code>async def run_stream(\n    self,\n    prompt: str,\n    *,\n    deps: DepsT | None = None,\n    message_history: list[ModelMessage] | None = None,\n    usage_limits: UsageLimits | None = None,\n) -&gt; AsyncIterator[StreamedRunResult[OutputT]]:\n    \"\"\"Run the agent with streaming output.\n\n    Args:\n        prompt: User prompt to process.\n        deps: Optional dependencies for tool calls.\n        message_history: Optional message history for context.\n            If None and context tracking is enabled, uses internal context.\n        usage_limits: Optional usage limits.\n\n    Yields:\n        StreamedRunResult with streaming response events.\n\n    Note:\n        Usage and context tracking occurs after the stream is consumed.\n    \"\"\"\n    kwargs: dict[str, Any] = {}\n    if deps is not None:\n        kwargs[\"deps\"] = deps\n    if usage_limits is not None:\n        kwargs[\"usage_limits\"] = usage_limits\n\n    # Determine message history to use\n    if message_history is not None:\n        # Explicit history provided - use it\n        kwargs[\"message_history\"] = message_history\n    elif self._context_manager is not None:\n        # Use internal context (convert to pydantic-ai format)\n        internal_messages = self._context_manager.get_messages()\n        if internal_messages:\n            kwargs[\"message_history\"] = dicts_to_model_messages(internal_messages)\n\n    async with self._agent.run_stream(prompt, **kwargs) as result:\n        yield result\n        # After stream is consumed and yield returns, track usage and messages\n        self._usage_tracker.record_usage(result.usage(), model=self._model_name)\n        if self._context_manager is not None:\n            new_messages = model_messages_to_dicts(result.all_messages())\n            self._context_manager.add_messages(new_messages)\n            if self._config.auto_compact and self._context_manager.should_compact():\n                await self._context_manager.compact()\n</code></pre>"},{"location":"api/agent/agent/#pydantic_agent.agent.core.Agent.tool","title":"tool","text":"<pre><code>tool(\n    func: Callable[..., Any] | None = None,\n    *,\n    name: str | None = None,\n    description: str | None = None,\n    retries: int | None = None,\n) -&gt; Callable[..., Any]\n</code></pre> <p>Register a tool function with the agent.</p> <p>Can be used as a decorator with or without arguments.</p> PARAMETER DESCRIPTION <code>func</code> <p>The tool function to register.</p> <p> TYPE: <code>Callable[..., Any] | None</code> DEFAULT: <code>None</code> </p> <code>name</code> <p>Optional custom name for the tool.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>description</code> <p>Optional description override.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>retries</code> <p>Optional retry count override.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Callable[..., Any]</code> <p>The decorated function.</p> Example <p>@agent.tool ... async def read_file(path: str) -&gt; str: ...     return Path(path).read_text()</p> Source code in <code>src/pydantic_agent/agent/core.py</code> <pre><code>def tool(\n    self,\n    func: Callable[..., Any] | None = None,\n    *,\n    name: str | None = None,\n    description: str | None = None,\n    retries: int | None = None,\n) -&gt; Callable[..., Any]:\n    \"\"\"Register a tool function with the agent.\n\n    Can be used as a decorator with or without arguments.\n\n    Args:\n        func: The tool function to register.\n        name: Optional custom name for the tool.\n        description: Optional description override.\n        retries: Optional retry count override.\n\n    Returns:\n        The decorated function.\n\n    Example:\n        &gt;&gt;&gt; @agent.tool\n        ... async def read_file(path: str) -&gt; str:\n        ...     return Path(path).read_text()\n    \"\"\"\n    kwargs: dict[str, Any] = {}\n    if name:\n        kwargs[\"name\"] = name\n    if description:\n        kwargs[\"description\"] = description\n    if retries is not None:\n        kwargs[\"retries\"] = retries\n\n    if func is not None:\n        return self._agent.tool(**kwargs)(func)\n\n    def decorator(f: Callable[..., Any]) -&gt; Callable[..., Any]:\n        return self._agent.tool(**kwargs)(f)\n\n    return decorator\n</code></pre>"},{"location":"api/agent/agent/#pydantic_agent.agent.core.Agent.tool_plain","title":"tool_plain","text":"<pre><code>tool_plain(\n    func: Callable[..., Any] | None = None,\n    *,\n    name: str | None = None,\n    description: str | None = None,\n    retries: int | None = None,\n) -&gt; Callable[..., Any]\n</code></pre> <p>Register a plain tool function (no RunContext).</p> <p>Similar to tool() but for functions that don't need RunContext.</p> PARAMETER DESCRIPTION <code>func</code> <p>The tool function to register.</p> <p> TYPE: <code>Callable[..., Any] | None</code> DEFAULT: <code>None</code> </p> <code>name</code> <p>Optional custom name for the tool.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>description</code> <p>Optional description override.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>retries</code> <p>Optional retry count override.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Callable[..., Any]</code> <p>The decorated function.</p> Source code in <code>src/pydantic_agent/agent/core.py</code> <pre><code>def tool_plain(\n    self,\n    func: Callable[..., Any] | None = None,\n    *,\n    name: str | None = None,\n    description: str | None = None,\n    retries: int | None = None,\n) -&gt; Callable[..., Any]:\n    \"\"\"Register a plain tool function (no RunContext).\n\n    Similar to tool() but for functions that don't need RunContext.\n\n    Args:\n        func: The tool function to register.\n        name: Optional custom name for the tool.\n        description: Optional description override.\n        retries: Optional retry count override.\n\n    Returns:\n        The decorated function.\n    \"\"\"\n    kwargs: dict[str, Any] = {}\n    if name:\n        kwargs[\"name\"] = name\n    if description:\n        kwargs[\"description\"] = description\n    if retries is not None:\n        kwargs[\"retries\"] = retries\n\n    if func is not None:\n        return self._agent.tool_plain(**kwargs)(func)\n\n    def decorator(f: Callable[..., Any]) -&gt; Callable[..., Any]:\n        return self._agent.tool_plain(**kwargs)(f)\n\n    return decorator\n</code></pre>"},{"location":"api/agent/agent/#pydantic_agent.agent.core.Agent.get_token_count","title":"get_token_count","text":"<pre><code>get_token_count(text: str | None = None) -&gt; int\n</code></pre> <p>Get token count for text or current context.</p> PARAMETER DESCRIPTION <code>text</code> <p>Optional text to count. If None, returns current context token count.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>int</code> <p>Token count.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If text is None and context tracking is disabled.</p> Source code in <code>src/pydantic_agent/agent/core.py</code> <pre><code>def get_token_count(self, text: str | None = None) -&gt; int:\n    \"\"\"Get token count for text or current context.\n\n    Args:\n        text: Optional text to count. If None, returns current context token count.\n\n    Returns:\n        Token count.\n\n    Raises:\n        RuntimeError: If text is None and context tracking is disabled.\n    \"\"\"\n    if text is not None:\n        return self._token_counter.count(text)\n\n    if self._context_manager is None:\n        raise RuntimeError(\n            \"Context tracking is disabled. Enable with AgentConfig(track_context=True)\"\n        )\n    return self._context_manager.get_token_count()\n</code></pre>"},{"location":"api/agent/agent/#pydantic_agent.agent.core.Agent.get_usage","title":"get_usage","text":"<pre><code>get_usage() -&gt; TokenUsage\n</code></pre> <p>Get aggregate token usage statistics.</p> RETURNS DESCRIPTION <code>TokenUsage</code> <p>TokenUsage with total prompt/completion/total tokens and request count.</p> Source code in <code>src/pydantic_agent/agent/core.py</code> <pre><code>def get_usage(self) -&gt; TokenUsage:\n    \"\"\"Get aggregate token usage statistics.\n\n    Returns:\n        TokenUsage with total prompt/completion/total tokens and request count.\n    \"\"\"\n    return self._usage_tracker.get_total_usage()\n</code></pre>"},{"location":"api/agent/agent/#pydantic_agent.agent.core.Agent.get_usage_history","title":"get_usage_history","text":"<pre><code>get_usage_history() -&gt; list[UsageRecord]\n</code></pre> <p>Get detailed per-request usage history.</p> RETURNS DESCRIPTION <code>list[UsageRecord]</code> <p>List of UsageRecord objects for each run.</p> Source code in <code>src/pydantic_agent/agent/core.py</code> <pre><code>def get_usage_history(self) -&gt; list[UsageRecord]:\n    \"\"\"Get detailed per-request usage history.\n\n    Returns:\n        List of UsageRecord objects for each run.\n    \"\"\"\n    return self._usage_tracker.get_usage_history()\n</code></pre>"},{"location":"api/agent/agent/#pydantic_agent.agent.core.Agent.get_cost","title":"get_cost","text":"<pre><code>get_cost(model: str | None = None) -&gt; float\n</code></pre> <p>Get estimated cost for all usage.</p> PARAMETER DESCRIPTION <code>model</code> <p>Model name for rate lookup. Defaults to agent's model.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>float</code> <p>Estimated cost in USD.</p> Source code in <code>src/pydantic_agent/agent/core.py</code> <pre><code>def get_cost(self, model: str | None = None) -&gt; float:\n    \"\"\"Get estimated cost for all usage.\n\n    Args:\n        model: Model name for rate lookup. Defaults to agent's model.\n\n    Returns:\n        Estimated cost in USD.\n    \"\"\"\n    usage = self._usage_tracker.get_total_usage()\n    model_for_cost = model or self._model_name or \"default\"\n    return self._cost_estimator.estimate(usage, model_for_cost).total_cost\n</code></pre>"},{"location":"api/agent/agent/#pydantic_agent.agent.core.Agent.get_cost_breakdown","title":"get_cost_breakdown","text":"<pre><code>get_cost_breakdown(\n    model: str | None = None,\n) -&gt; CostBreakdown\n</code></pre> <p>Get detailed cost breakdown.</p> PARAMETER DESCRIPTION <code>model</code> <p>Model name for rate lookup. Defaults to agent's model.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>CostBreakdown</code> <p>CostBreakdown with prompt_cost, completion_cost, total_cost.</p> Source code in <code>src/pydantic_agent/agent/core.py</code> <pre><code>def get_cost_breakdown(self, model: str | None = None) -&gt; CostBreakdown:\n    \"\"\"Get detailed cost breakdown.\n\n    Args:\n        model: Model name for rate lookup. Defaults to agent's model.\n\n    Returns:\n        CostBreakdown with prompt_cost, completion_cost, total_cost.\n    \"\"\"\n    usage = self._usage_tracker.get_total_usage()\n    model_for_cost = model or self._model_name or \"default\"\n    return self._cost_estimator.estimate(usage, model_for_cost)\n</code></pre>"},{"location":"api/agent/agent/#pydantic_agent.agent.core.Agent.get_messages","title":"get_messages","text":"<pre><code>get_messages() -&gt; list[dict[str, Any]]\n</code></pre> <p>Get all messages in the context.</p> RETURNS DESCRIPTION <code>list[dict[str, Any]]</code> <p>List of message dictionaries.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If context tracking is disabled.</p> Source code in <code>src/pydantic_agent/agent/core.py</code> <pre><code>def get_messages(self) -&gt; list[dict[str, Any]]:\n    \"\"\"Get all messages in the context.\n\n    Returns:\n        List of message dictionaries.\n\n    Raises:\n        RuntimeError: If context tracking is disabled.\n    \"\"\"\n    if self._context_manager is None:\n        raise RuntimeError(\n            \"Context tracking is disabled. Enable with AgentConfig(track_context=True)\"\n        )\n    return self._context_manager.get_messages()\n</code></pre>"},{"location":"api/agent/agent/#pydantic_agent.agent.core.Agent.should_compact","title":"should_compact","text":"<pre><code>should_compact() -&gt; bool\n</code></pre> <p>Check if context compaction threshold is reached.</p> RETURNS DESCRIPTION <code>bool</code> <p>True if compaction should be triggered.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If context tracking is disabled.</p> Source code in <code>src/pydantic_agent/agent/core.py</code> <pre><code>def should_compact(self) -&gt; bool:\n    \"\"\"Check if context compaction threshold is reached.\n\n    Returns:\n        True if compaction should be triggered.\n\n    Raises:\n        RuntimeError: If context tracking is disabled.\n    \"\"\"\n    if self._context_manager is None:\n        raise RuntimeError(\n            \"Context tracking is disabled. Enable with AgentConfig(track_context=True)\"\n        )\n    return self._context_manager.should_compact()\n</code></pre>"},{"location":"api/agent/agent/#pydantic_agent.agent.core.Agent.compact","title":"compact  <code>async</code>","text":"<pre><code>compact() -&gt; CompactionResult\n</code></pre> <p>Manually trigger context compaction.</p> RETURNS DESCRIPTION <code>CompactionResult</code> <p>CompactionResult with details of what was done.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If context tracking is disabled.</p> Source code in <code>src/pydantic_agent/agent/core.py</code> <pre><code>async def compact(self) -&gt; CompactionResult:\n    \"\"\"Manually trigger context compaction.\n\n    Returns:\n        CompactionResult with details of what was done.\n\n    Raises:\n        RuntimeError: If context tracking is disabled.\n    \"\"\"\n    if self._context_manager is None:\n        raise RuntimeError(\n            \"Context tracking is disabled. Enable with AgentConfig(track_context=True)\"\n        )\n    return await self._context_manager.compact()\n</code></pre>"},{"location":"api/agent/agent/#pydantic_agent.agent.core.Agent.get_context_state","title":"get_context_state","text":"<pre><code>get_context_state() -&gt; ContextState\n</code></pre> <p>Get the current context state.</p> RETURNS DESCRIPTION <code>ContextState</code> <p>ContextState with token_count, message_count, etc.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If context tracking is disabled.</p> Source code in <code>src/pydantic_agent/agent/core.py</code> <pre><code>def get_context_state(self) -&gt; ContextState:\n    \"\"\"Get the current context state.\n\n    Returns:\n        ContextState with token_count, message_count, etc.\n\n    Raises:\n        RuntimeError: If context tracking is disabled.\n    \"\"\"\n    if self._context_manager is None:\n        raise RuntimeError(\n            \"Context tracking is disabled. Enable with AgentConfig(track_context=True)\"\n        )\n    return self._context_manager.get_context_state()\n</code></pre>"},{"location":"api/agent/agent/#pydantic_agent.agent.core.Agent.clear_context","title":"clear_context","text":"<pre><code>clear_context() -&gt; None\n</code></pre> <p>Clear all context (messages and compaction history).</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If context tracking is disabled.</p> Source code in <code>src/pydantic_agent/agent/core.py</code> <pre><code>def clear_context(self) -&gt; None:\n    \"\"\"Clear all context (messages and compaction history).\n\n    Raises:\n        RuntimeError: If context tracking is disabled.\n    \"\"\"\n    if self._context_manager is None:\n        raise RuntimeError(\n            \"Context tracking is disabled. Enable with AgentConfig(track_context=True)\"\n        )\n    self._context_manager.clear()\n</code></pre>"},{"location":"api/agent/agent/#pydantic_agent.agent.core.Agent.reset_tracking","title":"reset_tracking","text":"<pre><code>reset_tracking() -&gt; None\n</code></pre> <p>Reset usage tracking data (keeps context).</p> Source code in <code>src/pydantic_agent/agent/core.py</code> <pre><code>def reset_tracking(self) -&gt; None:\n    \"\"\"Reset usage tracking data (keeps context).\"\"\"\n    self._usage_tracker.reset()\n</code></pre>"},{"location":"api/agent/agent/#pydantic_agent.agent.core.Agent.reset_all","title":"reset_all","text":"<pre><code>reset_all() -&gt; None\n</code></pre> <p>Reset both context and usage tracking.</p> Source code in <code>src/pydantic_agent/agent/core.py</code> <pre><code>def reset_all(self) -&gt; None:\n    \"\"\"Reset both context and usage tracking.\"\"\"\n    self.reset_tracking()\n    if self._context_manager is not None:\n        self._context_manager.clear()\n</code></pre>"},{"location":"api/agent/config/","title":"AgentConfig","text":"<p>Configuration options for agent behavior.</p>"},{"location":"api/agent/config/#quick-example","title":"Quick Example","text":"<pre><code>from pydantic_agent import Agent, AgentConfig, CompactionConfig\n\nconfig = AgentConfig(\n    system_prompt=\"You are a helpful assistant.\",\n    max_iterations=15,\n    track_context=True,\n    auto_compact=True,\n    context=CompactionConfig(\n        strategy=\"hybrid\",\n        trigger_threshold_tokens=50000,\n    ),\n)\n\nagent = Agent(\"gpt-4o\", config=config)\n</code></pre>"},{"location":"api/agent/config/#configuration-options","title":"Configuration Options","text":"Option Type Default Description <code>system_prompt</code> str None System prompt for the agent <code>max_iterations</code> int 10 Maximum tool-calling iterations <code>track_context</code> bool True Enable message tracking <code>auto_compact</code> bool True Auto-compact when threshold reached <code>context</code> CompactionConfig None Custom compaction settings <code>tokenizer</code> TokenizerConfig None Custom tokenizer settings"},{"location":"api/agent/config/#api-reference","title":"API Reference","text":""},{"location":"api/agent/config/#pydantic_agent.agent.config.AgentConfig","title":"AgentConfig","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration for agent execution.</p> ATTRIBUTE DESCRIPTION <code>max_iterations</code> <p>Maximum tool-calling iterations before stopping.</p> <p> TYPE: <code>int</code> </p> <code>system_prompt</code> <p>System prompt for the agent.</p> <p> TYPE: <code>str</code> </p> <code>context</code> <p>Context compaction configuration. None uses settings default.</p> <p> TYPE: <code>CompactionConfig | None</code> </p> <code>tokenizer</code> <p>Tokenizer configuration. None uses settings default.</p> <p> TYPE: <code>TokenizerConfig | None</code> </p> <code>track_context</code> <p>Whether to track messages internally across runs.</p> <p> TYPE: <code>bool</code> </p> <code>auto_compact</code> <p>Whether to automatically compact when threshold is reached.</p> <p> TYPE: <code>bool</code> </p>"},{"location":"api/agent/result/","title":"AgentResult","text":"<p>Result from agent execution, wrapping pydantic-ai's RunResult.</p>"},{"location":"api/agent/result/#quick-example","title":"Quick Example","text":"<pre><code>from pydantic_agent import Agent\n\nagent = Agent(\"gpt-4o\")\nresult = await agent.run(\"What is 2 + 2?\")\n\n# Access output\nprint(result.output)  # \"4\"\n\n# Access usage\nusage = result.usage()\nprint(f\"Tokens: {usage.total_tokens}\")\n\n# Access messages\nnew_msgs = result.new_messages()\nall_msgs = result.all_messages()\n</code></pre>"},{"location":"api/agent/result/#properties-and-methods","title":"Properties and Methods","text":"Member Type Description <code>output</code> OutputT The typed output from the agent <code>data</code> OutputT Alias for output <code>usage()</code> TokenUsage Token usage for this run <code>new_messages()</code> list Messages from this run only <code>all_messages()</code> list Complete message history"},{"location":"api/agent/result/#api-reference","title":"API Reference","text":""},{"location":"api/agent/result/#pydantic_agent.agent.result.AgentResult","title":"AgentResult  <code>dataclass</code>","text":"<pre><code>AgentResult(_result: RunResult[T])\n</code></pre> <p>               Bases: <code>Generic[T]</code></p> <p>Wrapper for agent run results with additional metadata.</p> <p>Provides convenient access to the result output, message history, and usage statistics.</p> ATTRIBUTE DESCRIPTION <code>_result</code> <p>The underlying pydantic-ai RunResult.</p> <p> TYPE: <code>RunResult[T]</code> </p>"},{"location":"api/agent/result/#pydantic_agent.agent.result.AgentResult.output","title":"output  <code>property</code>","text":"<pre><code>output: T\n</code></pre> <p>Get the final output from the agent run.</p> RETURNS DESCRIPTION <code>T</code> <p>The typed output from the agent.</p>"},{"location":"api/agent/result/#pydantic_agent.agent.result.AgentResult.data","title":"data  <code>property</code>","text":"<pre><code>data: T\n</code></pre> <p>Alias for output (for backwards compatibility).</p> RETURNS DESCRIPTION <code>T</code> <p>The typed output from the agent.</p>"},{"location":"api/agent/result/#pydantic_agent.agent.result.AgentResult.usage","title":"usage","text":"<pre><code>usage() -&gt; Usage\n</code></pre> <p>Get token usage statistics for this run.</p> RETURNS DESCRIPTION <code>Usage</code> <p>Usage statistics including input/output tokens.</p> Source code in <code>src/pydantic_agent/agent/result.py</code> <pre><code>def usage(self) -&gt; Usage:\n    \"\"\"Get token usage statistics for this run.\n\n    Returns:\n        Usage statistics including input/output tokens.\n    \"\"\"\n    return self._result.usage()\n</code></pre>"},{"location":"api/agent/result/#pydantic_agent.agent.result.AgentResult.new_messages","title":"new_messages","text":"<pre><code>new_messages() -&gt; list[Any]\n</code></pre> <p>Get new messages generated during this run.</p> RETURNS DESCRIPTION <code>list[Any]</code> <p>List of messages from this run (for message history).</p> Source code in <code>src/pydantic_agent/agent/result.py</code> <pre><code>def new_messages(self) -&gt; list[Any]:\n    \"\"\"Get new messages generated during this run.\n\n    Returns:\n        List of messages from this run (for message history).\n    \"\"\"\n    return self._result.new_messages()\n</code></pre>"},{"location":"api/agent/result/#pydantic_agent.agent.result.AgentResult.all_messages","title":"all_messages","text":"<pre><code>all_messages() -&gt; list[Any]\n</code></pre> <p>Get all messages including history.</p> RETURNS DESCRIPTION <code>list[Any]</code> <p>Complete message history including new messages.</p> Source code in <code>src/pydantic_agent/agent/result.py</code> <pre><code>def all_messages(self) -&gt; list[Any]:\n    \"\"\"Get all messages including history.\n\n    Returns:\n        Complete message history including new messages.\n    \"\"\"\n    return self._result.all_messages()\n</code></pre>"},{"location":"api/backends/","title":"Backends Module","text":"<p>Model backend adapters for OpenAI-compatible APIs.</p>"},{"location":"api/backends/#classes","title":"Classes","text":"Class Description OpenAICompatibleBackend Base backend class ModelProfile Model capability info"},{"location":"api/backends/#quick-example","title":"Quick Example","text":"<pre><code>from pydantic_agent.backends import (\n    create_ollama_backend,\n    create_vllm_backend,\n    create_lmstudio_backend,\n    get_profile,\n)\n\n# Factory functions\nbackend = create_ollama_backend(\"llama3.2\")\nbackend = create_vllm_backend(\"meta-llama/Llama-3.2-3B-Instruct\")\nbackend = create_lmstudio_backend()\n\n# Get model info\nprofile = get_profile(\"gpt-4o\")\nprint(f\"Context: {profile.context_window}\")\n</code></pre>"},{"location":"api/backends/#imports","title":"Imports","text":"<pre><code>from pydantic_agent.backends import (\n    OpenAICompatibleBackend,\n    create_ollama_backend,\n    create_vllm_backend,\n    create_lmstudio_backend,\n    get_profile,\n    ModelProfile,\n)\n</code></pre>"},{"location":"api/backends/openai-compat/","title":"OpenAICompatibleBackend","text":"<p>Backend adapter for OpenAI-compatible APIs.</p>"},{"location":"api/backends/openai-compat/#quick-example","title":"Quick Example","text":"<pre><code>from pydantic_agent.backends import OpenAICompatibleBackend\n\n# Direct instantiation\nbackend = OpenAICompatibleBackend(\n    model=\"my-model\",\n    base_url=\"http://localhost:8000/v1\",\n    api_key=\"optional-key\",\n)\n\n# Or use factory functions\nfrom pydantic_agent.backends import (\n    create_ollama_backend,\n    create_vllm_backend,\n    create_lmstudio_backend,\n)\n\n# Ollama\nbackend = create_ollama_backend(\"llama3.2\")\n\n# vLLM\nbackend = create_vllm_backend(\"meta-llama/Llama-3.2-3B-Instruct\")\n\n# LM Studio\nbackend = create_lmstudio_backend()\n</code></pre>"},{"location":"api/backends/openai-compat/#factory-functions","title":"Factory Functions","text":"Function Default URL Description <code>create_ollama_backend</code> <code>localhost:11434</code> Ollama <code>create_vllm_backend</code> <code>localhost:8000</code> vLLM <code>create_lmstudio_backend</code> <code>localhost:1234</code> LM Studio"},{"location":"api/backends/openai-compat/#api-reference","title":"API Reference","text":""},{"location":"api/backends/openai-compat/#pydantic_agent.backends.openai_compat.OpenAICompatibleBackend","title":"OpenAICompatibleBackend","text":"<pre><code>OpenAICompatibleBackend(\n    model: str,\n    *,\n    base_url: str = \"https://api.openai.com/v1\",\n    api_key: SecretStr | str | None = None,\n    timeout: float = 60.0,\n    profile: ModelProfile | None = None,\n)\n</code></pre> <p>               Bases: <code>ModelBackend</code></p> <p>Backend for OpenAI-compatible APIs.</p> <p>Works with any API that follows the OpenAI chat completions format. Automatically handles differences between providers.</p> <p>Initialize the backend.</p> PARAMETER DESCRIPTION <code>model</code> <p>Model identifier.</p> <p> TYPE: <code>str</code> </p> <code>base_url</code> <p>API base URL.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'https://api.openai.com/v1'</code> </p> <code>api_key</code> <p>API key for authentication.</p> <p> TYPE: <code>SecretStr | str | None</code> DEFAULT: <code>None</code> </p> <code>timeout</code> <p>Request timeout in seconds.</p> <p> TYPE: <code>float</code> DEFAULT: <code>60.0</code> </p> <code>profile</code> <p>Custom model profile.</p> <p> TYPE: <code>ModelProfile | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/pydantic_agent/backends/openai_compat.py</code> <pre><code>def __init__(\n    self,\n    model: str,\n    *,\n    base_url: str = \"https://api.openai.com/v1\",\n    api_key: SecretStr | str | None = None,\n    timeout: float = 60.0,\n    profile: ModelProfile | None = None,\n) -&gt; None:\n    \"\"\"Initialize the backend.\n\n    Args:\n        model: Model identifier.\n        base_url: API base URL.\n        api_key: API key for authentication.\n        timeout: Request timeout in seconds.\n        profile: Custom model profile.\n    \"\"\"\n    self._model = model\n    self._base_url = base_url.rstrip(\"/\")\n    self._timeout = timeout\n    self._profile = profile or get_profile(model)\n\n    # Handle SecretStr\n    if api_key is not None:\n        self._api_key = (\n            api_key.get_secret_value() if hasattr(api_key, \"get_secret_value\") else str(api_key)\n        )\n    else:\n        self._api_key = None\n\n    self._client = httpx.AsyncClient(\n        base_url=self._base_url,\n        timeout=timeout,\n        headers=self._build_headers(),\n    )\n</code></pre>"},{"location":"api/backends/openai-compat/#pydantic_agent.backends.openai_compat.OpenAICompatibleBackend.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Get backend name.</p>"},{"location":"api/backends/openai-compat/#pydantic_agent.backends.openai_compat.OpenAICompatibleBackend.model","title":"model  <code>property</code>","text":"<pre><code>model: str\n</code></pre> <p>Get model identifier.</p>"},{"location":"api/backends/openai-compat/#pydantic_agent.backends.openai_compat.OpenAICompatibleBackend.profile","title":"profile  <code>property</code>","text":"<pre><code>profile: ModelProfile\n</code></pre> <p>Get model profile.</p>"},{"location":"api/backends/openai-compat/#pydantic_agent.backends.openai_compat.OpenAICompatibleBackend.complete","title":"complete  <code>async</code>","text":"<pre><code>complete(\n    messages: list[dict[str, Any]],\n    *,\n    tools: list[dict[str, Any]] | None = None,\n    temperature: float | None = None,\n    max_tokens: int | None = None,\n    **kwargs: Any,\n) -&gt; ModelResponse\n</code></pre> <p>Generate a completion.</p> PARAMETER DESCRIPTION <code>messages</code> <p>Conversation messages.</p> <p> TYPE: <code>list[dict[str, Any]]</code> </p> <code>tools</code> <p>Available tools.</p> <p> TYPE: <code>list[dict[str, Any]] | None</code> DEFAULT: <code>None</code> </p> <code>temperature</code> <p>Sampling temperature.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>max_tokens</code> <p>Maximum tokens to generate.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>**kwargs</code> <p>Additional options.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>ModelResponse</code> <p>ModelResponse with generation results.</p> RAISES DESCRIPTION <code>ModelBackendError</code> <p>On API error.</p> <code>RateLimitError</code> <p>On rate limit.</p> <code>AuthenticationError</code> <p>On auth failure.</p> Source code in <code>src/pydantic_agent/backends/openai_compat.py</code> <pre><code>async def complete(\n    self,\n    messages: list[dict[str, Any]],\n    *,\n    tools: list[dict[str, Any]] | None = None,\n    temperature: float | None = None,\n    max_tokens: int | None = None,\n    **kwargs: Any,\n) -&gt; ModelResponse:\n    \"\"\"Generate a completion.\n\n    Args:\n        messages: Conversation messages.\n        tools: Available tools.\n        temperature: Sampling temperature.\n        max_tokens: Maximum tokens to generate.\n        **kwargs: Additional options.\n\n    Returns:\n        ModelResponse with generation results.\n\n    Raises:\n        ModelBackendError: On API error.\n        RateLimitError: On rate limit.\n        AuthenticationError: On auth failure.\n    \"\"\"\n    payload = self._build_payload(\n        messages=messages,\n        tools=tools,\n        temperature=temperature,\n        max_tokens=max_tokens,\n        stream=False,\n        **kwargs,\n    )\n\n    try:\n        response = await self._client.post(\"/chat/completions\", json=payload)\n        self._check_response(response)\n        data = response.json()\n        return self._parse_response(data)\n\n    except httpx.HTTPStatusError as e:\n        self._handle_http_error(e)\n        raise  # Never reached, but satisfies type checker\n\n    except httpx.RequestError as e:\n        raise ModelBackendError(\n            f\"Request failed: {e}\",\n            model=self._model,\n            retryable=True,\n            cause=e,\n        ) from e\n</code></pre>"},{"location":"api/backends/openai-compat/#pydantic_agent.backends.openai_compat.OpenAICompatibleBackend.stream","title":"stream  <code>async</code>","text":"<pre><code>stream(\n    messages: list[dict[str, Any]],\n    *,\n    tools: list[dict[str, Any]] | None = None,\n    temperature: float | None = None,\n    max_tokens: int | None = None,\n    **kwargs: Any,\n) -&gt; AsyncIterator[StreamChunk]\n</code></pre> <p>Generate a streaming completion.</p> PARAMETER DESCRIPTION <code>messages</code> <p>Conversation messages.</p> <p> TYPE: <code>list[dict[str, Any]]</code> </p> <code>tools</code> <p>Available tools.</p> <p> TYPE: <code>list[dict[str, Any]] | None</code> DEFAULT: <code>None</code> </p> <code>temperature</code> <p>Sampling temperature.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>max_tokens</code> <p>Maximum tokens to generate.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>**kwargs</code> <p>Additional options.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> YIELDS DESCRIPTION <code>AsyncIterator[StreamChunk]</code> <p>StreamChunk objects with partial content.</p> Source code in <code>src/pydantic_agent/backends/openai_compat.py</code> <pre><code>async def stream(\n    self,\n    messages: list[dict[str, Any]],\n    *,\n    tools: list[dict[str, Any]] | None = None,\n    temperature: float | None = None,\n    max_tokens: int | None = None,\n    **kwargs: Any,\n) -&gt; AsyncIterator[StreamChunk]:\n    \"\"\"Generate a streaming completion.\n\n    Args:\n        messages: Conversation messages.\n        tools: Available tools.\n        temperature: Sampling temperature.\n        max_tokens: Maximum tokens to generate.\n        **kwargs: Additional options.\n\n    Yields:\n        StreamChunk objects with partial content.\n    \"\"\"\n    payload = self._build_payload(\n        messages=messages,\n        tools=tools,\n        temperature=temperature,\n        max_tokens=max_tokens,\n        stream=True,\n        **kwargs,\n    )\n\n    try:\n        async with self._client.stream(\"POST\", \"/chat/completions\", json=payload) as response:\n            self._check_response(response)\n\n            async for line in response.aiter_lines():\n                if not line or line.startswith(\":\"):\n                    continue\n\n                if line.startswith(\"data: \"):\n                    data_str = line[6:]\n                    if data_str.strip() == \"[DONE]\":\n                        yield StreamChunk(is_final=True)\n                        break\n\n                    try:\n                        data = json.loads(data_str)\n                        chunk = self._parse_stream_chunk(data)\n                        if chunk:\n                            yield chunk\n                    except json.JSONDecodeError:\n                        logger.warning(\"Failed to parse stream chunk: %s\", line)\n\n    except httpx.HTTPStatusError as e:\n        self._handle_http_error(e)\n\n    except httpx.RequestError as e:\n        raise ModelBackendError(\n            f\"Stream request failed: {e}\",\n            model=self._model,\n            retryable=True,\n            cause=e,\n        ) from e\n</code></pre>"},{"location":"api/backends/openai-compat/#pydantic_agent.backends.openai_compat.OpenAICompatibleBackend.health_check","title":"health_check  <code>async</code>","text":"<pre><code>health_check() -&gt; bool\n</code></pre> <p>Check if the backend is healthy.</p> RETURNS DESCRIPTION <code>bool</code> <p>True if reachable.</p> Source code in <code>src/pydantic_agent/backends/openai_compat.py</code> <pre><code>async def health_check(self) -&gt; bool:\n    \"\"\"Check if the backend is healthy.\n\n    Returns:\n        True if reachable.\n    \"\"\"\n    try:\n        # Try to list models (common endpoint)\n        response = await self._client.get(\"/models\")\n        return response.status_code in (200, 401, 403)  # Even auth error means reachable\n    except httpx.RequestError:\n        return False\n</code></pre>"},{"location":"api/backends/openai-compat/#pydantic_agent.backends.openai_compat.OpenAICompatibleBackend.close","title":"close  <code>async</code>","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the HTTP client.</p> Source code in <code>src/pydantic_agent/backends/openai_compat.py</code> <pre><code>async def close(self) -&gt; None:\n    \"\"\"Close the HTTP client.\"\"\"\n    await self._client.aclose()\n</code></pre>"},{"location":"api/backends/openai-compat/#pydantic_agent.backends.openai_compat.create_ollama_backend","title":"create_ollama_backend","text":"<pre><code>create_ollama_backend(\n    model: str,\n    *,\n    base_url: str = \"http://localhost:11434/v1\",\n    **kwargs: Any,\n) -&gt; OpenAICompatibleBackend\n</code></pre> <p>Create a backend configured for Ollama.</p> PARAMETER DESCRIPTION <code>model</code> <p>Model name (e.g., \"llama3.2\", \"mistral\").</p> <p> TYPE: <code>str</code> </p> <code>base_url</code> <p>Ollama API URL.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'http://localhost:11434/v1'</code> </p> <code>**kwargs</code> <p>Additional backend options.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>OpenAICompatibleBackend</code> <p>Configured OpenAICompatibleBackend.</p> Source code in <code>src/pydantic_agent/backends/openai_compat.py</code> <pre><code>def create_ollama_backend(\n    model: str,\n    *,\n    base_url: str = \"http://localhost:11434/v1\",\n    **kwargs: Any,\n) -&gt; OpenAICompatibleBackend:\n    \"\"\"Create a backend configured for Ollama.\n\n    Args:\n        model: Model name (e.g., \"llama3.2\", \"mistral\").\n        base_url: Ollama API URL.\n        **kwargs: Additional backend options.\n\n    Returns:\n        Configured OpenAICompatibleBackend.\n    \"\"\"\n    return OpenAICompatibleBackend(\n        model=model,\n        base_url=base_url,\n        api_key=None,  # Ollama doesn't require auth by default\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/backends/openai-compat/#pydantic_agent.backends.openai_compat.create_vllm_backend","title":"create_vllm_backend","text":"<pre><code>create_vllm_backend(\n    model: str,\n    *,\n    base_url: str = \"http://localhost:8000/v1\",\n    api_key: str | None = None,\n    **kwargs: Any,\n) -&gt; OpenAICompatibleBackend\n</code></pre> <p>Create a backend configured for vLLM.</p> PARAMETER DESCRIPTION <code>model</code> <p>Model name.</p> <p> TYPE: <code>str</code> </p> <code>base_url</code> <p>vLLM API URL.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'http://localhost:8000/v1'</code> </p> <code>api_key</code> <p>API key if required.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>**kwargs</code> <p>Additional backend options.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>OpenAICompatibleBackend</code> <p>Configured OpenAICompatibleBackend.</p> Source code in <code>src/pydantic_agent/backends/openai_compat.py</code> <pre><code>def create_vllm_backend(\n    model: str,\n    *,\n    base_url: str = \"http://localhost:8000/v1\",\n    api_key: str | None = None,\n    **kwargs: Any,\n) -&gt; OpenAICompatibleBackend:\n    \"\"\"Create a backend configured for vLLM.\n\n    Args:\n        model: Model name.\n        base_url: vLLM API URL.\n        api_key: API key if required.\n        **kwargs: Additional backend options.\n\n    Returns:\n        Configured OpenAICompatibleBackend.\n    \"\"\"\n    return OpenAICompatibleBackend(\n        model=model,\n        base_url=base_url,\n        api_key=api_key,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/backends/openai-compat/#pydantic_agent.backends.openai_compat.create_lmstudio_backend","title":"create_lmstudio_backend","text":"<pre><code>create_lmstudio_backend(\n    model: str = \"local-model\",\n    *,\n    base_url: str = \"http://localhost:1234/v1\",\n    **kwargs: Any,\n) -&gt; OpenAICompatibleBackend\n</code></pre> <p>Create a backend configured for LM Studio.</p> PARAMETER DESCRIPTION <code>model</code> <p>Model identifier (can be any name).</p> <p> TYPE: <code>str</code> DEFAULT: <code>'local-model'</code> </p> <code>base_url</code> <p>LM Studio API URL.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'http://localhost:1234/v1'</code> </p> <code>**kwargs</code> <p>Additional backend options.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>OpenAICompatibleBackend</code> <p>Configured OpenAICompatibleBackend.</p> Source code in <code>src/pydantic_agent/backends/openai_compat.py</code> <pre><code>def create_lmstudio_backend(\n    model: str = \"local-model\",\n    *,\n    base_url: str = \"http://localhost:1234/v1\",\n    **kwargs: Any,\n) -&gt; OpenAICompatibleBackend:\n    \"\"\"Create a backend configured for LM Studio.\n\n    Args:\n        model: Model identifier (can be any name).\n        base_url: LM Studio API URL.\n        **kwargs: Additional backend options.\n\n    Returns:\n        Configured OpenAICompatibleBackend.\n    \"\"\"\n    return OpenAICompatibleBackend(\n        model=model,\n        base_url=base_url,\n        api_key=None,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/backends/profiles/","title":"ModelProfile","text":"<p>Model capability information.</p>"},{"location":"api/backends/profiles/#quick-example","title":"Quick Example","text":"<pre><code>from pydantic_agent.backends import get_profile, ModelProfile\n\n# Get profile\nprofile = get_profile(\"gpt-4o\")\n\nprint(f\"Context window: {profile.context_window}\")\nprint(f\"Max output: {profile.max_output_tokens}\")\nprint(f\"Supports tools: {profile.supports_tools}\")\nprint(f\"Supports vision: {profile.supports_vision}\")\nprint(f\"Provider: {profile.provider}\")\n</code></pre>"},{"location":"api/backends/profiles/#available-profiles","title":"Available Profiles","text":"Model Context Tools Vision gpt-4o 128k Yes Yes gpt-4o-mini 128k Yes Yes gpt-4-turbo 128k Yes Yes gpt-3.5-turbo 16k Yes No claude-3-5-sonnet 200k Yes Yes claude-3-opus 200k Yes Yes llama3.2 8k No No"},{"location":"api/backends/profiles/#api-reference","title":"API Reference","text":""},{"location":"api/backends/profiles/#pydantic_agent.backends.profiles.ModelProfile","title":"ModelProfile  <code>dataclass</code>","text":"<pre><code>ModelProfile(\n    name: str,\n    provider: str,\n    context_window: int,\n    max_output_tokens: int,\n    supports_tools: bool = True,\n    supports_vision: bool = False,\n    supports_streaming: bool = True,\n    default_temperature: float = 0.7,\n    cost_per_1k_input: float | None = None,\n    cost_per_1k_output: float | None = None,\n    extra: dict[str, Any] = dict(),\n)\n</code></pre> <p>Profile defining model capabilities and settings.</p> ATTRIBUTE DESCRIPTION <code>name</code> <p>Model identifier.</p> <p> TYPE: <code>str</code> </p> <code>provider</code> <p>Provider name (openai, anthropic, ollama, etc.).</p> <p> TYPE: <code>str</code> </p> <code>context_window</code> <p>Maximum context window size.</p> <p> TYPE: <code>int</code> </p> <code>max_output_tokens</code> <p>Maximum output tokens.</p> <p> TYPE: <code>int</code> </p> <code>supports_tools</code> <p>Whether the model supports tool calling.</p> <p> TYPE: <code>bool</code> </p> <code>supports_vision</code> <p>Whether the model supports images.</p> <p> TYPE: <code>bool</code> </p> <code>supports_streaming</code> <p>Whether streaming is supported.</p> <p> TYPE: <code>bool</code> </p> <code>default_temperature</code> <p>Default temperature setting.</p> <p> TYPE: <code>float</code> </p> <code>cost_per_1k_input</code> <p>Cost per 1000 input tokens (USD).</p> <p> TYPE: <code>float | None</code> </p> <code>cost_per_1k_output</code> <p>Cost per 1000 output tokens (USD).</p> <p> TYPE: <code>float | None</code> </p> <code>extra</code> <p>Additional provider-specific settings.</p> <p> TYPE: <code>dict[str, Any]</code> </p>"},{"location":"api/backends/profiles/#pydantic_agent.backends.profiles.get_profile","title":"get_profile","text":"<pre><code>get_profile(model_name: str) -&gt; ModelProfile\n</code></pre> <p>Get a profile for a model.</p> PARAMETER DESCRIPTION <code>model_name</code> <p>Model name or identifier.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>ModelProfile</code> <p>ModelProfile for the model, or default profile if unknown.</p> Source code in <code>src/pydantic_agent/backends/profiles.py</code> <pre><code>def get_profile(model_name: str) -&gt; ModelProfile:\n    \"\"\"Get a profile for a model.\n\n    Args:\n        model_name: Model name or identifier.\n\n    Returns:\n        ModelProfile for the model, or default profile if unknown.\n    \"\"\"\n    # Exact match\n    if model_name in PROFILES:\n        return PROFILES[model_name]\n\n    # Check for partial matches (e.g., \"gpt-4o-2024-05-13\" matches \"gpt-4o\")\n    for profile_name, profile in PROFILES.items():\n        if model_name.startswith(profile_name):\n            return profile\n\n    # Return default profile for unknown models\n    return PROFILES[\"default\"]\n</code></pre>"},{"location":"api/config/","title":"Config Module","text":"<p>Configuration and settings classes.</p>"},{"location":"api/config/#classes","title":"Classes","text":"Class Description AgentSettings Root configuration ModelBackendSettings Model connection Other Configs Logging, retry, etc."},{"location":"api/config/#quick-example","title":"Quick Example","text":"<pre><code>from pydantic_agent import AgentSettings\n\n# Load from all sources\nsettings = AgentSettings()\n\n# Access nested config\nprint(settings.model_backend.model)\nprint(settings.logging.level)\n</code></pre>"},{"location":"api/config/#configuration-priority","title":"Configuration Priority","text":"<ol> <li>Constructor arguments</li> <li>Environment variables (<code>AGENTS_*</code>)</li> <li><code>.env</code> file</li> <li><code>~/agents.env</code></li> <li><code>config.toml</code> / <code>config.yaml</code></li> <li>Default values</li> </ol>"},{"location":"api/config/#imports","title":"Imports","text":"<pre><code>from pydantic_agent import AgentSettings\nfrom pydantic_agent.config import (\n    AgentSettings,\n    ModelBackendSettings,\n    LoggingConfig,\n    ErrorRecoveryConfig,\n    ObservabilityConfig,\n    StreamingConfig,\n)\n</code></pre>"},{"location":"api/config/model-backend/","title":"ModelBackendSettings","text":"<p>Model connection configuration.</p>"},{"location":"api/config/model-backend/#quick-example","title":"Quick Example","text":"<pre><code>from pydantic_agent.config import ModelBackendSettings\n\n# Via AgentSettings\nfrom pydantic_agent import AgentSettings\nsettings = AgentSettings(\n    model_backend={\n        \"base_url\": \"http://localhost:11434/v1\",\n        \"model\": \"llama3.2\",\n        \"temperature\": 0.7,\n    }\n)\n</code></pre>"},{"location":"api/config/model-backend/#configuration-options","title":"Configuration Options","text":"Option Type Default Description <code>model</code> str <code>\"llama3.2\"</code> Model identifier <code>base_url</code> str <code>\"http://localhost:11434/v1\"</code> API endpoint <code>api_key</code> SecretStr None API key <code>temperature</code> float 0.7 Sampling temperature <code>max_tokens</code> int None Max output tokens <code>timeout</code> float 30.0 Request timeout <code>max_retries</code> int 3 Retry attempts"},{"location":"api/config/model-backend/#environment-variables","title":"Environment Variables","text":"<pre><code>AGENTS_MODEL_BACKEND__BASE_URL=https://api.openai.com/v1\nAGENTS_MODEL_BACKEND__MODEL=gpt-4o\nAGENTS_MODEL_BACKEND__API_KEY=sk-...\nAGENTS_MODEL_BACKEND__TEMPERATURE=0.7\n</code></pre>"},{"location":"api/config/model-backend/#api-reference","title":"API Reference","text":""},{"location":"api/config/model-backend/#pydantic_agent.config.model_backend.ModelBackendSettings","title":"ModelBackendSettings","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration for the model backend connection.</p> <p>This configuration defines how to connect to an OpenAI-compatible API endpoint, which can be a local LLM server (Ollama, vLLM, llama.cpp) or a remote service.</p> ATTRIBUTE DESCRIPTION <code>base_url</code> <p>Base URL for the OpenAI-compatible API endpoint.</p> <p> TYPE: <code>str</code> </p> <code>api_key</code> <p>Optional API key for authenticated endpoints.</p> <p> TYPE: <code>SecretStr | None</code> </p> <code>model</code> <p>Model identifier to use for requests.</p> <p> TYPE: <code>str</code> </p> <code>timeout</code> <p>Request timeout in seconds.</p> <p> TYPE: <code>float</code> </p> <code>max_retries</code> <p>Maximum retry attempts for failed requests.</p> <p> TYPE: <code>int</code> </p> <code>temperature</code> <p>Sampling temperature for generation.</p> <p> TYPE: <code>float</code> </p> <code>max_tokens</code> <p>Maximum tokens to generate (None for model default).</p> <p> TYPE: <code>int | None</code> </p>"},{"location":"api/config/model-backend/#pydantic_agent.config.model_backend.ModelBackendSettings.get_headers","title":"get_headers","text":"<pre><code>get_headers() -&gt; dict[str, str]\n</code></pre> <p>Get HTTP headers for API requests.</p> RETURNS DESCRIPTION <code>dict[str, str]</code> <p>Dictionary of headers including Authorization if API key is set.</p> Source code in <code>src/pydantic_agent/config/model_backend.py</code> <pre><code>def get_headers(self) -&gt; dict[str, str]:\n    \"\"\"Get HTTP headers for API requests.\n\n    Returns:\n        Dictionary of headers including Authorization if API key is set.\n    \"\"\"\n    headers: dict[str, str] = {}\n    if self.api_key:\n        headers[\"Authorization\"] = f\"Bearer {self.api_key.get_secret_value()}\"\n    return headers\n</code></pre>"},{"location":"api/config/other/","title":"Other Configuration Classes","text":"<p>Additional configuration classes.</p>"},{"location":"api/config/other/#loggingconfig","title":"LoggingConfig","text":"<pre><code>from pydantic_agent.config import LoggingConfig\n\nconfig = LoggingConfig(\n    level=\"INFO\",\n    format=\"json\",\n    redact_sensitive=True,\n)\n</code></pre> Option Type Default Description <code>level</code> str <code>\"INFO\"</code> Log level <code>format</code> str <code>\"text\"</code> Output format <code>redact_sensitive</code> bool True Redact secrets"},{"location":"api/config/other/#errorrecoveryconfig","title":"ErrorRecoveryConfig","text":"<pre><code>from pydantic_agent.config import ErrorRecoveryConfig\n\nconfig = ErrorRecoveryConfig(\n    retry_level=2,\n    max_retries=3,\n    base_wait=1.0,\n)\n</code></pre> Option Type Default Description <code>retry_level</code> int 2 Aggressiveness (1-3) <code>max_retries</code> int 3 Max attempts <code>base_wait</code> float 1.0 Initial backoff"},{"location":"api/config/other/#observabilityconfig","title":"ObservabilityConfig","text":"<pre><code>from pydantic_agent.config import ObservabilityConfig\n\nconfig = ObservabilityConfig(\n    enable_tracing=True,\n    service_name=\"my-agent\",\n)\n</code></pre>"},{"location":"api/config/other/#streamingconfig","title":"StreamingConfig","text":"<pre><code>from pydantic_agent.config import StreamingConfig\n\nconfig = StreamingConfig(\n    enabled=True,\n    chunk_size=1024,\n)\n</code></pre>"},{"location":"api/config/other/#api-reference","title":"API Reference","text":""},{"location":"api/config/other/#pydantic_agent.config.logging_config.LoggingConfig","title":"LoggingConfig","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration for logging behavior.</p> <p>Supports structured JSON logging, request/response body logging, and automatic redaction of sensitive data.</p> ATTRIBUTE DESCRIPTION <code>level</code> <p>Log level (DEBUG, INFO, WARNING, ERROR, CRITICAL).</p> <p> TYPE: <code>LogLevel</code> </p> <code>structured</code> <p>Enable JSON format logging.</p> <p> TYPE: <code>bool</code> </p> <code>include_request_body</code> <p>Log request bodies (opt-in for privacy).</p> <p> TYPE: <code>bool</code> </p> <code>include_response_body</code> <p>Log response bodies (opt-in for privacy).</p> <p> TYPE: <code>bool</code> </p> <code>body_size_limit</code> <p>Maximum bytes to log for bodies.</p> <p> TYPE: <code>int</code> </p> <code>include_correlation_id</code> <p>Include correlation IDs in logs.</p> <p> TYPE: <code>bool</code> </p> <code>redact_authorization</code> <p>Redact Authorization headers.</p> <p> TYPE: <code>bool</code> </p> <code>redact_api_keys</code> <p>Redact API keys in query params.</p> <p> TYPE: <code>bool</code> </p> <code>sensitive_patterns</code> <p>Custom regex patterns to redact.</p> <p> TYPE: <code>list[str]</code> </p>"},{"location":"api/config/other/#pydantic_agent.config.retry.ErrorRecoveryConfig","title":"ErrorRecoveryConfig","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration for error recovery and retry behavior.</p> <p>Error recovery aggressiveness is configurable on a scale of 1-3: - Level 1 (Conservative): Minimal retries, fail fast - Level 2 (Balanced): Default behavior - Level 3 (Aggressive): Maximum retry attempts</p> ATTRIBUTE DESCRIPTION <code>retry_level</code> <p>Aggressiveness level (1-3).</p> <p> TYPE: <code>RetryLevel</code> </p> <code>tool_max_retries</code> <p>Override for tool retry count.</p> <p> TYPE: <code>int | None</code> </p> <code>model_max_retries</code> <p>Override for model retry count.</p> <p> TYPE: <code>int | None</code> </p> <code>initial_backoff_seconds</code> <p>Initial wait before retry.</p> <p> TYPE: <code>float</code> </p> <code>max_backoff_seconds</code> <p>Maximum wait between retries.</p> <p> TYPE: <code>float</code> </p> <code>circuit_breaker_threshold</code> <p>Failures before circuit opens.</p> <p> TYPE: <code>int</code> </p> <code>circuit_breaker_timeout</code> <p>Seconds before retry after circuit opens.</p> <p> TYPE: <code>float</code> </p> <code>retryable_tool_errors</code> <p>Tool error types that trigger retry.</p> <p> TYPE: <code>list[str]</code> </p> <code>retryable_model_errors</code> <p>Model error types that trigger retry.</p> <p> TYPE: <code>list[str]</code> </p>"},{"location":"api/config/other/#pydantic_agent.config.retry.ErrorRecoveryConfig.validate_retry_level","title":"validate_retry_level  <code>classmethod</code>","text":"<pre><code>validate_retry_level(v: int) -&gt; int\n</code></pre> <p>Validate retry level is in range 1-3.</p> Source code in <code>src/pydantic_agent/config/retry.py</code> <pre><code>@field_validator(\"retry_level\")\n@classmethod\ndef validate_retry_level(cls, v: int) -&gt; int:\n    \"\"\"Validate retry level is in range 1-3.\"\"\"\n    if v not in (1, 2, 3):\n        raise ValueError(\"retry_level must be 1, 2, or 3\")\n    return v\n</code></pre>"},{"location":"api/config/other/#pydantic_agent.config.retry.ErrorRecoveryConfig.get_tool_retries","title":"get_tool_retries","text":"<pre><code>get_tool_retries() -&gt; int\n</code></pre> <p>Get tool retry count based on configuration.</p> RETURNS DESCRIPTION <code>int</code> <p>Number of retries for tool calls.</p> Source code in <code>src/pydantic_agent/config/retry.py</code> <pre><code>def get_tool_retries(self) -&gt; int:\n    \"\"\"Get tool retry count based on configuration.\n\n    Returns:\n        Number of retries for tool calls.\n    \"\"\"\n    if self.tool_max_retries is not None:\n        return self.tool_max_retries\n    return _TOOL_RETRIES[self.retry_level]\n</code></pre>"},{"location":"api/config/other/#pydantic_agent.config.retry.ErrorRecoveryConfig.get_model_retries","title":"get_model_retries","text":"<pre><code>get_model_retries() -&gt; int\n</code></pre> <p>Get model retry count based on configuration.</p> RETURNS DESCRIPTION <code>int</code> <p>Number of retries for model calls.</p> Source code in <code>src/pydantic_agent/config/retry.py</code> <pre><code>def get_model_retries(self) -&gt; int:\n    \"\"\"Get model retry count based on configuration.\n\n    Returns:\n        Number of retries for model calls.\n    \"\"\"\n    if self.model_max_retries is not None:\n        return self.model_max_retries\n    return _MODEL_RETRIES[self.retry_level]\n</code></pre>"},{"location":"api/config/other/#pydantic_agent.config.retry.ErrorRecoveryConfig.get_backoff_multiplier","title":"get_backoff_multiplier","text":"<pre><code>get_backoff_multiplier() -&gt; float\n</code></pre> <p>Get exponential backoff multiplier based on retry level.</p> RETURNS DESCRIPTION <code>float</code> <p>Backoff multiplier for exponential backoff.</p> Source code in <code>src/pydantic_agent/config/retry.py</code> <pre><code>def get_backoff_multiplier(self) -&gt; float:\n    \"\"\"Get exponential backoff multiplier based on retry level.\n\n    Returns:\n        Backoff multiplier for exponential backoff.\n    \"\"\"\n    return _BACKOFF_MULTIPLIERS[self.retry_level]\n</code></pre>"},{"location":"api/config/other/#pydantic_agent.config.observability.ObservabilityConfig","title":"ObservabilityConfig","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration for observability features.</p> <p>Controls request ID generation, trace context propagation, and OpenTelemetry integration.</p> ATTRIBUTE DESCRIPTION <code>request_id_format</code> <p>Format for generated request IDs.</p> <p> TYPE: <code>RequestIdFormat</code> </p> <code>propagate_trace_context</code> <p>Propagate trace headers.</p> <p> TYPE: <code>bool</code> </p> <code>enable_otel_instrumentation</code> <p>Enable OpenTelemetry hooks.</p> <p> TYPE: <code>bool</code> </p> <code>metrics_enabled</code> <p>Expose duration metrics.</p> <p> TYPE: <code>bool</code> </p>"},{"location":"api/config/settings/","title":"AgentSettings","text":"<p>Root configuration class using Pydantic Settings.</p>"},{"location":"api/config/settings/#quick-example","title":"Quick Example","text":"<pre><code>from pydantic_agent import AgentSettings\n\n# Load from environment, .env, config files\nsettings = AgentSettings()\n\n# Override specific values\nsettings = AgentSettings(\n    model_backend={\n        \"model\": \"gpt-4o\",\n        \"api_key\": \"sk-...\",\n    },\n    logging={\"level\": \"DEBUG\"},\n)\n</code></pre>"},{"location":"api/config/settings/#configuration-sections","title":"Configuration Sections","text":"Section Type Description <code>model_backend</code> ModelBackendSettings Model connection <code>logging</code> LoggingConfig Logging settings <code>observability</code> ObservabilityConfig Tracing settings <code>retry</code> ErrorRecoveryConfig Retry behavior <code>streaming</code> StreamingConfig Streaming options <code>context</code> CompactionConfig Default compaction <code>tokenizer</code> TokenizerConfig Tokenizer settings <code>cost_rates</code> dict Custom cost rates"},{"location":"api/config/settings/#environment-variables","title":"Environment Variables","text":"<pre><code>AGENTS_MODEL_BACKEND__MODEL=gpt-4o\nAGENTS_MODEL_BACKEND__API_KEY=sk-...\nAGENTS_LOGGING__LEVEL=INFO\nAGENTS_RETRY__MAX_RETRIES=3\n</code></pre>"},{"location":"api/config/settings/#api-reference","title":"API Reference","text":""},{"location":"api/config/settings/#pydantic_agent.config.settings.AgentSettings","title":"AgentSettings","text":"<p>               Bases: <code>BaseSettings</code></p> <p>Root configuration for the agent framework.</p> <p>Configuration is loaded from multiple sources in priority order: 1. Constructor arguments (highest priority) 2. Environment variables (AGENTS_ prefix) 3. .env file (project-specific) 4. ~/agents.env file (user-wide defaults) 5. config.toml file 6. Default values (lowest priority)</p> <p>Environment variables use double underscore for nesting: - AGENTS_MODEL_BACKEND__BASE_URL -&gt; model_backend.base_url - AGENTS_LOGGING__LEVEL -&gt; logging.level</p> ATTRIBUTE DESCRIPTION <code>model_backend</code> <p>Model backend connection settings.</p> <p> TYPE: <code>ModelBackendSettings</code> </p> <code>logging</code> <p>Logging configuration.</p> <p> TYPE: <code>LoggingConfig</code> </p> <code>observability</code> <p>Observability and tracing settings.</p> <p> TYPE: <code>ObservabilityConfig</code> </p> <code>retry</code> <p>Error recovery and retry settings.</p> <p> TYPE: <code>ErrorRecoveryConfig</code> </p> <code>streaming</code> <p>Streaming behavior settings.</p> <p> TYPE: <code>StreamingConfig</code> </p> <code>context</code> <p>Default context compaction settings.</p> <p> TYPE: <code>CompactionConfig</code> </p> <code>tokenizer</code> <p>Default tokenizer settings.</p> <p> TYPE: <code>TokenizerConfig</code> </p> <code>cost_rates</code> <p>Custom cost rates per 1000 tokens by model.</p> <p> TYPE: <code>dict[str, float]</code> </p>"},{"location":"api/config/settings/#pydantic_agent.config.settings.AgentSettings.settings_customise_sources","title":"settings_customise_sources  <code>classmethod</code>","text":"<pre><code>settings_customise_sources(\n    settings_cls: type[BaseSettings],\n    init_settings: PydanticBaseSettingsSource,\n    env_settings: PydanticBaseSettingsSource,\n    dotenv_settings: PydanticBaseSettingsSource,\n    file_secret_settings: PydanticBaseSettingsSource,\n) -&gt; tuple[PydanticBaseSettingsSource, ...]\n</code></pre> <p>Customize settings sources to include TOML file support.</p> <p>Order determines priority (first = highest priority): 1. init_settings (constructor args) 2. env_settings (environment variables) 3. dotenv_settings (.env file) 4. toml_settings (config.toml file) 5. file_secret_settings (secrets files)</p> Source code in <code>src/pydantic_agent/config/settings.py</code> <pre><code>@classmethod\ndef settings_customise_sources(\n    cls,\n    settings_cls: type[BaseSettings],\n    init_settings: PydanticBaseSettingsSource,\n    env_settings: PydanticBaseSettingsSource,\n    dotenv_settings: PydanticBaseSettingsSource,\n    file_secret_settings: PydanticBaseSettingsSource,\n) -&gt; tuple[PydanticBaseSettingsSource, ...]:\n    \"\"\"Customize settings sources to include TOML file support.\n\n    Order determines priority (first = highest priority):\n    1. init_settings (constructor args)\n    2. env_settings (environment variables)\n    3. dotenv_settings (.env file)\n    4. toml_settings (config.toml file)\n    5. file_secret_settings (secrets files)\n    \"\"\"\n    return (\n        init_settings,\n        env_settings,\n        dotenv_settings,\n        TomlConfigSettingsSource(settings_cls),\n        file_secret_settings,\n    )\n</code></pre>"},{"location":"api/config/settings/#pydantic_agent.config.settings.AgentSettings.from_file","title":"from_file  <code>classmethod</code>","text":"<pre><code>from_file(path: str | Path) -&gt; AgentSettings\n</code></pre> <p>Load settings from a specific configuration file.</p> PARAMETER DESCRIPTION <code>path</code> <p>Path to TOML or YAML configuration file.</p> <p> TYPE: <code>str | Path</code> </p> RETURNS DESCRIPTION <code>AgentSettings</code> <p>AgentSettings instance with values from file.</p> RAISES DESCRIPTION <code>FileNotFoundError</code> <p>If configuration file doesn't exist.</p> <code>ValueError</code> <p>If file format is not supported.</p> Source code in <code>src/pydantic_agent/config/settings.py</code> <pre><code>@classmethod\ndef from_file(cls, path: str | Path) -&gt; AgentSettings:\n    \"\"\"Load settings from a specific configuration file.\n\n    Args:\n        path: Path to TOML or YAML configuration file.\n\n    Returns:\n        AgentSettings instance with values from file.\n\n    Raises:\n        FileNotFoundError: If configuration file doesn't exist.\n        ValueError: If file format is not supported.\n    \"\"\"\n    path = Path(path)\n    if not path.exists():\n        raise FileNotFoundError(f\"Configuration file not found: {path}\")\n\n    suffix = path.suffix.lower()\n    if suffix == \".toml\":\n        return cls(_env_file=None, _toml_file=path)\n    elif suffix in (\".yaml\", \".yml\"):\n        # For YAML, we need to load and pass as dict\n        import yaml\n\n        with path.open() as f:\n            data = yaml.safe_load(f)\n        return cls(_env_file=None, **data)\n    else:\n        raise ValueError(f\"Unsupported configuration file format: {suffix}\")\n</code></pre>"},{"location":"api/config/settings/#pydantic_agent.config.settings.AgentSettings.model_dump_safe","title":"model_dump_safe","text":"<pre><code>model_dump_safe() -&gt; dict[str, Any]\n</code></pre> <p>Dump model to dict with secrets redacted.</p> RETURNS DESCRIPTION <code>dict[str, Any]</code> <p>Dictionary representation with sensitive values replaced.</p> Source code in <code>src/pydantic_agent/config/settings.py</code> <pre><code>def model_dump_safe(self) -&gt; dict[str, Any]:\n    \"\"\"Dump model to dict with secrets redacted.\n\n    Returns:\n        Dictionary representation with sensitive values replaced.\n    \"\"\"\n    data = self.model_dump()\n\n    # Redact API key if present\n    if data.get(\"model_backend\", {}).get(\"api_key\"):\n        data[\"model_backend\"][\"api_key\"] = \"***REDACTED***\"\n\n    return data\n</code></pre>"},{"location":"api/context/","title":"Context Module","text":"<p>Context window management and compaction.</p>"},{"location":"api/context/#classes","title":"Classes","text":"Class Description ContextManager Manages conversation context CompactionConfig Compaction configuration Compaction Strategies 5 compaction strategies"},{"location":"api/context/#quick-example","title":"Quick Example","text":"<pre><code>from pydantic_agent.context import ContextManager, CompactionConfig\n\nconfig = CompactionConfig(\n    strategy=\"hybrid\",\n    trigger_threshold_tokens=100000,\n    target_tokens=80000,\n)\n\nmanager = ContextManager(config=config)\nmanager.add_messages([{\"role\": \"user\", \"content\": \"Hello\"}])\n\nif manager.should_compact():\n    result = await manager.compact()\n</code></pre>"},{"location":"api/context/#imports","title":"Imports","text":"<pre><code>from pydantic_agent import CompactionConfig, ContextState\nfrom pydantic_agent.context import ContextManager, CompactionConfig\n</code></pre>"},{"location":"api/context/config/","title":"CompactionConfig","text":"<p>Configuration for context compaction.</p>"},{"location":"api/context/config/#quick-example","title":"Quick Example","text":"<pre><code>from pydantic_agent import CompactionConfig\n\nconfig = CompactionConfig(\n    strategy=\"hybrid\",\n    trigger_threshold_tokens=100000,\n    target_tokens=80000,\n    preserve_recent_turns=10,\n    preserve_system_prompt=True,\n)\n</code></pre>"},{"location":"api/context/config/#configuration-options","title":"Configuration Options","text":"Option Type Default Description <code>strategy</code> str <code>\"sliding_window\"</code> Compaction strategy <code>trigger_threshold_tokens</code> int 100000 Token count to trigger <code>target_tokens</code> int 80000 Target after compaction <code>preserve_recent_turns</code> int 10 Recent turns to keep <code>preserve_system_prompt</code> bool True Always keep system <code>summarization_model</code> str <code>\"same\"</code> Model for summaries"},{"location":"api/context/config/#available-strategies","title":"Available Strategies","text":"<ul> <li><code>sliding_window</code> - Remove oldest messages</li> <li><code>summarize_older</code> - LLM summarization</li> <li><code>selective_pruning</code> - Remove tool pairs</li> <li><code>importance_scoring</code> - LLM scoring</li> <li><code>hybrid</code> - Combine strategies</li> </ul>"},{"location":"api/context/config/#api-reference","title":"API Reference","text":""},{"location":"api/context/config/#pydantic_agent.context.config.CompactionConfig","title":"CompactionConfig","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration for context window compaction.</p> ATTRIBUTE DESCRIPTION <code>strategy</code> <p>Compaction strategy to use.</p> <p> TYPE: <code>CompactionStrategyType</code> </p> <code>trigger_threshold_tokens</code> <p>Token count that triggers compaction.</p> <p> TYPE: <code>int</code> </p> <code>target_tokens</code> <p>Target token count after compaction.</p> <p> TYPE: <code>int</code> </p> <code>preserve_recent_turns</code> <p>Number of recent turns to always preserve.</p> <p> TYPE: <code>int</code> </p> <code>preserve_system_prompt</code> <p>Always preserve the system prompt.</p> <p> TYPE: <code>bool</code> </p> <code>summarization_model</code> <p>Model to use for summarization (or \"same\").</p> <p> TYPE: <code>str</code> </p>"},{"location":"api/context/manager/","title":"ContextManager","text":"<p>Manages conversation context and compaction.</p>"},{"location":"api/context/manager/#quick-example","title":"Quick Example","text":"<pre><code>from pydantic_agent.context import ContextManager, CompactionConfig\n\nmanager = ContextManager(config=CompactionConfig(strategy=\"hybrid\"))\n\n# Add messages\nmanager.add_messages([\n    {\"role\": \"user\", \"content\": \"Hello\"},\n    {\"role\": \"assistant\", \"content\": \"Hi!\"},\n])\n\n# Get messages\nmessages = manager.get_messages()\n\n# Check state\nstate = manager.get_context_state()\nprint(f\"Tokens: {state.token_count}\")\n\n# Compact if needed\nif manager.should_compact():\n    result = await manager.compact()\n</code></pre>"},{"location":"api/context/manager/#api-reference","title":"API Reference","text":""},{"location":"api/context/manager/#pydantic_agent.context.manager.ContextManager","title":"ContextManager","text":"<pre><code>ContextManager(\n    config: CompactionConfig | None = None,\n    token_counter: TokenCounter | None = None,\n)\n</code></pre> <p>Manages conversation context and compaction.</p> <p>Tracks message history, monitors token usage, and applies compaction strategies when thresholds are reached.</p> <p>Initialize the context manager.</p> PARAMETER DESCRIPTION <code>config</code> <p>Compaction configuration.</p> <p> TYPE: <code>CompactionConfig | None</code> DEFAULT: <code>None</code> </p> <code>token_counter</code> <p>Token counter instance.</p> <p> TYPE: <code>TokenCounter | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/pydantic_agent/context/manager.py</code> <pre><code>def __init__(\n    self,\n    config: CompactionConfig | None = None,\n    token_counter: TokenCounter | None = None,\n) -&gt; None:\n    \"\"\"Initialize the context manager.\n\n    Args:\n        config: Compaction configuration.\n        token_counter: Token counter instance.\n    \"\"\"\n    self._config = config or CompactionConfig()\n    self._counter = token_counter or TokenCounter()\n    self._history = MessageHistory()\n    self._compaction_history: list[CompactionResult] = []\n    self._strategy = self._create_strategy()\n</code></pre>"},{"location":"api/context/manager/#pydantic_agent.context.manager.ContextManager.config","title":"config  <code>property</code>","text":"<pre><code>config: CompactionConfig\n</code></pre> <p>Get the compaction configuration.</p> RETURNS DESCRIPTION <code>CompactionConfig</code> <p>CompactionConfig instance.</p>"},{"location":"api/context/manager/#pydantic_agent.context.manager.ContextManager.add_messages","title":"add_messages","text":"<pre><code>add_messages(messages: list[dict[str, Any]]) -&gt; None\n</code></pre> <p>Add messages to the history.</p> PARAMETER DESCRIPTION <code>messages</code> <p>Messages to add.</p> <p> TYPE: <code>list[dict[str, Any]]</code> </p> Source code in <code>src/pydantic_agent/context/manager.py</code> <pre><code>def add_messages(self, messages: list[dict[str, Any]]) -&gt; None:\n    \"\"\"Add messages to the history.\n\n    Args:\n        messages: Messages to add.\n    \"\"\"\n    for msg in messages:\n        role = msg.get(\"role\", \"\")\n        content = msg.get(\"content\", \"\")\n\n        if role == \"system\" and self._config.preserve_system_prompt:\n            self._history.system_prompt = content\n        else:\n            self._history.messages.append(msg)\n</code></pre>"},{"location":"api/context/manager/#pydantic_agent.context.manager.ContextManager.get_messages","title":"get_messages","text":"<pre><code>get_messages() -&gt; list[dict[str, Any]]\n</code></pre> <p>Get all messages.</p> RETURNS DESCRIPTION <code>list[dict[str, Any]]</code> <p>List of messages.</p> Source code in <code>src/pydantic_agent/context/manager.py</code> <pre><code>def get_messages(self) -&gt; list[dict[str, Any]]:\n    \"\"\"Get all messages.\n\n    Returns:\n        List of messages.\n    \"\"\"\n    return self._history.get_messages()\n</code></pre>"},{"location":"api/context/manager/#pydantic_agent.context.manager.ContextManager.get_token_count","title":"get_token_count","text":"<pre><code>get_token_count() -&gt; int\n</code></pre> <p>Get current token count.</p> RETURNS DESCRIPTION <code>int</code> <p>Approximate token count.</p> Source code in <code>src/pydantic_agent/context/manager.py</code> <pre><code>def get_token_count(self) -&gt; int:\n    \"\"\"Get current token count.\n\n    Returns:\n        Approximate token count.\n    \"\"\"\n    messages = self.get_messages()\n    count = self._counter.count_messages(messages)\n\n    if self._history.system_prompt:\n        count += self._counter.count(self._history.system_prompt)\n\n    return count\n</code></pre>"},{"location":"api/context/manager/#pydantic_agent.context.manager.ContextManager.should_compact","title":"should_compact","text":"<pre><code>should_compact() -&gt; bool\n</code></pre> <p>Check if compaction threshold is reached.</p> RETURNS DESCRIPTION <code>bool</code> <p>True if compaction should be triggered.</p> Source code in <code>src/pydantic_agent/context/manager.py</code> <pre><code>def should_compact(self) -&gt; bool:\n    \"\"\"Check if compaction threshold is reached.\n\n    Returns:\n        True if compaction should be triggered.\n    \"\"\"\n    return self.get_token_count() &gt;= self._config.trigger_threshold_tokens\n</code></pre>"},{"location":"api/context/manager/#pydantic_agent.context.manager.ContextManager.compact","title":"compact  <code>async</code>","text":"<pre><code>compact() -&gt; CompactionResult\n</code></pre> <p>Apply compaction strategy to reduce context size.</p> RETURNS DESCRIPTION <code>CompactionResult</code> <p>CompactionResult with details of what was done.</p> Source code in <code>src/pydantic_agent/context/manager.py</code> <pre><code>async def compact(self) -&gt; CompactionResult:\n    \"\"\"Apply compaction strategy to reduce context size.\n\n    Returns:\n        CompactionResult with details of what was done.\n    \"\"\"\n    messages = self.get_messages()\n\n    result = await self._strategy.compact(\n        messages,\n        self._config.target_tokens,\n        self._config.preserve_recent_turns,\n    )\n\n    # Update history with compacted messages\n    self._history.messages = result.messages\n    self._compaction_history.append(result)\n\n    return result\n</code></pre>"},{"location":"api/context/manager/#pydantic_agent.context.manager.ContextManager.get_context_state","title":"get_context_state","text":"<pre><code>get_context_state() -&gt; ContextState\n</code></pre> <p>Get the current context state.</p> RETURNS DESCRIPTION <code>ContextState</code> <p>ContextState with current information.</p> Source code in <code>src/pydantic_agent/context/manager.py</code> <pre><code>def get_context_state(self) -&gt; ContextState:\n    \"\"\"Get the current context state.\n\n    Returns:\n        ContextState with current information.\n    \"\"\"\n    return ContextState(\n        token_count=self.get_token_count(),\n        message_count=len(self._history),\n        system_prompt=self._history.system_prompt,\n        compaction_history=self._compaction_history.copy(),\n    )\n</code></pre>"},{"location":"api/context/manager/#pydantic_agent.context.manager.ContextManager.get_system_prompt","title":"get_system_prompt","text":"<pre><code>get_system_prompt() -&gt; str | None\n</code></pre> <p>Get the system prompt.</p> RETURNS DESCRIPTION <code>str | None</code> <p>The system prompt or None.</p> Source code in <code>src/pydantic_agent/context/manager.py</code> <pre><code>def get_system_prompt(self) -&gt; str | None:\n    \"\"\"Get the system prompt.\n\n    Returns:\n        The system prompt or None.\n    \"\"\"\n    return self._history.system_prompt\n</code></pre>"},{"location":"api/context/manager/#pydantic_agent.context.manager.ContextManager.set_system_prompt","title":"set_system_prompt","text":"<pre><code>set_system_prompt(prompt: str) -&gt; None\n</code></pre> <p>Set the system prompt.</p> PARAMETER DESCRIPTION <code>prompt</code> <p>The system prompt.</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/pydantic_agent/context/manager.py</code> <pre><code>def set_system_prompt(self, prompt: str) -&gt; None:\n    \"\"\"Set the system prompt.\n\n    Args:\n        prompt: The system prompt.\n    \"\"\"\n    self._history.system_prompt = prompt\n</code></pre>"},{"location":"api/context/manager/#pydantic_agent.context.manager.ContextManager.clear","title":"clear","text":"<pre><code>clear() -&gt; None\n</code></pre> <p>Clear all context.</p> Source code in <code>src/pydantic_agent/context/manager.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Clear all context.\"\"\"\n    self._history.clear()\n    self._compaction_history.clear()\n</code></pre>"},{"location":"api/context/manager/#pydantic_agent.context.manager.ContextManager.get_compaction_history","title":"get_compaction_history","text":"<pre><code>get_compaction_history() -&gt; list[CompactionResult]\n</code></pre> <p>Get history of compactions.</p> RETURNS DESCRIPTION <code>list[CompactionResult]</code> <p>List of CompactionResult objects.</p> Source code in <code>src/pydantic_agent/context/manager.py</code> <pre><code>def get_compaction_history(self) -&gt; list[CompactionResult]:\n    \"\"\"Get history of compactions.\n\n    Returns:\n        List of CompactionResult objects.\n    \"\"\"\n    return self._compaction_history.copy()\n</code></pre>"},{"location":"api/context/manager/#pydantic_agent.context.manager.ContextState","title":"ContextState  <code>dataclass</code>","text":"<pre><code>ContextState(\n    token_count: int,\n    message_count: int,\n    system_prompt: str | None,\n    compaction_history: list[CompactionResult] = list(),\n)\n</code></pre> <p>Current state of the context.</p> ATTRIBUTE DESCRIPTION <code>token_count</code> <p>Current token count.</p> <p> TYPE: <code>int</code> </p> <code>message_count</code> <p>Number of messages.</p> <p> TYPE: <code>int</code> </p> <code>system_prompt</code> <p>The system prompt.</p> <p> TYPE: <code>str | None</code> </p> <code>compaction_history</code> <p>History of compactions performed.</p> <p> TYPE: <code>list[CompactionResult]</code> </p>"},{"location":"api/context/strategies/","title":"Compaction Strategies","text":"<p>The 5 available compaction strategies.</p>"},{"location":"api/context/strategies/#overview","title":"Overview","text":"Strategy Speed LLM Calls Best For <code>sliding_window</code> Fast None Simple chats <code>summarize_older</code> Slow Yes Long research <code>selective_pruning</code> Fast None Tool-heavy <code>importance_scoring</code> Slow Yes Mixed content <code>hybrid</code> Medium Maybe General use"},{"location":"api/context/strategies/#usage","title":"Usage","text":"<pre><code>from pydantic_agent import CompactionConfig\n\n# Select strategy via config\nconfig = CompactionConfig(strategy=\"sliding_window\")\nconfig = CompactionConfig(strategy=\"summarize_older\")\nconfig = CompactionConfig(strategy=\"selective_pruning\")\nconfig = CompactionConfig(strategy=\"importance_scoring\")\nconfig = CompactionConfig(strategy=\"hybrid\")\n</code></pre>"},{"location":"api/context/strategies/#api-reference","title":"API Reference","text":""},{"location":"api/context/strategies/#pydantic_agent.context.compaction.SlidingWindowStrategy","title":"SlidingWindowStrategy","text":"<p>               Bases: <code>CompactionStrategy</code></p> <p>Remove oldest messages beyond a count threshold.</p> <p>This is the simplest compaction strategy. It removes messages from the beginning of the conversation until the token count is below the target.</p>"},{"location":"api/context/strategies/#pydantic_agent.context.compaction.SlidingWindowStrategy.compact","title":"compact  <code>async</code>","text":"<pre><code>compact(\n    messages: list[dict[str, Any]],\n    target_tokens: int,\n    preserve_recent: int = 0,\n) -&gt; CompactionResult\n</code></pre> <p>Compact by removing oldest messages.</p> PARAMETER DESCRIPTION <code>messages</code> <p>Messages to compact.</p> <p> TYPE: <code>list[dict[str, Any]]</code> </p> <code>target_tokens</code> <p>Target token count.</p> <p> TYPE: <code>int</code> </p> <code>preserve_recent</code> <p>Number of recent messages to always keep.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> RETURNS DESCRIPTION <code>CompactionResult</code> <p>CompactionResult with compacted messages.</p> Source code in <code>src/pydantic_agent/context/compaction/sliding_window.py</code> <pre><code>async def compact(\n    self,\n    messages: list[dict[str, Any]],\n    target_tokens: int,\n    preserve_recent: int = 0,\n) -&gt; CompactionResult:\n    \"\"\"Compact by removing oldest messages.\n\n    Args:\n        messages: Messages to compact.\n        target_tokens: Target token count.\n        preserve_recent: Number of recent messages to always keep.\n\n    Returns:\n        CompactionResult with compacted messages.\n    \"\"\"\n    tokens_before = self._count_tokens(messages)\n\n    if tokens_before &lt;= target_tokens:\n        return CompactionResult(\n            messages=messages,\n            removed_count=0,\n            tokens_before=tokens_before,\n            tokens_after=tokens_before,\n            strategy=self.name,\n        )\n\n    # Separate preserved and removable messages\n    if preserve_recent &gt; 0 and len(messages) &gt; preserve_recent:\n        preserved = messages[-preserve_recent:]\n        removable = messages[:-preserve_recent]\n    else:\n        preserved = []\n        removable = messages.copy()\n\n    # Remove from the beginning until we're under target\n    removed_count = 0\n    while removable and self._count_tokens(removable + preserved) &gt; target_tokens:\n        removable.pop(0)\n        removed_count += 1\n\n    result_messages = removable + preserved\n    tokens_after = self._count_tokens(result_messages)\n\n    return CompactionResult(\n        messages=result_messages,\n        removed_count=removed_count,\n        tokens_before=tokens_before,\n        tokens_after=tokens_after,\n        strategy=self.name,\n    )\n</code></pre>"},{"location":"api/context/strategies/#pydantic_agent.context.compaction.SummarizeOlderStrategy","title":"SummarizeOlderStrategy","text":"<pre><code>SummarizeOlderStrategy(\n    summarization_agent: Agent[Any, str] | None = None,\n)\n</code></pre> <p>               Bases: <code>CompactionStrategy</code></p> <p>Summarize older messages while keeping recent ones verbatim.</p> <p>Uses an LLM to create a summary of older conversation turns, replacing them with a single summary message.</p> <p>Initialize the summarization strategy.</p> PARAMETER DESCRIPTION <code>summarization_agent</code> <p>Agent to use for summarization.                 If None, a default will be created.</p> <p> TYPE: <code>Agent[Any, str] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/pydantic_agent/context/compaction/summarize.py</code> <pre><code>def __init__(\n    self,\n    summarization_agent: Agent[Any, str] | None = None,\n) -&gt; None:\n    \"\"\"Initialize the summarization strategy.\n\n    Args:\n        summarization_agent: Agent to use for summarization.\n                            If None, a default will be created.\n    \"\"\"\n    self._agent = summarization_agent\n</code></pre>"},{"location":"api/context/strategies/#pydantic_agent.context.compaction.SummarizeOlderStrategy.compact","title":"compact  <code>async</code>","text":"<pre><code>compact(\n    messages: list[dict[str, Any]],\n    target_tokens: int,\n    preserve_recent: int = 0,\n) -&gt; CompactionResult\n</code></pre> <p>Compact by summarizing older messages.</p> PARAMETER DESCRIPTION <code>messages</code> <p>Messages to compact.</p> <p> TYPE: <code>list[dict[str, Any]]</code> </p> <code>target_tokens</code> <p>Target token count.</p> <p> TYPE: <code>int</code> </p> <code>preserve_recent</code> <p>Number of recent messages to keep verbatim.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> RETURNS DESCRIPTION <code>CompactionResult</code> <p>CompactionResult with compacted messages.</p> Source code in <code>src/pydantic_agent/context/compaction/summarize.py</code> <pre><code>async def compact(\n    self,\n    messages: list[dict[str, Any]],\n    target_tokens: int,\n    preserve_recent: int = 0,\n) -&gt; CompactionResult:\n    \"\"\"Compact by summarizing older messages.\n\n    Args:\n        messages: Messages to compact.\n        target_tokens: Target token count.\n        preserve_recent: Number of recent messages to keep verbatim.\n\n    Returns:\n        CompactionResult with compacted messages.\n    \"\"\"\n    tokens_before = self._count_tokens(messages)\n\n    if tokens_before &lt;= target_tokens:\n        return CompactionResult(\n            messages=messages,\n            removed_count=0,\n            tokens_before=tokens_before,\n            tokens_after=tokens_before,\n            strategy=self.name,\n        )\n\n    # Separate messages to preserve and summarize\n    if preserve_recent &gt; 0 and len(messages) &gt; preserve_recent:\n        to_preserve = messages[-preserve_recent:]\n        to_summarize = messages[:-preserve_recent]\n    else:\n        to_preserve = messages.copy()\n        to_summarize = []\n\n    if not to_summarize:\n        # Nothing to summarize, fall back to sliding window\n        return CompactionResult(\n            messages=to_preserve,\n            removed_count=0,\n            tokens_before=tokens_before,\n            tokens_after=self._count_tokens(to_preserve),\n            strategy=self.name,\n        )\n\n    # Create summary\n    summary = await self._create_summary(to_summarize)\n\n    # Create summary message\n    summary_message = {\n        \"role\": \"system\",\n        \"content\": f\"[Previous conversation summary: {summary}]\",\n    }\n\n    result_messages = [summary_message] + to_preserve\n    tokens_after = self._count_tokens(result_messages)\n\n    return CompactionResult(\n        messages=result_messages,\n        removed_count=len(to_summarize),\n        tokens_before=tokens_before,\n        tokens_after=tokens_after,\n        strategy=self.name,\n    )\n</code></pre>"},{"location":"api/context/strategies/#pydantic_agent.context.compaction.SelectivePruningStrategy","title":"SelectivePruningStrategy","text":"<p>               Bases: <code>CompactionStrategy</code></p> <p>Remove completed tool call/result pairs.</p> <p>This strategy identifies tool calls that have been completed (have corresponding results) and removes both the call and result, keeping only a summary of what was done.</p>"},{"location":"api/context/strategies/#pydantic_agent.context.compaction.SelectivePruningStrategy.compact","title":"compact  <code>async</code>","text":"<pre><code>compact(\n    messages: list[dict[str, Any]],\n    target_tokens: int,\n    preserve_recent: int = 0,\n) -&gt; CompactionResult\n</code></pre> <p>Compact by removing completed tool call pairs.</p> PARAMETER DESCRIPTION <code>messages</code> <p>Messages to compact.</p> <p> TYPE: <code>list[dict[str, Any]]</code> </p> <code>target_tokens</code> <p>Target token count.</p> <p> TYPE: <code>int</code> </p> <code>preserve_recent</code> <p>Number of recent messages to preserve.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> RETURNS DESCRIPTION <code>CompactionResult</code> <p>CompactionResult with compacted messages.</p> Source code in <code>src/pydantic_agent/context/compaction/selective.py</code> <pre><code>async def compact(\n    self,\n    messages: list[dict[str, Any]],\n    target_tokens: int,\n    preserve_recent: int = 0,\n) -&gt; CompactionResult:\n    \"\"\"Compact by removing completed tool call pairs.\n\n    Args:\n        messages: Messages to compact.\n        target_tokens: Target token count.\n        preserve_recent: Number of recent messages to preserve.\n\n    Returns:\n        CompactionResult with compacted messages.\n    \"\"\"\n    tokens_before = self._count_tokens(messages)\n\n    if tokens_before &lt;= target_tokens:\n        return CompactionResult(\n            messages=messages,\n            removed_count=0,\n            tokens_before=tokens_before,\n            tokens_after=tokens_before,\n            strategy=self.name,\n        )\n\n    # Identify tool call/result pairs\n    tool_call_pairs = self._find_tool_call_pairs(messages)\n\n    # Separate messages to preserve\n    if preserve_recent &gt; 0:\n        preserved_indices = set(range(len(messages) - preserve_recent, len(messages)))\n    else:\n        preserved_indices = set()\n\n    # Remove oldest pairs first until under target\n    result_messages = messages.copy()\n    removed_count = 0\n\n    for call_idx, result_idx in tool_call_pairs:\n        if self._count_tokens(result_messages) &lt;= target_tokens:\n            break\n\n        # Don't remove preserved messages\n        if call_idx in preserved_indices or result_idx in preserved_indices:\n            continue\n\n        # Create summary of what was done\n        call_msg = messages[call_idx]\n        tool_calls = call_msg.get(\"tool_calls\", [])\n\n        if tool_calls:\n            tool_names = [\n                tc.get(\"function\", {}).get(\"name\", \"unknown\")\n                for tc in tool_calls\n                if isinstance(tc, dict)\n            ]\n            summary = f\"[Tool calls executed: {', '.join(tool_names)}]\"\n\n            # Replace with summary\n            for tc_idx, msg in enumerate(result_messages):\n                if msg.get(\"role\") == \"assistant\" and msg.get(\"tool_calls\") == tool_calls:\n                    result_messages[tc_idx] = {\n                        \"role\": \"system\",\n                        \"content\": summary,\n                    }\n                    removed_count += 1\n                    break\n\n            # Remove corresponding tool results\n            result_messages = [\n                m\n                for m in result_messages\n                if not (\n                    m.get(\"role\") == \"tool\"\n                    and m.get(\"tool_call_id\")\n                    in [tc.get(\"id\") for tc in tool_calls if isinstance(tc, dict)]\n                )\n            ]\n\n    tokens_after = self._count_tokens(result_messages)\n\n    return CompactionResult(\n        messages=result_messages,\n        removed_count=removed_count,\n        tokens_before=tokens_before,\n        tokens_after=tokens_after,\n        strategy=self.name,\n    )\n</code></pre>"},{"location":"api/context/strategies/#pydantic_agent.context.compaction.ImportanceScoringStrategy","title":"ImportanceScoringStrategy","text":"<pre><code>ImportanceScoringStrategy(\n    scoring_agent: Agent[Any, str] | None = None,\n)\n</code></pre> <p>               Bases: <code>CompactionStrategy</code></p> <p>Score messages by importance and prune lowest scored.</p> <p>Uses an LLM to score messages by their importance to the conversation, then removes the lowest-scored messages.</p> <p>Initialize the importance scoring strategy.</p> PARAMETER DESCRIPTION <code>scoring_agent</code> <p>Agent to use for scoring.           If None, uses heuristic scoring.</p> <p> TYPE: <code>Agent[Any, str] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/pydantic_agent/context/compaction/importance.py</code> <pre><code>def __init__(\n    self,\n    scoring_agent: Agent[Any, str] | None = None,\n) -&gt; None:\n    \"\"\"Initialize the importance scoring strategy.\n\n    Args:\n        scoring_agent: Agent to use for scoring.\n                      If None, uses heuristic scoring.\n    \"\"\"\n    self._agent = scoring_agent\n</code></pre>"},{"location":"api/context/strategies/#pydantic_agent.context.compaction.ImportanceScoringStrategy.compact","title":"compact  <code>async</code>","text":"<pre><code>compact(\n    messages: list[dict[str, Any]],\n    target_tokens: int,\n    preserve_recent: int = 0,\n) -&gt; CompactionResult\n</code></pre> <p>Compact by removing low-importance messages.</p> PARAMETER DESCRIPTION <code>messages</code> <p>Messages to compact.</p> <p> TYPE: <code>list[dict[str, Any]]</code> </p> <code>target_tokens</code> <p>Target token count.</p> <p> TYPE: <code>int</code> </p> <code>preserve_recent</code> <p>Number of recent messages to preserve.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> RETURNS DESCRIPTION <code>CompactionResult</code> <p>CompactionResult with compacted messages.</p> Source code in <code>src/pydantic_agent/context/compaction/importance.py</code> <pre><code>async def compact(\n    self,\n    messages: list[dict[str, Any]],\n    target_tokens: int,\n    preserve_recent: int = 0,\n) -&gt; CompactionResult:\n    \"\"\"Compact by removing low-importance messages.\n\n    Args:\n        messages: Messages to compact.\n        target_tokens: Target token count.\n        preserve_recent: Number of recent messages to preserve.\n\n    Returns:\n        CompactionResult with compacted messages.\n    \"\"\"\n    tokens_before = self._count_tokens(messages)\n\n    if tokens_before &lt;= target_tokens:\n        return CompactionResult(\n            messages=messages,\n            removed_count=0,\n            tokens_before=tokens_before,\n            tokens_after=tokens_before,\n            strategy=self.name,\n        )\n\n    # Score messages\n    scores = await self._score_messages(messages)\n\n    # Create list of (index, message, score) for sorting\n    indexed = [(i, m, s) for i, (m, s) in enumerate(zip(messages, scores))]\n\n    # Separate preserved messages\n    if preserve_recent &gt; 0:\n        preserve_start = len(messages) - preserve_recent\n        preserved = [x for x in indexed if x[0] &gt;= preserve_start]\n        removable = [x for x in indexed if x[0] &lt; preserve_start]\n    else:\n        preserved = []\n        removable = indexed.copy()\n\n    # Sort removable by score (lowest first)\n    removable.sort(key=lambda x: x[2])\n\n    # Remove lowest scored until under target\n    removed_count = 0\n    while removable:\n        current = [x[1] for x in removable] + [x[1] for x in preserved]\n        if self._count_tokens(current) &lt;= target_tokens:\n            break\n\n        removable.pop(0)  # Remove lowest scored\n        removed_count += 1\n\n    # Reconstruct messages in original order\n    remaining = sorted(removable + preserved, key=lambda x: x[0])\n    result_messages = [x[1] for x in remaining]\n    tokens_after = self._count_tokens(result_messages)\n\n    return CompactionResult(\n        messages=result_messages,\n        removed_count=removed_count,\n        tokens_before=tokens_before,\n        tokens_after=tokens_after,\n        strategy=self.name,\n    )\n</code></pre>"},{"location":"api/context/strategies/#pydantic_agent.context.compaction.HybridStrategy","title":"HybridStrategy","text":"<pre><code>HybridStrategy(\n    strategies: list[CompactionStrategy] | None = None,\n)\n</code></pre> <p>               Bases: <code>CompactionStrategy</code></p> <p>Combination of strategies with configurable weights.</p> <p>Applies multiple strategies in sequence, using each one to progressively reduce context size.</p> <p>Initialize the hybrid strategy.</p> PARAMETER DESCRIPTION <code>strategies</code> <p>Strategies to apply in order.        If None, uses default combination.</p> <p> TYPE: <code>list[CompactionStrategy] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/pydantic_agent/context/compaction/hybrid.py</code> <pre><code>def __init__(\n    self,\n    strategies: list[CompactionStrategy] | None = None,\n) -&gt; None:\n    \"\"\"Initialize the hybrid strategy.\n\n    Args:\n        strategies: Strategies to apply in order.\n                   If None, uses default combination.\n    \"\"\"\n    if strategies is None:\n        self._strategies = [\n            SelectivePruningStrategy(),\n            SlidingWindowStrategy(),\n        ]\n    else:\n        self._strategies = strategies\n</code></pre>"},{"location":"api/context/strategies/#pydantic_agent.context.compaction.HybridStrategy.compact","title":"compact  <code>async</code>","text":"<pre><code>compact(\n    messages: list[dict[str, Any]],\n    target_tokens: int,\n    preserve_recent: int = 0,\n) -&gt; CompactionResult\n</code></pre> <p>Compact using multiple strategies.</p> PARAMETER DESCRIPTION <code>messages</code> <p>Messages to compact.</p> <p> TYPE: <code>list[dict[str, Any]]</code> </p> <code>target_tokens</code> <p>Target token count.</p> <p> TYPE: <code>int</code> </p> <code>preserve_recent</code> <p>Number of recent messages to preserve.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> RETURNS DESCRIPTION <code>CompactionResult</code> <p>CompactionResult with compacted messages.</p> Source code in <code>src/pydantic_agent/context/compaction/hybrid.py</code> <pre><code>async def compact(\n    self,\n    messages: list[dict[str, Any]],\n    target_tokens: int,\n    preserve_recent: int = 0,\n) -&gt; CompactionResult:\n    \"\"\"Compact using multiple strategies.\n\n    Args:\n        messages: Messages to compact.\n        target_tokens: Target token count.\n        preserve_recent: Number of recent messages to preserve.\n\n    Returns:\n        CompactionResult with compacted messages.\n    \"\"\"\n    tokens_before = self._count_tokens(messages)\n\n    if tokens_before &lt;= target_tokens:\n        return CompactionResult(\n            messages=messages,\n            removed_count=0,\n            tokens_before=tokens_before,\n            tokens_after=tokens_before,\n            strategy=self.name,\n        )\n\n    current_messages = messages\n    total_removed = 0\n    strategies_used = []\n\n    for strategy in self._strategies:\n        if self._count_tokens(current_messages) &lt;= target_tokens:\n            break\n\n        result = await strategy.compact(\n            current_messages,\n            target_tokens,\n            preserve_recent,\n        )\n\n        current_messages = result.messages\n        total_removed += result.removed_count\n        strategies_used.append(strategy.name)\n\n    tokens_after = self._count_tokens(current_messages)\n\n    return CompactionResult(\n        messages=current_messages,\n        removed_count=total_removed,\n        tokens_before=tokens_before,\n        tokens_after=tokens_after,\n        strategy=f\"{self.name}({'+'.join(strategies_used)})\",\n    )\n</code></pre>"},{"location":"api/errors/","title":"Errors Module","text":"<p>Exception classes and error handling utilities.</p>"},{"location":"api/errors/#classes","title":"Classes","text":"Class Description Exceptions Exception hierarchy CircuitBreaker Circuit breaker pattern Retry Retry decorators"},{"location":"api/errors/#quick-example","title":"Quick Example","text":"<pre><code>from pydantic_agent.errors import (\n    AgentError,\n    ModelBackendError,\n    RateLimitError,\n    CircuitBreaker,\n    create_retry_decorator,\n)\n\n# Handle exceptions\ntry:\n    result = await agent.run(query)\nexcept RateLimitError as e:\n    await asyncio.sleep(e.retry_after)\nexcept ModelBackendError:\n    use_fallback()\n\n# Circuit breaker\nbreaker = CircuitBreaker(\"api\", failure_threshold=5)\nasync with breaker:\n    result = await call_api()\n</code></pre>"},{"location":"api/errors/#imports","title":"Imports","text":"<pre><code>from pydantic_agent.errors import (\n    AgentError,\n    ModelBackendError,\n    RateLimitError,\n    AuthenticationError,\n    ToolError,\n    CircuitBreaker,\n    create_retry_decorator,\n)\n</code></pre>"},{"location":"api/errors/circuit-breaker/","title":"CircuitBreaker","text":"<p>Circuit breaker pattern for preventing cascading failures.</p>"},{"location":"api/errors/circuit-breaker/#quick-example","title":"Quick Example","text":"<pre><code>from pydantic_agent.errors import CircuitBreaker\n\nbreaker = CircuitBreaker(\n    name=\"model-api\",\n    failure_threshold=5,\n    timeout=30.0,\n)\n\n# Use as context manager\nasync with breaker:\n    result = await call_api()\n\n# Check state\nif breaker.is_open:\n    print(\"Circuit is open\")\n\n# Get stats\nstats = breaker.get_stats()\nprint(f\"Failures: {stats.failure_count}\")\n\n# Manual reset\nbreaker.reset()\n</code></pre>"},{"location":"api/errors/circuit-breaker/#states","title":"States","text":"<ol> <li>Closed - Normal, requests pass through</li> <li>Open - Too many failures, requests rejected</li> <li>Half-Open - Testing if service recovered</li> </ol>"},{"location":"api/errors/circuit-breaker/#configuration","title":"Configuration","text":"Option Type Default Description <code>name</code> str Required Unique identifier <code>failure_threshold</code> int 5 Failures to open <code>timeout</code> float 30.0 Seconds to stay open <code>success_threshold</code> int 2 Successes to close"},{"location":"api/errors/circuit-breaker/#api-reference","title":"API Reference","text":""},{"location":"api/errors/circuit-breaker/#pydantic_agent.errors.circuit_breaker.CircuitBreaker","title":"CircuitBreaker","text":"<pre><code>CircuitBreaker(\n    name: str, config: CircuitBreakerConfig | None = None\n)\n</code></pre> <p>               Bases: <code>Generic[T]</code></p> <p>Circuit breaker for protecting against cascading failures.</p> <p>The circuit breaker monitors calls to a service and trips (opens) when failures exceed a threshold, preventing further calls until a timeout elapses.</p> <p>States: - CLOSED: Normal operation, calls pass through - OPEN: Failures exceeded threshold, calls are rejected - HALF_OPEN: Testing recovery, limited calls allowed</p> Example <p>breaker = CircuitBreaker(\"model-api\")</p> <p>async def call_api():     async with breaker:         return await api.call()</p> <p>Initialize the circuit breaker.</p> PARAMETER DESCRIPTION <code>name</code> <p>Name for this circuit breaker.</p> <p> TYPE: <code>str</code> </p> <code>config</code> <p>Circuit breaker configuration.</p> <p> TYPE: <code>CircuitBreakerConfig | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/pydantic_agent/errors/circuit_breaker.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    config: CircuitBreakerConfig | None = None,\n) -&gt; None:\n    \"\"\"Initialize the circuit breaker.\n\n    Args:\n        name: Name for this circuit breaker.\n        config: Circuit breaker configuration.\n    \"\"\"\n    self.name = name\n    self.config = config or CircuitBreakerConfig()\n    self._state = CircuitState.CLOSED\n    self._failures: deque[FailureRecord] = deque()\n    self._last_failure_time: float | None = None\n    self._half_open_successes = 0\n    self._stats = CircuitStats()\n</code></pre>"},{"location":"api/errors/circuit-breaker/#pydantic_agent.errors.circuit_breaker.CircuitBreaker--or-manually","title":"Or manually:","text":"<p>if breaker.allow_request():     try:         result = await api.call()         breaker.record_success()     except Exception as e:         breaker.record_failure(e)</p>"},{"location":"api/errors/circuit-breaker/#pydantic_agent.errors.circuit_breaker.CircuitBreaker.state","title":"state  <code>property</code>","text":"<pre><code>state: CircuitState\n</code></pre> <p>Get current circuit state, transitioning if needed.</p>"},{"location":"api/errors/circuit-breaker/#pydantic_agent.errors.circuit_breaker.CircuitBreaker.stats","title":"stats  <code>property</code>","text":"<pre><code>stats: CircuitStats\n</code></pre> <p>Get circuit breaker statistics.</p>"},{"location":"api/errors/circuit-breaker/#pydantic_agent.errors.circuit_breaker.CircuitBreaker.allow_request","title":"allow_request","text":"<pre><code>allow_request() -&gt; bool\n</code></pre> <p>Check if a request should be allowed.</p> RETURNS DESCRIPTION <code>bool</code> <p>True if the request should proceed.</p> Source code in <code>src/pydantic_agent/errors/circuit_breaker.py</code> <pre><code>def allow_request(self) -&gt; bool:\n    \"\"\"Check if a request should be allowed.\n\n    Returns:\n        True if the request should proceed.\n    \"\"\"\n    current_state = self.state  # This may trigger transition\n\n    if current_state == CircuitState.CLOSED:\n        return True\n    elif current_state == CircuitState.HALF_OPEN:\n        # Allow limited requests in half-open\n        return True\n    else:  # OPEN\n        return False\n</code></pre>"},{"location":"api/errors/circuit-breaker/#pydantic_agent.errors.circuit_breaker.CircuitBreaker.record_success","title":"record_success","text":"<pre><code>record_success() -&gt; None\n</code></pre> <p>Record a successful call.</p> Source code in <code>src/pydantic_agent/errors/circuit_breaker.py</code> <pre><code>def record_success(self) -&gt; None:\n    \"\"\"Record a successful call.\"\"\"\n    self._stats.total_calls += 1\n    self._stats.successful_calls += 1\n\n    if self._state == CircuitState.HALF_OPEN:\n        self._half_open_successes += 1\n        if self._half_open_successes &gt;= self.config.success_threshold:\n            self._transition_to(CircuitState.CLOSED)\n            self._failures.clear()\n</code></pre>"},{"location":"api/errors/circuit-breaker/#pydantic_agent.errors.circuit_breaker.CircuitBreaker.record_failure","title":"record_failure","text":"<pre><code>record_failure(exception: Exception) -&gt; None\n</code></pre> <p>Record a failed call.</p> PARAMETER DESCRIPTION <code>exception</code> <p>The exception that occurred.</p> <p> TYPE: <code>Exception</code> </p> Source code in <code>src/pydantic_agent/errors/circuit_breaker.py</code> <pre><code>def record_failure(self, exception: Exception) -&gt; None:\n    \"\"\"Record a failed call.\n\n    Args:\n        exception: The exception that occurred.\n    \"\"\"\n    self._stats.total_calls += 1\n    self._stats.failed_calls += 1\n\n    now = time.time()\n    self._failures.append(FailureRecord(timestamp=now, exception=exception))\n    self._last_failure_time = now\n\n    if self._state == CircuitState.HALF_OPEN:\n        # Immediate trip back to open on failure in half-open\n        self._transition_to(CircuitState.OPEN)\n    elif self._state == CircuitState.CLOSED:\n        if self._count_recent_failures() &gt;= self.config.failure_threshold:\n            self._transition_to(CircuitState.OPEN)\n</code></pre>"},{"location":"api/errors/circuit-breaker/#pydantic_agent.errors.circuit_breaker.CircuitBreaker.get_time_until_retry","title":"get_time_until_retry","text":"<pre><code>get_time_until_retry() -&gt; float\n</code></pre> <p>Get seconds until retry is allowed.</p> RETURNS DESCRIPTION <code>float</code> <p>Seconds until retry, 0 if allowed now.</p> Source code in <code>src/pydantic_agent/errors/circuit_breaker.py</code> <pre><code>def get_time_until_retry(self) -&gt; float:\n    \"\"\"Get seconds until retry is allowed.\n\n    Returns:\n        Seconds until retry, 0 if allowed now.\n    \"\"\"\n    if self._state != CircuitState.OPEN:\n        return 0.0\n\n    if self._last_failure_time is None:\n        return 0.0\n\n    elapsed = time.time() - self._last_failure_time\n    remaining = self.config.timeout - elapsed\n    return max(0.0, remaining)\n</code></pre>"},{"location":"api/errors/circuit-breaker/#pydantic_agent.errors.circuit_breaker.CircuitBreaker.reset","title":"reset","text":"<pre><code>reset() -&gt; None\n</code></pre> <p>Force reset the circuit breaker to closed state.</p> Source code in <code>src/pydantic_agent/errors/circuit_breaker.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Force reset the circuit breaker to closed state.\"\"\"\n    self._state = CircuitState.CLOSED\n    self._failures.clear()\n    self._last_failure_time = None\n    self._half_open_successes = 0\n</code></pre>"},{"location":"api/errors/exceptions/","title":"Exceptions","text":"<p>Custom exception classes.</p>"},{"location":"api/errors/exceptions/#exception-hierarchy","title":"Exception Hierarchy","text":"<pre><code>AgentError (base)\n\u251c\u2500\u2500 ConfigurationError\n\u251c\u2500\u2500 ModelBackendError\n\u2502   \u2514\u2500\u2500 RateLimitError\n\u251c\u2500\u2500 ToolExecutionError\n\u251c\u2500\u2500 ContextOverflowError\n\u251c\u2500\u2500 MCPError\n\u251c\u2500\u2500 AuthenticationError\n\u2514\u2500\u2500 TimeoutError\n</code></pre>"},{"location":"api/errors/exceptions/#quick-example","title":"Quick Example","text":"<pre><code>from pydantic_agent.errors import (\n    AgentError,\n    ModelBackendError,\n    RateLimitError,\n    AuthenticationError,\n    ToolExecutionError,\n    ContextOverflowError,\n)\n\ntry:\n    result = await agent.run(query)\nexcept RateLimitError as e:\n    print(f\"Rate limited, retry after: {e.retry_after}s\")\nexcept AuthenticationError:\n    print(\"Invalid API key\")\nexcept ModelBackendError as e:\n    print(f\"Model error: {e}\")\nexcept ToolExecutionError as e:\n    print(f\"Tool {e.tool_name} failed: {e}\")\nexcept ContextOverflowError as e:\n    print(f\"Context overflow: {e.current_tokens}/{e.max_tokens} tokens\")\nexcept AgentError as e:\n    print(f\"Agent error: {e}\")\n</code></pre>"},{"location":"api/errors/exceptions/#api-reference","title":"API Reference","text":""},{"location":"api/errors/exceptions/#pydantic_agent.errors.exceptions.AgentError","title":"AgentError","text":"<pre><code>AgentError(\n    message: str,\n    *,\n    details: dict[str, Any] | None = None,\n    cause: Exception | None = None,\n)\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Base exception for all agent errors.</p> <p>All custom exceptions in this framework inherit from this class, allowing for easy catching of all agent-related errors.</p> <p>Initialize the error.</p> PARAMETER DESCRIPTION <code>message</code> <p>Human-readable error message.</p> <p> TYPE: <code>str</code> </p> <code>details</code> <p>Additional error context.</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> <code>cause</code> <p>Original exception that caused this error.</p> <p> TYPE: <code>Exception | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/pydantic_agent/errors/exceptions.py</code> <pre><code>def __init__(\n    self,\n    message: str,\n    *,\n    details: dict[str, Any] | None = None,\n    cause: Exception | None = None,\n) -&gt; None:\n    \"\"\"Initialize the error.\n\n    Args:\n        message: Human-readable error message.\n        details: Additional error context.\n        cause: Original exception that caused this error.\n    \"\"\"\n    super().__init__(message)\n    self.message = message\n    self.details = details or {}\n    self.cause = cause\n</code></pre>"},{"location":"api/errors/exceptions/#pydantic_agent.errors.exceptions.ConfigurationError","title":"ConfigurationError","text":"<pre><code>ConfigurationError(\n    message: str,\n    *,\n    config_key: str | None = None,\n    expected: Any = None,\n    actual: Any = None,\n    **kwargs: Any,\n)\n</code></pre> <p>               Bases: <code>AgentError</code></p> <p>Error in agent configuration.</p> <p>Raised when configuration is invalid, missing required fields, or contains incompatible settings.</p> <p>Initialize configuration error.</p> PARAMETER DESCRIPTION <code>message</code> <p>Error message.</p> <p> TYPE: <code>str</code> </p> <code>config_key</code> <p>The configuration key that caused the error.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>expected</code> <p>Expected value or type.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>None</code> </p> <code>actual</code> <p>Actual value received.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>None</code> </p> <code>**kwargs</code> <p>Additional arguments passed to AgentError.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>src/pydantic_agent/errors/exceptions.py</code> <pre><code>def __init__(\n    self,\n    message: str,\n    *,\n    config_key: str | None = None,\n    expected: Any = None,\n    actual: Any = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Initialize configuration error.\n\n    Args:\n        message: Error message.\n        config_key: The configuration key that caused the error.\n        expected: Expected value or type.\n        actual: Actual value received.\n        **kwargs: Additional arguments passed to AgentError.\n    \"\"\"\n    details = kwargs.pop(\"details\", {})\n    if config_key:\n        details[\"config_key\"] = config_key\n    if expected is not None:\n        details[\"expected\"] = expected\n    if actual is not None:\n        details[\"actual\"] = actual\n\n    super().__init__(message, details=details, **kwargs)\n    self.config_key = config_key\n    self.expected = expected\n    self.actual = actual\n</code></pre>"},{"location":"api/errors/exceptions/#pydantic_agent.errors.exceptions.ModelBackendError","title":"ModelBackendError","text":"<pre><code>ModelBackendError(\n    message: str,\n    *,\n    model: str | None = None,\n    status_code: int | None = None,\n    response_body: str | None = None,\n    retryable: bool = False,\n    **kwargs: Any,\n)\n</code></pre> <p>               Bases: <code>AgentError</code></p> <p>Error from the model backend.</p> <p>Raised when the underlying model API returns an error, times out, or is unavailable.</p> <p>Initialize model backend error.</p> PARAMETER DESCRIPTION <code>message</code> <p>Error message.</p> <p> TYPE: <code>str</code> </p> <code>model</code> <p>Model that caused the error.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>status_code</code> <p>HTTP status code if applicable.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>response_body</code> <p>Response body from the API.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>retryable</code> <p>Whether this error can be retried.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>**kwargs</code> <p>Additional arguments passed to AgentError.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>src/pydantic_agent/errors/exceptions.py</code> <pre><code>def __init__(\n    self,\n    message: str,\n    *,\n    model: str | None = None,\n    status_code: int | None = None,\n    response_body: str | None = None,\n    retryable: bool = False,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Initialize model backend error.\n\n    Args:\n        message: Error message.\n        model: Model that caused the error.\n        status_code: HTTP status code if applicable.\n        response_body: Response body from the API.\n        retryable: Whether this error can be retried.\n        **kwargs: Additional arguments passed to AgentError.\n    \"\"\"\n    details = kwargs.pop(\"details\", {})\n    if model:\n        details[\"model\"] = model\n    if status_code:\n        details[\"status_code\"] = status_code\n    if response_body:\n        details[\"response_body\"] = response_body\n    details[\"retryable\"] = retryable\n\n    super().__init__(message, details=details, **kwargs)\n    self.model = model\n    self.status_code = status_code\n    self.response_body = response_body\n    self.retryable = retryable\n</code></pre>"},{"location":"api/errors/exceptions/#pydantic_agent.errors.exceptions.RateLimitError","title":"RateLimitError","text":"<pre><code>RateLimitError(\n    message: str,\n    *,\n    retry_after: float | None = None,\n    **kwargs: Any,\n)\n</code></pre> <p>               Bases: <code>ModelBackendError</code></p> <p>Rate limit exceeded.</p> <p>Raised when the model API rate limit is hit.</p> <p>Initialize rate limit error.</p> PARAMETER DESCRIPTION <code>message</code> <p>Error message.</p> <p> TYPE: <code>str</code> </p> <code>retry_after</code> <p>Seconds to wait before retrying.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>**kwargs</code> <p>Additional arguments passed to ModelBackendError.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>src/pydantic_agent/errors/exceptions.py</code> <pre><code>def __init__(\n    self,\n    message: str,\n    *,\n    retry_after: float | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Initialize rate limit error.\n\n    Args:\n        message: Error message.\n        retry_after: Seconds to wait before retrying.\n        **kwargs: Additional arguments passed to ModelBackendError.\n    \"\"\"\n    kwargs.setdefault(\"retryable\", True)\n    super().__init__(message, **kwargs)\n    self.retry_after = retry_after\n    if retry_after:\n        self.details[\"retry_after\"] = retry_after\n</code></pre>"},{"location":"api/errors/exceptions/#pydantic_agent.errors.exceptions.AuthenticationError","title":"AuthenticationError","text":"<pre><code>AuthenticationError(\n    message: str,\n    *,\n    details: dict[str, Any] | None = None,\n    cause: Exception | None = None,\n)\n</code></pre> <p>               Bases: <code>AgentError</code></p> <p>Authentication failed.</p> <p>Raised when API authentication fails, typically due to invalid or expired credentials.</p> Source code in <code>src/pydantic_agent/errors/exceptions.py</code> <pre><code>def __init__(\n    self,\n    message: str,\n    *,\n    details: dict[str, Any] | None = None,\n    cause: Exception | None = None,\n) -&gt; None:\n    \"\"\"Initialize the error.\n\n    Args:\n        message: Human-readable error message.\n        details: Additional error context.\n        cause: Original exception that caused this error.\n    \"\"\"\n    super().__init__(message)\n    self.message = message\n    self.details = details or {}\n    self.cause = cause\n</code></pre>"},{"location":"api/errors/exceptions/#pydantic_agent.errors.exceptions.ToolExecutionError","title":"ToolExecutionError","text":"<pre><code>ToolExecutionError(\n    message: str,\n    *,\n    tool_name: str | None = None,\n    tool_args: dict[str, Any] | None = None,\n    **kwargs: Any,\n)\n</code></pre> <p>               Bases: <code>AgentError</code></p> <p>Error during tool execution.</p> <p>Raised when a tool fails to execute properly, either due to invalid arguments, permission issues, or runtime errors.</p> <p>Initialize tool execution error.</p> PARAMETER DESCRIPTION <code>message</code> <p>Error message.</p> <p> TYPE: <code>str</code> </p> <code>tool_name</code> <p>Name of the tool that failed.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>tool_args</code> <p>Arguments passed to the tool.</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> <code>**kwargs</code> <p>Additional arguments passed to AgentError.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>src/pydantic_agent/errors/exceptions.py</code> <pre><code>def __init__(\n    self,\n    message: str,\n    *,\n    tool_name: str | None = None,\n    tool_args: dict[str, Any] | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Initialize tool execution error.\n\n    Args:\n        message: Error message.\n        tool_name: Name of the tool that failed.\n        tool_args: Arguments passed to the tool.\n        **kwargs: Additional arguments passed to AgentError.\n    \"\"\"\n    details = kwargs.pop(\"details\", {})\n    if tool_name:\n        details[\"tool_name\"] = tool_name\n    if tool_args:\n        # Redact potentially sensitive values\n        details[\"tool_args\"] = {\n            k: \"[REDACTED]\" if \"key\" in k.lower() or \"secret\" in k.lower() else v\n            for k, v in tool_args.items()\n        }\n\n    super().__init__(message, details=details, **kwargs)\n    self.tool_name = tool_name\n    self.tool_args = tool_args\n</code></pre>"},{"location":"api/errors/exceptions/#pydantic_agent.errors.exceptions.ContextOverflowError","title":"ContextOverflowError","text":"<pre><code>ContextOverflowError(\n    message: str,\n    *,\n    current_tokens: int | None = None,\n    max_tokens: int | None = None,\n    compaction_attempted: bool = False,\n    **kwargs: Any,\n)\n</code></pre> <p>               Bases: <code>AgentError</code></p> <p>Context window exceeded.</p> <p>Raised when the conversation context exceeds the model's maximum context window and cannot be compacted further.</p> <p>Initialize context overflow error.</p> PARAMETER DESCRIPTION <code>message</code> <p>Error message.</p> <p> TYPE: <code>str</code> </p> <code>current_tokens</code> <p>Current token count.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>max_tokens</code> <p>Maximum allowed tokens.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>compaction_attempted</code> <p>Whether compaction was tried.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>**kwargs</code> <p>Additional arguments passed to AgentError.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>src/pydantic_agent/errors/exceptions.py</code> <pre><code>def __init__(\n    self,\n    message: str,\n    *,\n    current_tokens: int | None = None,\n    max_tokens: int | None = None,\n    compaction_attempted: bool = False,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Initialize context overflow error.\n\n    Args:\n        message: Error message.\n        current_tokens: Current token count.\n        max_tokens: Maximum allowed tokens.\n        compaction_attempted: Whether compaction was tried.\n        **kwargs: Additional arguments passed to AgentError.\n    \"\"\"\n    details = kwargs.pop(\"details\", {})\n    if current_tokens:\n        details[\"current_tokens\"] = current_tokens\n    if max_tokens:\n        details[\"max_tokens\"] = max_tokens\n    details[\"compaction_attempted\"] = compaction_attempted\n\n    super().__init__(message, details=details, **kwargs)\n    self.current_tokens = current_tokens\n    self.max_tokens = max_tokens\n    self.compaction_attempted = compaction_attempted\n</code></pre>"},{"location":"api/errors/exceptions/#pydantic_agent.errors.exceptions.MCPError","title":"MCPError","text":"<pre><code>MCPError(\n    message: str,\n    *,\n    server_name: str | None = None,\n    server_url: str | None = None,\n    **kwargs: Any,\n)\n</code></pre> <p>               Bases: <code>AgentError</code></p> <p>Error from MCP server interaction.</p> <p>Raised when communication with an MCP server fails, the server returns an error, or authentication fails.</p> <p>Initialize MCP error.</p> PARAMETER DESCRIPTION <code>message</code> <p>Error message.</p> <p> TYPE: <code>str</code> </p> <code>server_name</code> <p>Name of the MCP server.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>server_url</code> <p>URL of the MCP server.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>**kwargs</code> <p>Additional arguments passed to AgentError.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>src/pydantic_agent/errors/exceptions.py</code> <pre><code>def __init__(\n    self,\n    message: str,\n    *,\n    server_name: str | None = None,\n    server_url: str | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Initialize MCP error.\n\n    Args:\n        message: Error message.\n        server_name: Name of the MCP server.\n        server_url: URL of the MCP server.\n        **kwargs: Additional arguments passed to AgentError.\n    \"\"\"\n    details = kwargs.pop(\"details\", {})\n    if server_name:\n        details[\"server_name\"] = server_name\n    if server_url:\n        details[\"server_url\"] = server_url\n\n    super().__init__(message, details=details, **kwargs)\n    self.server_name = server_name\n    self.server_url = server_url\n</code></pre>"},{"location":"api/errors/exceptions/#pydantic_agent.errors.exceptions.TimeoutError","title":"TimeoutError","text":"<pre><code>TimeoutError(\n    message: str,\n    *,\n    timeout_seconds: float | None = None,\n    operation: str | None = None,\n    **kwargs: Any,\n)\n</code></pre> <p>               Bases: <code>AgentError</code></p> <p>Operation timed out.</p> <p>Raised when an operation exceeds its timeout limit.</p> <p>Initialize timeout error.</p> PARAMETER DESCRIPTION <code>message</code> <p>Error message.</p> <p> TYPE: <code>str</code> </p> <code>timeout_seconds</code> <p>The timeout that was exceeded.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>operation</code> <p>Name of the operation that timed out.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>**kwargs</code> <p>Additional arguments passed to AgentError.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>src/pydantic_agent/errors/exceptions.py</code> <pre><code>def __init__(\n    self,\n    message: str,\n    *,\n    timeout_seconds: float | None = None,\n    operation: str | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Initialize timeout error.\n\n    Args:\n        message: Error message.\n        timeout_seconds: The timeout that was exceeded.\n        operation: Name of the operation that timed out.\n        **kwargs: Additional arguments passed to AgentError.\n    \"\"\"\n    details = kwargs.pop(\"details\", {})\n    if timeout_seconds:\n        details[\"timeout_seconds\"] = timeout_seconds\n    if operation:\n        details[\"operation\"] = operation\n\n    super().__init__(message, details=details, **kwargs)\n    self.timeout_seconds = timeout_seconds\n    self.operation = operation\n</code></pre>"},{"location":"api/errors/retry/","title":"Retry Utilities","text":"<p>Retry decorators and utilities.</p>"},{"location":"api/errors/retry/#quick-example","title":"Quick Example","text":"<pre><code>from pydantic_agent.errors import create_retry_decorator\n\n@create_retry_decorator(max_attempts=3, base_wait=1.0)\nasync def call_api():\n    response = await httpx.get(url)\n    return response.json()\n</code></pre>"},{"location":"api/errors/retry/#retry-levels","title":"Retry Levels","text":"Level Max Retries Base Wait Description 1 2 1.0s Conservative 2 3 1.0s Balanced (default) 3 5 0.5s Aggressive"},{"location":"api/errors/retry/#configuration","title":"Configuration","text":"<pre><code>from pydantic_agent.config import ErrorRecoveryConfig\n\nconfig = ErrorRecoveryConfig(\n    retry_level=2,\n    max_retries=3,\n    base_wait=1.0,\n    max_wait=30.0,\n    exponential_base=2.0,\n    jitter=True,\n)\n</code></pre>"},{"location":"api/errors/retry/#api-reference","title":"API Reference","text":""},{"location":"api/errors/retry/#pydantic_agent.errors.retry.create_retry_decorator","title":"create_retry_decorator","text":"<pre><code>create_retry_decorator(\n    config: ErrorRecoveryConfig | None = None,\n    *,\n    max_attempts: int | None = None,\n    base_wait: float | None = None,\n    max_wait: float | None = None,\n    retry_exceptions: tuple[type[Exception], ...]\n    | None = None,\n) -&gt; Callable[[Callable[..., T]], Callable[..., T]]\n</code></pre> <p>Create a retry decorator with the given configuration.</p> PARAMETER DESCRIPTION <code>config</code> <p>Error recovery configuration.</p> <p> TYPE: <code>ErrorRecoveryConfig | None</code> DEFAULT: <code>None</code> </p> <code>max_attempts</code> <p>Override max retry attempts.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>base_wait</code> <p>Override base wait time in seconds.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>max_wait</code> <p>Override max wait time in seconds.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> <code>retry_exceptions</code> <p>Override exceptions to retry on.</p> <p> TYPE: <code>tuple[type[Exception], ...] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Callable[[Callable[..., T]], Callable[..., T]]</code> <p>Retry decorator.</p> Source code in <code>src/pydantic_agent/errors/retry.py</code> <pre><code>def create_retry_decorator(\n    config: ErrorRecoveryConfig | None = None,\n    *,\n    max_attempts: int | None = None,\n    base_wait: float | None = None,\n    max_wait: float | None = None,\n    retry_exceptions: tuple[type[Exception], ...] | None = None,\n) -&gt; Callable[[Callable[..., T]], Callable[..., T]]:\n    \"\"\"Create a retry decorator with the given configuration.\n\n    Args:\n        config: Error recovery configuration.\n        max_attempts: Override max retry attempts.\n        base_wait: Override base wait time in seconds.\n        max_wait: Override max wait time in seconds.\n        retry_exceptions: Override exceptions to retry on.\n\n    Returns:\n        Retry decorator.\n    \"\"\"\n    if config is None:\n        config = ErrorRecoveryConfig()\n\n    # Use overrides or config values\n    attempts = max_attempts if max_attempts is not None else config.max_retries + 1\n    wait_base = base_wait if base_wait is not None else config.base_retry_delay\n    wait_max = max_wait if max_wait is not None else config.max_retry_delay\n\n    # Default retry exceptions if not specified\n    if retry_exceptions is None:\n        retry_exceptions = (RateLimitError, ConnectionError, TimeoutError)\n\n    return retry(\n        stop=stop_after_attempt(attempts),\n        wait=wait_exponential(multiplier=wait_base, max=wait_max),\n        retry=retry_if_exception_type(retry_exceptions),\n        before_sleep=_log_retry_attempt,\n        reraise=True,\n    )\n</code></pre>"},{"location":"api/mcp/","title":"MCP Module","text":"<p>Model Context Protocol integration.</p>"},{"location":"api/mcp/#classes","title":"Classes","text":"Class Description MCPClientManager Manage MCP server connections MCPServerConfig Server configuration"},{"location":"api/mcp/#quick-example","title":"Quick Example","text":"<pre><code>from pydantic_agent import Agent\nfrom pydantic_agent.mcp import MCPClientManager, MCPServerConfig\n\nservers = [\n    MCPServerConfig(\n        name=\"filesystem\",\n        transport=\"stdio\",\n        command=\"npx\",\n        args=[\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/path\"],\n    ),\n]\n\nasync with MCPClientManager(servers) as manager:\n    toolsets = manager.get_toolsets()\n    agent = Agent(\"gpt-4o\", tools=toolsets)\n</code></pre>"},{"location":"api/mcp/#imports","title":"Imports","text":"<pre><code>from pydantic_agent.mcp import MCPClientManager, MCPServerConfig, MCPAuthConfig\n</code></pre>"},{"location":"api/mcp/client/","title":"MCPClientManager","text":"<p>Manage MCP server connections.</p>"},{"location":"api/mcp/client/#quick-example","title":"Quick Example","text":"<pre><code>from pydantic_agent.mcp import MCPClientManager, MCPServerConfig\n\nmanager = MCPClientManager()\n\n# Add server\nmanager.add_server(MCPServerConfig(\n    name=\"server1\",\n    transport=\"stdio\",\n    command=\"my-server\",\n))\n\n# Connect\nawait manager.connect_all()\n\n# Get tools\ntoolsets = manager.get_toolsets()\n\n# Check status\nstatus = manager.get_status(\"server1\")\n\n# Disconnect\nawait manager.disconnect_all()\n</code></pre>"},{"location":"api/mcp/client/#context-manager","title":"Context Manager","text":"<pre><code>async with MCPClientManager(servers) as manager:\n    toolsets = manager.get_toolsets()\n    # Auto-connects and disconnects\n</code></pre>"},{"location":"api/mcp/client/#api-reference","title":"API Reference","text":""},{"location":"api/mcp/client/#pydantic_agent.mcp.client.MCPClientManager","title":"MCPClientManager","text":"<pre><code>MCPClientManager(\n    configs: list[MCPServerConfig] | None = None,\n)\n</code></pre> <p>Manages MCP server connections.</p> <p>Provides a high-level interface for connecting to and managing multiple MCP servers.</p> <p>Initialize the MCP client manager.</p> PARAMETER DESCRIPTION <code>configs</code> <p>Optional list of server configurations to connect.</p> <p> TYPE: <code>list[MCPServerConfig] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/pydantic_agent/mcp/client.py</code> <pre><code>def __init__(self, configs: list[MCPServerConfig] | None = None) -&gt; None:\n    \"\"\"Initialize the MCP client manager.\n\n    Args:\n        configs: Optional list of server configurations to connect.\n    \"\"\"\n    self._configs = configs or []\n    self._lifecycle = ServerLifecycleManager()\n</code></pre>"},{"location":"api/mcp/client/#pydantic_agent.mcp.client.MCPClientManager.add_server","title":"add_server","text":"<pre><code>add_server(config: MCPServerConfig) -&gt; None\n</code></pre> <p>Add a server configuration.</p> PARAMETER DESCRIPTION <code>config</code> <p>Server configuration to add.</p> <p> TYPE: <code>MCPServerConfig</code> </p> Source code in <code>src/pydantic_agent/mcp/client.py</code> <pre><code>def add_server(self, config: MCPServerConfig) -&gt; None:\n    \"\"\"Add a server configuration.\n\n    Args:\n        config: Server configuration to add.\n    \"\"\"\n    self._configs.append(config)\n</code></pre>"},{"location":"api/mcp/client/#pydantic_agent.mcp.client.MCPClientManager.connect_all","title":"connect_all  <code>async</code>","text":"<pre><code>connect_all() -&gt; list[MCPServer]\n</code></pre> <p>Connect to all configured servers.</p> RETURNS DESCRIPTION <code>list[MCPServer]</code> <p>List of connected MCPServer instances.</p> RAISES DESCRIPTION <code>ConnectionError</code> <p>If any server fails to connect.</p> Source code in <code>src/pydantic_agent/mcp/client.py</code> <pre><code>async def connect_all(self) -&gt; list[MCPServer]:\n    \"\"\"Connect to all configured servers.\n\n    Returns:\n        List of connected MCPServer instances.\n\n    Raises:\n        ConnectionError: If any server fails to connect.\n    \"\"\"\n    servers = []\n    for config in self._configs:\n        server = await self._lifecycle.start_server(config)\n        servers.append(server)\n    return servers\n</code></pre>"},{"location":"api/mcp/client/#pydantic_agent.mcp.client.MCPClientManager.disconnect_all","title":"disconnect_all  <code>async</code>","text":"<pre><code>disconnect_all() -&gt; None\n</code></pre> <p>Disconnect from all servers.</p> Source code in <code>src/pydantic_agent/mcp/client.py</code> <pre><code>async def disconnect_all(self) -&gt; None:\n    \"\"\"Disconnect from all servers.\"\"\"\n    await self._lifecycle.stop_all()\n</code></pre>"},{"location":"api/mcp/client/#pydantic_agent.mcp.client.MCPClientManager.get_toolsets","title":"get_toolsets","text":"<pre><code>get_toolsets() -&gt; list[MCPServer]\n</code></pre> <p>Get MCP servers as toolsets for pydantic-ai Agent.</p> RETURNS DESCRIPTION <code>list[MCPServer]</code> <p>List of MCPServer instances to use as toolsets.</p> Source code in <code>src/pydantic_agent/mcp/client.py</code> <pre><code>def get_toolsets(self) -&gt; list[MCPServer]:\n    \"\"\"Get MCP servers as toolsets for pydantic-ai Agent.\n\n    Returns:\n        List of MCPServer instances to use as toolsets.\n    \"\"\"\n    return self._lifecycle.get_all_servers()\n</code></pre>"},{"location":"api/mcp/client/#pydantic_agent.mcp.client.MCPClientManager.get_server","title":"get_server","text":"<pre><code>get_server(name: str) -&gt; MCPServer | None\n</code></pre> <p>Get a specific server by name.</p> PARAMETER DESCRIPTION <code>name</code> <p>Server name.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>MCPServer | None</code> <p>The MCPServer if connected, None otherwise.</p> Source code in <code>src/pydantic_agent/mcp/client.py</code> <pre><code>def get_server(self, name: str) -&gt; MCPServer | None:\n    \"\"\"Get a specific server by name.\n\n    Args:\n        name: Server name.\n\n    Returns:\n        The MCPServer if connected, None otherwise.\n    \"\"\"\n    return self._lifecycle.get_server(name)\n</code></pre>"},{"location":"api/mcp/client/#pydantic_agent.mcp.client.MCPClientManager.get_status","title":"get_status","text":"<pre><code>get_status(name: str) -&gt; ServerStatus\n</code></pre> <p>Get the status of a server.</p> PARAMETER DESCRIPTION <code>name</code> <p>Server name.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>ServerStatus</code> <p>ServerStatus object with state information.</p> Source code in <code>src/pydantic_agent/mcp/client.py</code> <pre><code>def get_status(self, name: str) -&gt; ServerStatus:\n    \"\"\"Get the status of a server.\n\n    Args:\n        name: Server name.\n\n    Returns:\n        ServerStatus object with state information.\n    \"\"\"\n    return self._lifecycle.get_status(name)\n</code></pre>"},{"location":"api/mcp/client/#pydantic_agent.mcp.client.MCPClientManager.get_all_statuses","title":"get_all_statuses","text":"<pre><code>get_all_statuses() -&gt; list[ServerStatus]\n</code></pre> <p>Get status of all servers.</p> RETURNS DESCRIPTION <code>list[ServerStatus]</code> <p>List of ServerStatus objects.</p> Source code in <code>src/pydantic_agent/mcp/client.py</code> <pre><code>def get_all_statuses(self) -&gt; list[ServerStatus]:\n    \"\"\"Get status of all servers.\n\n    Returns:\n        List of ServerStatus objects.\n    \"\"\"\n    return self._lifecycle.get_all_statuses()\n</code></pre>"},{"location":"api/mcp/config/","title":"MCPServerConfig","text":"<p>Configuration for MCP servers.</p>"},{"location":"api/mcp/config/#quick-example","title":"Quick Example","text":"<pre><code>from pydantic_agent.mcp import MCPServerConfig, MCPAuthConfig\n\n# Stdio transport\nconfig = MCPServerConfig(\n    name=\"filesystem\",\n    transport=\"stdio\",\n    command=\"npx\",\n    args=[\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/path\"],\n)\n\n# SSE transport with auth\nconfig = MCPServerConfig(\n    name=\"api\",\n    transport=\"sse\",\n    url=\"http://localhost:8080/sse\",\n    auth=MCPAuthConfig(\n        type=\"api_key\",\n        key_env=\"API_KEY\",\n    ),\n)\n</code></pre>"},{"location":"api/mcp/config/#configuration-options","title":"Configuration Options","text":""},{"location":"api/mcp/config/#mcpserverconfig_1","title":"MCPServerConfig","text":"Option Type Description <code>name</code> str Unique server name <code>transport</code> str <code>\"stdio\"</code> or <code>\"sse\"</code> <code>command</code> str Command (stdio) <code>args</code> list Arguments (stdio) <code>url</code> str Server URL (sse) <code>auth</code> MCPAuthConfig Authentication <code>tool_prefix</code> str Prefix for tools"},{"location":"api/mcp/config/#mcpauthconfig","title":"MCPAuthConfig","text":"Option Type Description <code>type</code> str <code>\"api_key\"</code> <code>key</code> str Direct key <code>key_env</code> str Env var name <code>header</code> str HTTP header"},{"location":"api/mcp/config/#api-reference","title":"API Reference","text":""},{"location":"api/mcp/config/#pydantic_agent.mcp.config.MCPServerConfig","title":"MCPServerConfig","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration for an MCP server.</p> <p>Supports both stdio (subprocess) and SSE (HTTP) transports.</p> ATTRIBUTE DESCRIPTION <code>name</code> <p>Unique server name.</p> <p> TYPE: <code>str</code> </p> <code>transport</code> <p>Transport type (stdio or sse).</p> <p> TYPE: <code>Literal['stdio', 'sse']</code> </p> <code>command</code> <p>Command to run (stdio transport).</p> <p> TYPE: <code>str | None</code> </p> <code>args</code> <p>Command arguments (stdio transport).</p> <p> TYPE: <code>list[str]</code> </p> <code>url</code> <p>Server URL (SSE transport).</p> <p> TYPE: <code>str | None</code> </p> <code>auth</code> <p>Authentication configuration.</p> <p> TYPE: <code>MCPAuthConfig | None</code> </p> <code>tool_prefix</code> <p>Prefix for tool names from this server.</p> <p> TYPE: <code>str | None</code> </p>"},{"location":"api/mcp/config/#pydantic_agent.mcp.config.MCPAuthConfig","title":"MCPAuthConfig","text":"<p>               Bases: <code>BaseModel</code></p> <p>Authentication configuration for MCP servers.</p> ATTRIBUTE DESCRIPTION <code>type</code> <p>Authentication type (currently only api_key supported).</p> <p> TYPE: <code>Literal['api_key']</code> </p> <code>key_env</code> <p>Environment variable name containing the API key.</p> <p> TYPE: <code>str | None</code> </p> <code>key</code> <p>Direct key value or env var reference (${VAR_NAME}).</p> <p> TYPE: <code>str | None</code> </p> <code>header</code> <p>HTTP header name for the key.</p> <p> TYPE: <code>str</code> </p>"},{"location":"api/observability/","title":"Observability Module","text":"<p>Logging, tracing, and OpenTelemetry integration.</p>"},{"location":"api/observability/#classes","title":"Classes","text":"Class Description Logging Structured logging Tracing Request tracing OpenTelemetry OTel integration"},{"location":"api/observability/#quick-example","title":"Quick Example","text":"<pre><code>from pydantic_agent.observability import (\n    setup_logging,\n    RequestTracer,\n    get_otel_integration,\n)\nfrom pydantic_agent.config import LoggingConfig\n\n# Setup logging\nconfig = LoggingConfig(level=\"INFO\", format=\"json\")\nlogger = setup_logging(config)\n\n# Request tracing\ntracer = RequestTracer()\ntracer.start_trace()\nwith tracer.start_span(\"operation\") as span:\n    span.set_attribute(\"key\", \"value\")\ntrace = tracer.end_trace()\n\n# OpenTelemetry\notel = get_otel_integration()\notel.initialize()\n</code></pre>"},{"location":"api/observability/#imports","title":"Imports","text":"<pre><code>from pydantic_agent.observability import (\n    setup_logging,\n    AgentLogger,\n    RequestTracer,\n    get_otel_integration,\n    OTelIntegration,\n)\n</code></pre>"},{"location":"api/observability/logging/","title":"Logging","text":"<p>Structured logging utilities.</p>"},{"location":"api/observability/logging/#quick-example","title":"Quick Example","text":"<pre><code>from pydantic_agent.observability import setup_logging\nfrom pydantic_agent.config import LoggingConfig\n\nconfig = LoggingConfig(\n    level=\"INFO\",\n    format=\"json\",\n    redact_sensitive=True,\n)\n\nlogger = setup_logging(config)\nlogger.info(\"Agent started\", model=\"gpt-4o\")\n</code></pre>"},{"location":"api/observability/logging/#formats","title":"Formats","text":""},{"location":"api/observability/logging/#text-format","title":"Text Format","text":"<pre><code>2024-01-15 10:30:00 INFO [agent] Starting agent run\n</code></pre>"},{"location":"api/observability/logging/#json-format","title":"JSON Format","text":"<pre><code>{\"timestamp\": \"2024-01-15T10:30:00\", \"level\": \"INFO\", \"message\": \"Starting agent run\"}\n</code></pre>"},{"location":"api/observability/logging/#configuration","title":"Configuration","text":"Option Type Default Description <code>level</code> str <code>\"INFO\"</code> Log level <code>format</code> str <code>\"text\"</code> Output format <code>redact_sensitive</code> bool True Redact secrets"},{"location":"api/observability/logging/#api-reference","title":"API Reference","text":""},{"location":"api/observability/logging/#pydantic_agent.observability.logging.setup_logging","title":"setup_logging","text":"<pre><code>setup_logging(\n    config: LoggingConfig | None = None,\n    name: str = \"pydantic_agent\",\n) -&gt; AgentLogger\n</code></pre> <p>Set up logging with the given configuration.</p> PARAMETER DESCRIPTION <code>config</code> <p>Logging configuration.</p> <p> TYPE: <code>LoggingConfig | None</code> DEFAULT: <code>None</code> </p> <code>name</code> <p>Logger name.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'pydantic_agent'</code> </p> RETURNS DESCRIPTION <code>AgentLogger</code> <p>Configured AgentLogger instance.</p> Source code in <code>src/pydantic_agent/observability/logging.py</code> <pre><code>def setup_logging(\n    config: LoggingConfig | None = None,\n    name: str = \"pydantic_agent\",\n) -&gt; AgentLogger:\n    \"\"\"Set up logging with the given configuration.\n\n    Args:\n        config: Logging configuration.\n        name: Logger name.\n\n    Returns:\n        Configured AgentLogger instance.\n    \"\"\"\n    if config is None:\n        config = LoggingConfig()\n\n    logger = logging.getLogger(name)\n    logger.setLevel(getattr(logging, config.level.upper()))\n\n    # Remove existing handlers\n    logger.handlers.clear()\n\n    # Create handler\n    if config.file:\n        handler: logging.Handler = logging.FileHandler(config.file)\n    else:\n        handler = logging.StreamHandler(sys.stderr)\n\n    handler.setLevel(getattr(logging, config.level.upper()))\n\n    # Set formatter\n    if config.format == \"json\":\n        formatter: logging.Formatter = StructuredFormatter(include_extras=config.include_timestamps)\n    else:\n        fmt = \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n        formatter = logging.Formatter(fmt)\n\n    handler.setFormatter(formatter)\n\n    # Add sensitive data filter if redaction is enabled\n    if config.redact_sensitive:\n        handler.addFilter(SensitiveDataFilter())\n\n    logger.addHandler(handler)\n\n    return AgentLogger(logger)\n</code></pre>"},{"location":"api/observability/logging/#pydantic_agent.observability.logging.AgentLogger","title":"AgentLogger","text":"<pre><code>AgentLogger(logger: Logger)\n</code></pre> <p>Wrapper around logging.Logger with structured logging support.</p> <p>Initialize the agent logger.</p> PARAMETER DESCRIPTION <code>logger</code> <p>Underlying logger.</p> <p> TYPE: <code>Logger</code> </p> Source code in <code>src/pydantic_agent/observability/logging.py</code> <pre><code>def __init__(self, logger: logging.Logger) -&gt; None:\n    \"\"\"Initialize the agent logger.\n\n    Args:\n        logger: Underlying logger.\n    \"\"\"\n    self._logger = logger\n</code></pre>"},{"location":"api/observability/logging/#pydantic_agent.observability.logging.AgentLogger.debug","title":"debug","text":"<pre><code>debug(msg: str, **kwargs: Any) -&gt; None\n</code></pre> <p>Log debug message.</p> Source code in <code>src/pydantic_agent/observability/logging.py</code> <pre><code>def debug(self, msg: str, **kwargs: Any) -&gt; None:\n    \"\"\"Log debug message.\"\"\"\n    self._log(logging.DEBUG, msg, kwargs)\n</code></pre>"},{"location":"api/observability/logging/#pydantic_agent.observability.logging.AgentLogger.info","title":"info","text":"<pre><code>info(msg: str, **kwargs: Any) -&gt; None\n</code></pre> <p>Log info message.</p> Source code in <code>src/pydantic_agent/observability/logging.py</code> <pre><code>def info(self, msg: str, **kwargs: Any) -&gt; None:\n    \"\"\"Log info message.\"\"\"\n    self._log(logging.INFO, msg, kwargs)\n</code></pre>"},{"location":"api/observability/logging/#pydantic_agent.observability.logging.AgentLogger.warning","title":"warning","text":"<pre><code>warning(msg: str, **kwargs: Any) -&gt; None\n</code></pre> <p>Log warning message.</p> Source code in <code>src/pydantic_agent/observability/logging.py</code> <pre><code>def warning(self, msg: str, **kwargs: Any) -&gt; None:\n    \"\"\"Log warning message.\"\"\"\n    self._log(logging.WARNING, msg, kwargs)\n</code></pre>"},{"location":"api/observability/logging/#pydantic_agent.observability.logging.AgentLogger.error","title":"error","text":"<pre><code>error(msg: str, **kwargs: Any) -&gt; None\n</code></pre> <p>Log error message.</p> Source code in <code>src/pydantic_agent/observability/logging.py</code> <pre><code>def error(self, msg: str, **kwargs: Any) -&gt; None:\n    \"\"\"Log error message.\"\"\"\n    self._log(logging.ERROR, msg, kwargs)\n</code></pre>"},{"location":"api/observability/logging/#pydantic_agent.observability.logging.AgentLogger.exception","title":"exception","text":"<pre><code>exception(msg: str, **kwargs: Any) -&gt; None\n</code></pre> <p>Log exception with traceback.</p> Source code in <code>src/pydantic_agent/observability/logging.py</code> <pre><code>def exception(self, msg: str, **kwargs: Any) -&gt; None:\n    \"\"\"Log exception with traceback.\"\"\"\n    self._log(logging.ERROR, msg, kwargs, exc_info=True)\n</code></pre>"},{"location":"api/observability/otel/","title":"OpenTelemetry Integration","text":"<p>OpenTelemetry tracing and metrics.</p>"},{"location":"api/observability/otel/#prerequisites","title":"Prerequisites","text":"<pre><code>uv add pydantic-agent[otel]\n</code></pre>"},{"location":"api/observability/otel/#quick-example","title":"Quick Example","text":"<pre><code>from pydantic_agent.observability import get_otel_integration\n\notel = get_otel_integration()\n\n# Initialize\nif otel.initialize():\n    print(\"OpenTelemetry initialized\")\n\n# Trace operations\nwith otel.trace_agent_run(prompt, model=\"gpt-4o\") as span:\n    result = await agent.run(prompt)\n    span.set_attribute(\"tokens\", result.usage().total_tokens)\n</code></pre>"},{"location":"api/observability/otel/#exporters","title":"Exporters","text":""},{"location":"api/observability/otel/#jaeger","title":"Jaeger","text":"<pre><code>from opentelemetry.exporter.jaeger.thrift import JaegerExporter\nfrom opentelemetry.sdk.trace.export import BatchSpanProcessor\n\notel.add_span_processor(BatchSpanProcessor(\n    JaegerExporter(agent_host_name=\"localhost\", agent_port=6831)\n))\n</code></pre>"},{"location":"api/observability/otel/#otlp","title":"OTLP","text":"<pre><code>from opentelemetry.exporter.otlp.proto.grpc.trace_exporter import OTLPSpanExporter\nfrom opentelemetry.sdk.trace.export import BatchSpanProcessor\n\notel.add_span_processor(BatchSpanProcessor(\n    OTLPSpanExporter(endpoint=\"https://otlp.example.com:4317\")\n))\n</code></pre>"},{"location":"api/observability/otel/#configuration","title":"Configuration","text":"<pre><code>from pydantic_agent.config import ObservabilityConfig\n\nconfig = ObservabilityConfig(\n    enable_tracing=True,\n    service_name=\"my-agent\",\n)\n</code></pre>"},{"location":"api/observability/otel/#api-reference","title":"API Reference","text":""},{"location":"api/observability/otel/#pydantic_agent.observability.otel.OTelIntegration","title":"OTelIntegration","text":"<pre><code>OTelIntegration(service_name: str = 'pydantic-agent')\n</code></pre> <p>OpenTelemetry integration for the agent.</p> <p>Provides hooks for tracing agent operations when OpenTelemetry is available.</p> <p>Initialize OpenTelemetry integration.</p> PARAMETER DESCRIPTION <code>service_name</code> <p>Service name for tracing.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'pydantic-agent'</code> </p> Source code in <code>src/pydantic_agent/observability/otel.py</code> <pre><code>def __init__(self, service_name: str = \"pydantic-agent\") -&gt; None:\n    \"\"\"Initialize OpenTelemetry integration.\n\n    Args:\n        service_name: Service name for tracing.\n    \"\"\"\n    self._service_name = service_name\n    self._tracer: TracerProtocol | NoOpTracer = NoOpTracer()\n    self._initialized = False\n</code></pre>"},{"location":"api/observability/otel/#pydantic_agent.observability.otel.OTelIntegration.is_initialized","title":"is_initialized  <code>property</code>","text":"<pre><code>is_initialized: bool\n</code></pre> <p>Check if OpenTelemetry is initialized.</p>"},{"location":"api/observability/otel/#pydantic_agent.observability.otel.OTelIntegration.initialize","title":"initialize","text":"<pre><code>initialize() -&gt; bool\n</code></pre> <p>Initialize OpenTelemetry if available.</p> RETURNS DESCRIPTION <code>bool</code> <p>True if OpenTelemetry was initialized.</p> Source code in <code>src/pydantic_agent/observability/otel.py</code> <pre><code>def initialize(self) -&gt; bool:\n    \"\"\"Initialize OpenTelemetry if available.\n\n    Returns:\n        True if OpenTelemetry was initialized.\n    \"\"\"\n    try:\n        from opentelemetry import trace\n        from opentelemetry.sdk.trace import TracerProvider\n\n        provider = TracerProvider()\n        trace.set_tracer_provider(provider)\n        self._tracer = trace.get_tracer(self._service_name)\n        self._initialized = True\n        return True\n    except ImportError:\n        self._initialized = False\n        return False\n</code></pre>"},{"location":"api/observability/otel/#pydantic_agent.observability.otel.OTelIntegration.trace_agent_run","title":"trace_agent_run","text":"<pre><code>trace_agent_run(\n    prompt: str, model: str | None = None\n) -&gt; Generator[SpanProtocol | NoOpSpan, None, None]\n</code></pre> <p>Create a span for an agent run.</p> PARAMETER DESCRIPTION <code>prompt</code> <p>The user prompt.</p> <p> TYPE: <code>str</code> </p> <code>model</code> <p>Model being used.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> YIELDS DESCRIPTION <code>SpanProtocol | NoOpSpan</code> <p>Span for the agent run.</p> Source code in <code>src/pydantic_agent/observability/otel.py</code> <pre><code>def trace_agent_run(\n    self,\n    prompt: str,\n    model: str | None = None,\n) -&gt; Generator[SpanProtocol | NoOpSpan, None, None]:\n    \"\"\"Create a span for an agent run.\n\n    Args:\n        prompt: The user prompt.\n        model: Model being used.\n\n    Yields:\n        Span for the agent run.\n    \"\"\"\n    span = self._tracer.start_span(\"agent.run\")\n    try:\n        span.set_attribute(\"agent.prompt_length\", len(prompt))\n        if model:\n            span.set_attribute(\"agent.model\", model)\n        yield span\n    finally:\n        span.end()\n</code></pre>"},{"location":"api/observability/otel/#pydantic_agent.observability.otel.OTelIntegration.trace_tool_call","title":"trace_tool_call","text":"<pre><code>trace_tool_call(\n    tool_name: str, args: dict[str, Any] | None = None\n) -&gt; Generator[SpanProtocol | NoOpSpan, None, None]\n</code></pre> <p>Create a span for a tool call.</p> PARAMETER DESCRIPTION <code>tool_name</code> <p>Name of the tool.</p> <p> TYPE: <code>str</code> </p> <code>args</code> <p>Tool arguments.</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> YIELDS DESCRIPTION <code>SpanProtocol | NoOpSpan</code> <p>Span for the tool call.</p> Source code in <code>src/pydantic_agent/observability/otel.py</code> <pre><code>def trace_tool_call(\n    self,\n    tool_name: str,\n    args: dict[str, Any] | None = None,\n) -&gt; Generator[SpanProtocol | NoOpSpan, None, None]:\n    \"\"\"Create a span for a tool call.\n\n    Args:\n        tool_name: Name of the tool.\n        args: Tool arguments.\n\n    Yields:\n        Span for the tool call.\n    \"\"\"\n    span = self._tracer.start_span(f\"tool.{tool_name}\")\n    try:\n        span.set_attribute(\"tool.name\", tool_name)\n        if args:\n            span.set_attribute(\"tool.arg_count\", len(args))\n        yield span\n    finally:\n        span.end()\n</code></pre>"},{"location":"api/observability/otel/#pydantic_agent.observability.otel.OTelIntegration.trace_model_request","title":"trace_model_request","text":"<pre><code>trace_model_request(\n    model: str, token_count: int | None = None\n) -&gt; Generator[SpanProtocol | NoOpSpan, None, None]\n</code></pre> <p>Create a span for a model request.</p> PARAMETER DESCRIPTION <code>model</code> <p>Model name.</p> <p> TYPE: <code>str</code> </p> <code>token_count</code> <p>Input token count.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> YIELDS DESCRIPTION <code>SpanProtocol | NoOpSpan</code> <p>Span for the model request.</p> Source code in <code>src/pydantic_agent/observability/otel.py</code> <pre><code>def trace_model_request(\n    self,\n    model: str,\n    token_count: int | None = None,\n) -&gt; Generator[SpanProtocol | NoOpSpan, None, None]:\n    \"\"\"Create a span for a model request.\n\n    Args:\n        model: Model name.\n        token_count: Input token count.\n\n    Yields:\n        Span for the model request.\n    \"\"\"\n    span = self._tracer.start_span(\"model.request\")\n    try:\n        span.set_attribute(\"model.name\", model)\n        if token_count:\n            span.set_attribute(\"model.input_tokens\", token_count)\n        yield span\n    finally:\n        span.end()\n</code></pre>"},{"location":"api/observability/otel/#pydantic_agent.observability.otel.OTelIntegration.record_usage","title":"record_usage","text":"<pre><code>record_usage(\n    input_tokens: int,\n    output_tokens: int,\n    model: str | None = None,\n) -&gt; None\n</code></pre> <p>Record token usage as metrics.</p> PARAMETER DESCRIPTION <code>input_tokens</code> <p>Number of input tokens.</p> <p> TYPE: <code>int</code> </p> <code>output_tokens</code> <p>Number of output tokens.</p> <p> TYPE: <code>int</code> </p> <code>model</code> <p>Model used.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/pydantic_agent/observability/otel.py</code> <pre><code>def record_usage(\n    self,\n    input_tokens: int,\n    output_tokens: int,\n    model: str | None = None,\n) -&gt; None:\n    \"\"\"Record token usage as metrics.\n\n    Args:\n        input_tokens: Number of input tokens.\n        output_tokens: Number of output tokens.\n        model: Model used.\n    \"\"\"\n    if not self._initialized:\n        return\n\n    try:\n        from opentelemetry import metrics\n\n        meter = metrics.get_meter(self._service_name)\n\n        input_counter = meter.create_counter(\n            \"agent.tokens.input\",\n            description=\"Input tokens used\",\n        )\n        output_counter = meter.create_counter(\n            \"agent.tokens.output\",\n            description=\"Output tokens used\",\n        )\n\n        attributes = {\"model\": model} if model else {}\n        input_counter.add(input_tokens, attributes)\n        output_counter.add(output_tokens, attributes)\n    except ImportError:\n        pass\n</code></pre>"},{"location":"api/observability/otel/#pydantic_agent.observability.otel.get_otel_integration","title":"get_otel_integration","text":"<pre><code>get_otel_integration() -&gt; OTelIntegration\n</code></pre> <p>Get the global OpenTelemetry integration.</p> RETURNS DESCRIPTION <code>OTelIntegration</code> <p>OTelIntegration instance.</p> Source code in <code>src/pydantic_agent/observability/otel.py</code> <pre><code>def get_otel_integration() -&gt; OTelIntegration:\n    \"\"\"Get the global OpenTelemetry integration.\n\n    Returns:\n        OTelIntegration instance.\n    \"\"\"\n    global _otel_integration\n    if _otel_integration is None:\n        _otel_integration = OTelIntegration()\n    return _otel_integration\n</code></pre>"},{"location":"api/observability/tracing/","title":"Tracing","text":"<p>Request tracing utilities.</p>"},{"location":"api/observability/tracing/#quick-example","title":"Quick Example","text":"<pre><code>from pydantic_agent.observability import RequestTracer\n\ntracer = RequestTracer()\n\n# Start trace\ntracer.start_trace()\n\n# Create spans\nwith tracer.start_span(\"operation\") as span:\n    span.set_attribute(\"model\", \"gpt-4o\")\n    span.set_attribute(\"tokens\", 1500)\n    # Do work...\n\n# Nested spans\nwith tracer.start_span(\"parent\") as parent:\n    with tracer.start_span(\"child\") as child:\n        child.set_attribute(\"step\", 1)\n\n# End trace\ntrace = tracer.end_trace()\nprint(f\"Duration: {trace.duration_seconds}s\")\n</code></pre>"},{"location":"api/observability/tracing/#trace-data","title":"Trace Data","text":"<pre><code>trace = tracer.end_trace()\n\nprint(f\"Trace ID: {trace.trace_id}\")\nprint(f\"Duration: {trace.duration_seconds}s\")\n\nfor span in trace.spans:\n    print(f\"{span.name}: {span.duration_ms}ms\")\n    for key, value in span.attributes.items():\n        print(f\"  {key}: {value}\")\n</code></pre>"},{"location":"api/observability/tracing/#api-reference","title":"API Reference","text":""},{"location":"api/observability/tracing/#pydantic_agent.observability.tracing.RequestTracer","title":"RequestTracer","text":"<pre><code>RequestTracer(service_name: str = 'pydantic-agent')\n</code></pre> <p>Tracer for tracking requests through the agent.</p> <p>Initialize the tracer.</p> PARAMETER DESCRIPTION <code>service_name</code> <p>Name of the service being traced.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'pydantic-agent'</code> </p> Source code in <code>src/pydantic_agent/observability/tracing.py</code> <pre><code>def __init__(self, service_name: str = \"pydantic-agent\") -&gt; None:\n    \"\"\"Initialize the tracer.\n\n    Args:\n        service_name: Name of the service being traced.\n    \"\"\"\n    self._service_name = service_name\n    self._context: TraceContext | None = None\n    self._current_span_id: str | None = None\n</code></pre>"},{"location":"api/observability/tracing/#pydantic_agent.observability.tracing.RequestTracer.trace_id","title":"trace_id  <code>property</code>","text":"<pre><code>trace_id: str | None\n</code></pre> <p>Get current trace ID.</p>"},{"location":"api/observability/tracing/#pydantic_agent.observability.tracing.RequestTracer.current_span_id","title":"current_span_id  <code>property</code>","text":"<pre><code>current_span_id: str | None\n</code></pre> <p>Get current span ID.</p>"},{"location":"api/observability/tracing/#pydantic_agent.observability.tracing.RequestTracer.start_trace","title":"start_trace","text":"<pre><code>start_trace(\n    attributes: dict[str, Any] | None = None,\n) -&gt; TraceContext\n</code></pre> <p>Start a new trace.</p> PARAMETER DESCRIPTION <code>attributes</code> <p>Initial trace attributes.</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>TraceContext</code> <p>New TraceContext.</p> Source code in <code>src/pydantic_agent/observability/tracing.py</code> <pre><code>def start_trace(self, attributes: dict[str, Any] | None = None) -&gt; TraceContext:\n    \"\"\"Start a new trace.\n\n    Args:\n        attributes: Initial trace attributes.\n\n    Returns:\n        New TraceContext.\n    \"\"\"\n    self._context = TraceContext(\n        trace_id=uuid.uuid4().hex,\n        attributes=attributes or {},\n    )\n    _current_trace.set(self._context)\n    return self._context\n</code></pre>"},{"location":"api/observability/tracing/#pydantic_agent.observability.tracing.RequestTracer.end_trace","title":"end_trace","text":"<pre><code>end_trace() -&gt; TraceContext | None\n</code></pre> <p>End the current trace.</p> RETURNS DESCRIPTION <code>TraceContext | None</code> <p>Completed TraceContext or None.</p> Source code in <code>src/pydantic_agent/observability/tracing.py</code> <pre><code>def end_trace(self) -&gt; TraceContext | None:\n    \"\"\"End the current trace.\n\n    Returns:\n        Completed TraceContext or None.\n    \"\"\"\n    if self._context:\n        self._context.end_time = time.time()\n        ctx = self._context\n        self._context = None\n        self._current_span_id = None\n        _current_trace.set(None)\n        return ctx\n    return None\n</code></pre>"},{"location":"api/observability/tracing/#pydantic_agent.observability.tracing.RequestTracer.start_span","title":"start_span","text":"<pre><code>start_span(name: str) -&gt; Span\n</code></pre> <p>Start a new span.</p> PARAMETER DESCRIPTION <code>name</code> <p>Span name.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Span</code> <p>New Span.</p> Source code in <code>src/pydantic_agent/observability/tracing.py</code> <pre><code>def start_span(self, name: str) -&gt; Span:\n    \"\"\"Start a new span.\n\n    Args:\n        name: Span name.\n\n    Returns:\n        New Span.\n    \"\"\"\n    if self._context is None:\n        self.start_trace()\n\n    span = Span(self, name, parent_id=self._current_span_id)\n    self._current_span_id = span._data.span_id\n    return span\n</code></pre>"},{"location":"api/observability/tracing/#pydantic_agent.observability.tracing.RequestTracer.get_trace_context","title":"get_trace_context","text":"<pre><code>get_trace_context() -&gt; TraceContext | None\n</code></pre> <p>Get current trace context.</p> Source code in <code>src/pydantic_agent/observability/tracing.py</code> <pre><code>def get_trace_context(self) -&gt; TraceContext | None:\n    \"\"\"Get current trace context.\"\"\"\n    return self._context\n</code></pre>"},{"location":"api/observability/tracing/#pydantic_agent.observability.tracing.RequestTracer.get_trace_header","title":"get_trace_header","text":"<pre><code>get_trace_header() -&gt; dict[str, str]\n</code></pre> <p>Get trace context as headers for propagation.</p> RETURNS DESCRIPTION <code>dict[str, str]</code> <p>Dictionary with traceparent header.</p> Source code in <code>src/pydantic_agent/observability/tracing.py</code> <pre><code>def get_trace_header(self) -&gt; dict[str, str]:\n    \"\"\"Get trace context as headers for propagation.\n\n    Returns:\n        Dictionary with traceparent header.\n    \"\"\"\n    if not self._context:\n        return {}\n\n    span_id = self._current_span_id or \"0000000000000000\"\n    traceparent = f\"00-{self._context.trace_id}-{span_id}-01\"\n    return {\"traceparent\": traceparent}\n</code></pre>"},{"location":"api/observability/tracing/#pydantic_agent.observability.tracing.RequestTracer.from_header","title":"from_header  <code>classmethod</code>","text":"<pre><code>from_header(traceparent: str) -&gt; RequestTracer\n</code></pre> <p>Create tracer from incoming traceparent header.</p> PARAMETER DESCRIPTION <code>traceparent</code> <p>W3C traceparent header value.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>RequestTracer</code> <p>RequestTracer with context restored.</p> Source code in <code>src/pydantic_agent/observability/tracing.py</code> <pre><code>@classmethod\ndef from_header(cls, traceparent: str) -&gt; RequestTracer:\n    \"\"\"Create tracer from incoming traceparent header.\n\n    Args:\n        traceparent: W3C traceparent header value.\n\n    Returns:\n        RequestTracer with context restored.\n    \"\"\"\n    tracer = cls()\n\n    try:\n        parts = traceparent.split(\"-\")\n        if len(parts) &gt;= 3:\n            trace_id = parts[1]\n            parent_span_id = parts[2]\n\n            tracer._context = TraceContext(trace_id=trace_id)\n            tracer._current_span_id = parent_span_id\n            _current_trace.set(tracer._context)\n    except (ValueError, IndexError):\n        pass\n\n    return tracer\n</code></pre>"},{"location":"api/observability/tracing/#pydantic_agent.observability.tracing.Span","title":"Span","text":"<pre><code>Span(\n    tracer: RequestTracer,\n    name: str,\n    parent_id: str | None = None,\n)\n</code></pre> <p>A span representing a unit of work within a trace.</p> <p>Initialize the span.</p> PARAMETER DESCRIPTION <code>tracer</code> <p>Parent tracer.</p> <p> TYPE: <code>RequestTracer</code> </p> <code>name</code> <p>Span name.</p> <p> TYPE: <code>str</code> </p> <code>parent_id</code> <p>Parent span ID if nested.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/pydantic_agent/observability/tracing.py</code> <pre><code>def __init__(\n    self,\n    tracer: RequestTracer,\n    name: str,\n    parent_id: str | None = None,\n) -&gt; None:\n    \"\"\"Initialize the span.\n\n    Args:\n        tracer: Parent tracer.\n        name: Span name.\n        parent_id: Parent span ID if nested.\n    \"\"\"\n    self._tracer = tracer\n    self._data = SpanData(\n        name=name,\n        span_id=uuid.uuid4().hex[:16],\n        parent_id=parent_id,\n        start_time=time.time(),\n    )\n</code></pre>"},{"location":"api/observability/tracing/#pydantic_agent.observability.tracing.Span.set_attribute","title":"set_attribute","text":"<pre><code>set_attribute(key: str, value: Any) -&gt; None\n</code></pre> <p>Set a span attribute.</p> Source code in <code>src/pydantic_agent/observability/tracing.py</code> <pre><code>def set_attribute(self, key: str, value: Any) -&gt; None:\n    \"\"\"Set a span attribute.\"\"\"\n    self._data.attributes[key] = value\n</code></pre>"},{"location":"api/observability/tracing/#pydantic_agent.observability.tracing.Span.add_event","title":"add_event","text":"<pre><code>add_event(\n    name: str, attributes: dict[str, Any] | None = None\n) -&gt; None\n</code></pre> <p>Add an event to the span.</p> Source code in <code>src/pydantic_agent/observability/tracing.py</code> <pre><code>def add_event(self, name: str, attributes: dict[str, Any] | None = None) -&gt; None:\n    \"\"\"Add an event to the span.\"\"\"\n    self._data.events.append(\n        {\n            \"name\": name,\n            \"timestamp\": time.time(),\n            \"attributes\": attributes or {},\n        }\n    )\n</code></pre>"},{"location":"api/observability/tracing/#pydantic_agent.observability.tracing.Span.set_error","title":"set_error","text":"<pre><code>set_error(error: str) -&gt; None\n</code></pre> <p>Mark span as errored.</p> Source code in <code>src/pydantic_agent/observability/tracing.py</code> <pre><code>def set_error(self, error: str) -&gt; None:\n    \"\"\"Mark span as errored.\"\"\"\n    self._data.status = \"error\"\n    self._data.error = error\n</code></pre>"},{"location":"api/observability/tracing/#pydantic_agent.observability.tracing.Span.end","title":"end","text":"<pre><code>end() -&gt; None\n</code></pre> <p>End the span.</p> Source code in <code>src/pydantic_agent/observability/tracing.py</code> <pre><code>def end(self) -&gt; None:\n    \"\"\"End the span.\"\"\"\n    self._data.end_time = time.time()\n    self._tracer._add_span(self._data)\n</code></pre>"},{"location":"api/tokens/","title":"Tokens Module","text":"<p>Token counting and cost estimation.</p>"},{"location":"api/tokens/#classes","title":"Classes","text":"Class Description TokenCounter Count tokens in text UsageTracker Track usage across requests CostEstimator Estimate costs"},{"location":"api/tokens/#quick-example","title":"Quick Example","text":"<pre><code>from pydantic_agent.tokens import TokenCounter, UsageTracker, CostEstimator\n\n# Count tokens\ncounter = TokenCounter()\ncount = counter.count(\"Hello, world!\")\n\n# Track usage\ntracker = UsageTracker()\ntracker.record_usage(prompt_tokens=100, completion_tokens=50)\nusage = tracker.get_total_usage()\n\n# Estimate cost\nestimator = CostEstimator()\ncost = estimator.estimate(usage, model=\"gpt-4o\")\n</code></pre>"},{"location":"api/tokens/#imports","title":"Imports","text":"<pre><code>from pydantic_agent import TokenUsage, UsageRecord, CostBreakdown\nfrom pydantic_agent.tokens import TokenCounter, UsageTracker, CostEstimator\n</code></pre>"},{"location":"api/tokens/cost/","title":"CostEstimator","text":"<p>Estimate costs based on token usage.</p>"},{"location":"api/tokens/cost/#quick-example","title":"Quick Example","text":"<pre><code>from pydantic_agent.tokens import CostEstimator\n\nestimator = CostEstimator()\n\n# Estimate cost\nbreakdown = estimator.estimate(\n    prompt_tokens=1000,\n    completion_tokens=500,\n    model=\"gpt-4o\",\n)\nprint(f\"Total: ${breakdown.total_cost:.4f}\")\n\n# Custom rates\nestimator.set_rate(\"my-model\", 0.002)\n\n# Get rates\nall_rates = estimator.get_all_rates()\n</code></pre>"},{"location":"api/tokens/cost/#default-rates","title":"Default Rates","text":"Model Input (per 1M) Output (per 1M) gpt-4o $2.50 $10.00 gpt-4o-mini $0.15 $0.60 claude-3-5-sonnet $3.00 $15.00 Local models $0.00 $0.00"},{"location":"api/tokens/cost/#api-reference","title":"API Reference","text":""},{"location":"api/tokens/cost/#pydantic_agent.tokens.cost.CostEstimator","title":"CostEstimator","text":"<pre><code>CostEstimator(custom_rates: dict[str, float] | None = None)\n</code></pre> <p>Estimate costs based on token usage.</p> <p>Provides cost estimation for various models with configurable rates.</p> <p>Initialize the cost estimator.</p> PARAMETER DESCRIPTION <code>custom_rates</code> <p>Custom cost rates per 1000 tokens.           Overrides defaults for specified models.</p> <p> TYPE: <code>dict[str, float] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/pydantic_agent/tokens/cost.py</code> <pre><code>def __init__(\n    self,\n    custom_rates: dict[str, float] | None = None,\n) -&gt; None:\n    \"\"\"Initialize the cost estimator.\n\n    Args:\n        custom_rates: Custom cost rates per 1000 tokens.\n                      Overrides defaults for specified models.\n    \"\"\"\n    self._rates = DEFAULT_COST_RATES.copy()\n    if custom_rates:\n        self._rates.update(custom_rates)\n</code></pre>"},{"location":"api/tokens/cost/#pydantic_agent.tokens.cost.CostEstimator.get_rate","title":"get_rate","text":"<pre><code>get_rate(model: str) -&gt; float\n</code></pre> <p>Get the cost rate for a model.</p> PARAMETER DESCRIPTION <code>model</code> <p>Model name or identifier.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>float</code> <p>Cost per 1000 tokens.</p> Source code in <code>src/pydantic_agent/tokens/cost.py</code> <pre><code>def get_rate(self, model: str) -&gt; float:\n    \"\"\"Get the cost rate for a model.\n\n    Args:\n        model: Model name or identifier.\n\n    Returns:\n        Cost per 1000 tokens.\n    \"\"\"\n    # Check exact match\n    if model in self._rates:\n        return self._rates[model]\n\n    # Check prefix match\n    model_lower = model.lower()\n    for key, rate in self._rates.items():\n        if key.lower() in model_lower:\n            return rate\n\n    # Return default\n    return self._rates.get(\"default\", 0.0)\n</code></pre>"},{"location":"api/tokens/cost/#pydantic_agent.tokens.cost.CostEstimator.estimate","title":"estimate","text":"<pre><code>estimate(\n    usage: TokenUsage, model: str | None = None\n) -&gt; CostBreakdown\n</code></pre> <p>Estimate cost for token usage.</p> PARAMETER DESCRIPTION <code>usage</code> <p>Token usage to estimate cost for.</p> <p> TYPE: <code>TokenUsage</code> </p> <code>model</code> <p>Model to use for rate lookup.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>CostBreakdown</code> <p>CostBreakdown with detailed costs.</p> Source code in <code>src/pydantic_agent/tokens/cost.py</code> <pre><code>def estimate(\n    self,\n    usage: TokenUsage,\n    model: str | None = None,\n) -&gt; CostBreakdown:\n    \"\"\"Estimate cost for token usage.\n\n    Args:\n        usage: Token usage to estimate cost for.\n        model: Model to use for rate lookup.\n\n    Returns:\n        CostBreakdown with detailed costs.\n    \"\"\"\n    rate = self.get_rate(model or \"default\")\n\n    prompt_cost = (usage.prompt_tokens / 1000) * rate\n    completion_cost = (usage.completion_tokens / 1000) * rate\n    total_cost = prompt_cost + completion_cost\n\n    return CostBreakdown(\n        prompt_cost=prompt_cost,\n        completion_cost=completion_cost,\n        total_cost=total_cost,\n        model=model,\n    )\n</code></pre>"},{"location":"api/tokens/cost/#pydantic_agent.tokens.cost.CostEstimator.estimate_tokens","title":"estimate_tokens","text":"<pre><code>estimate_tokens(\n    token_count: int, model: str | None = None\n) -&gt; float\n</code></pre> <p>Estimate cost for a token count.</p> PARAMETER DESCRIPTION <code>token_count</code> <p>Number of tokens.</p> <p> TYPE: <code>int</code> </p> <code>model</code> <p>Model to use for rate lookup.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>float</code> <p>Estimated cost in USD.</p> Source code in <code>src/pydantic_agent/tokens/cost.py</code> <pre><code>def estimate_tokens(\n    self,\n    token_count: int,\n    model: str | None = None,\n) -&gt; float:\n    \"\"\"Estimate cost for a token count.\n\n    Args:\n        token_count: Number of tokens.\n        model: Model to use for rate lookup.\n\n    Returns:\n        Estimated cost in USD.\n    \"\"\"\n    rate = self.get_rate(model or \"default\")\n    return (token_count / 1000) * rate\n</code></pre>"},{"location":"api/tokens/cost/#pydantic_agent.tokens.cost.CostEstimator.set_rate","title":"set_rate","text":"<pre><code>set_rate(model: str, rate: float) -&gt; None\n</code></pre> <p>Set a custom rate for a model.</p> PARAMETER DESCRIPTION <code>model</code> <p>Model name.</p> <p> TYPE: <code>str</code> </p> <code>rate</code> <p>Cost per 1000 tokens.</p> <p> TYPE: <code>float</code> </p> Source code in <code>src/pydantic_agent/tokens/cost.py</code> <pre><code>def set_rate(self, model: str, rate: float) -&gt; None:\n    \"\"\"Set a custom rate for a model.\n\n    Args:\n        model: Model name.\n        rate: Cost per 1000 tokens.\n    \"\"\"\n    self._rates[model] = rate\n</code></pre>"},{"location":"api/tokens/cost/#pydantic_agent.tokens.cost.CostEstimator.get_all_rates","title":"get_all_rates","text":"<pre><code>get_all_rates() -&gt; dict[str, float]\n</code></pre> <p>Get all configured rates.</p> RETURNS DESCRIPTION <code>dict[str, float]</code> <p>Dictionary of model names to rates.</p> Source code in <code>src/pydantic_agent/tokens/cost.py</code> <pre><code>def get_all_rates(self) -&gt; dict[str, float]:\n    \"\"\"Get all configured rates.\n\n    Returns:\n        Dictionary of model names to rates.\n    \"\"\"\n    return self._rates.copy()\n</code></pre>"},{"location":"api/tokens/cost/#pydantic_agent.tokens.cost.CostBreakdown","title":"CostBreakdown  <code>dataclass</code>","text":"<pre><code>CostBreakdown(\n    prompt_cost: float,\n    completion_cost: float,\n    total_cost: float,\n    model: str | None = None,\n)\n</code></pre> <p>Cost breakdown by category.</p> ATTRIBUTE DESCRIPTION <code>prompt_cost</code> <p>Cost for prompt tokens.</p> <p> TYPE: <code>float</code> </p> <code>completion_cost</code> <p>Cost for completion tokens.</p> <p> TYPE: <code>float</code> </p> <code>total_cost</code> <p>Total cost.</p> <p> TYPE: <code>float</code> </p> <code>model</code> <p>Model used for calculation.</p> <p> TYPE: <code>str | None</code> </p>"},{"location":"api/tokens/counter/","title":"TokenCounter","text":"<p>Token counting using tiktoken.</p>"},{"location":"api/tokens/counter/#quick-example","title":"Quick Example","text":"<pre><code>from pydantic_agent.tokens import TokenCounter\n\ncounter = TokenCounter(encoding=\"cl100k_base\")\n\n# Count text tokens\ncount = counter.count(\"Hello, world!\")\n\n# Count message tokens\nmessages = [\n    {\"role\": \"user\", \"content\": \"Hello\"},\n    {\"role\": \"assistant\", \"content\": \"Hi!\"},\n]\ncount = counter.count_messages(messages)\n</code></pre>"},{"location":"api/tokens/counter/#api-reference","title":"API Reference","text":""},{"location":"api/tokens/counter/#pydantic_agent.tokens.counter.TokenCounter","title":"TokenCounter","text":"<pre><code>TokenCounter(config: TokenizerConfig | None = None)\n</code></pre> <p>Token counting using tiktoken.</p> <p>Provides methods for counting tokens in text and message lists. Token counts are approximate and may vary from actual model tokenization.</p> <p>Initialize the token counter.</p> PARAMETER DESCRIPTION <code>config</code> <p>Optional tokenizer configuration.</p> <p> TYPE: <code>TokenizerConfig | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/pydantic_agent/tokens/counter.py</code> <pre><code>def __init__(self, config: TokenizerConfig | None = None) -&gt; None:\n    \"\"\"Initialize the token counter.\n\n    Args:\n        config: Optional tokenizer configuration.\n    \"\"\"\n    from pydantic_agent.tokens.config import TokenizerConfig\n\n    self._config = config or TokenizerConfig()\n    self._encoding_name = self._config.encoding\n\n    if self._config.cache_tokenizer:\n        self._encoding = _get_encoding(self._encoding_name)\n    else:\n        self._encoding = tiktoken.get_encoding(self._encoding_name)\n</code></pre>"},{"location":"api/tokens/counter/#pydantic_agent.tokens.counter.TokenCounter.count","title":"count","text":"<pre><code>count(text: str) -&gt; int\n</code></pre> <p>Count tokens in text.</p> PARAMETER DESCRIPTION <code>text</code> <p>The text to count tokens in.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>int</code> <p>Approximate token count.</p> Source code in <code>src/pydantic_agent/tokens/counter.py</code> <pre><code>def count(self, text: str) -&gt; int:\n    \"\"\"Count tokens in text.\n\n    Args:\n        text: The text to count tokens in.\n\n    Returns:\n        Approximate token count.\n    \"\"\"\n    return len(self._encoding.encode(text))\n</code></pre>"},{"location":"api/tokens/counter/#pydantic_agent.tokens.counter.TokenCounter.count_messages","title":"count_messages","text":"<pre><code>count_messages(messages: list[dict[str, Any]]) -&gt; int\n</code></pre> <p>Count tokens in a message list.</p> <p>Estimates tokens for a list of chat messages, accounting for message structure overhead.</p> PARAMETER DESCRIPTION <code>messages</code> <p>List of message dictionaries with 'role' and 'content'.</p> <p> TYPE: <code>list[dict[str, Any]]</code> </p> RETURNS DESCRIPTION <code>int</code> <p>Approximate total token count.</p> Source code in <code>src/pydantic_agent/tokens/counter.py</code> <pre><code>def count_messages(self, messages: list[dict[str, Any]]) -&gt; int:\n    \"\"\"Count tokens in a message list.\n\n    Estimates tokens for a list of chat messages, accounting for\n    message structure overhead.\n\n    Args:\n        messages: List of message dictionaries with 'role' and 'content'.\n\n    Returns:\n        Approximate total token count.\n    \"\"\"\n    total = 0\n\n    for message in messages:\n        # Add overhead per message (role, separators)\n        total += 4  # Approximate overhead per message\n\n        # Count content tokens\n        content = message.get(\"content\", \"\")\n        if content:\n            total += self.count(content)\n\n        # Count role tokens\n        role = message.get(\"role\", \"\")\n        if role:\n            total += self.count(role)\n\n        # Count tool call tokens if present\n        tool_calls = message.get(\"tool_calls\", [])\n        for tool_call in tool_calls:\n            if isinstance(tool_call, dict):\n                func = tool_call.get(\"function\", {})\n                name = func.get(\"name\", \"\")\n                args = func.get(\"arguments\", \"\")\n                total += self.count(name) + self.count(args) + 10  # Overhead\n\n    # Add final overhead\n    total += 3\n\n    return total\n</code></pre>"},{"location":"api/tokens/counter/#pydantic_agent.tokens.counter.TokenCounter.count_with_margin","title":"count_with_margin","text":"<pre><code>count_with_margin(text: str) -&gt; int\n</code></pre> <p>Count tokens with safety margin.</p> PARAMETER DESCRIPTION <code>text</code> <p>The text to count.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>int</code> <p>Token count plus safety margin.</p> Source code in <code>src/pydantic_agent/tokens/counter.py</code> <pre><code>def count_with_margin(self, text: str) -&gt; int:\n    \"\"\"Count tokens with safety margin.\n\n    Args:\n        text: The text to count.\n\n    Returns:\n        Token count plus safety margin.\n    \"\"\"\n    base_count = self.count(text)\n    margin = int(base_count * self._config.safety_margin)\n    return base_count + margin\n</code></pre>"},{"location":"api/tokens/counter/#pydantic_agent.tokens.counter.TokenCounter.fits_context","title":"fits_context","text":"<pre><code>fits_context(text: str, max_tokens: int) -&gt; bool\n</code></pre> <p>Check if text fits within a context window.</p> PARAMETER DESCRIPTION <code>text</code> <p>The text to check.</p> <p> TYPE: <code>str</code> </p> <code>max_tokens</code> <p>Maximum token count.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if text fits (with safety margin).</p> Source code in <code>src/pydantic_agent/tokens/counter.py</code> <pre><code>def fits_context(self, text: str, max_tokens: int) -&gt; bool:\n    \"\"\"Check if text fits within a context window.\n\n    Args:\n        text: The text to check.\n        max_tokens: Maximum token count.\n\n    Returns:\n        True if text fits (with safety margin).\n    \"\"\"\n    return self.count_with_margin(text) &lt;= max_tokens\n</code></pre>"},{"location":"api/tokens/counter/#pydantic_agent.tokens.counter.TokenCounter.get_encoding_for_model","title":"get_encoding_for_model","text":"<pre><code>get_encoding_for_model(model: str) -&gt; str\n</code></pre> <p>Get the appropriate encoding for a model.</p> PARAMETER DESCRIPTION <code>model</code> <p>Model name or identifier.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Encoding name to use.</p> Source code in <code>src/pydantic_agent/tokens/counter.py</code> <pre><code>def get_encoding_for_model(self, model: str) -&gt; str:\n    \"\"\"Get the appropriate encoding for a model.\n\n    Args:\n        model: Model name or identifier.\n\n    Returns:\n        Encoding name to use.\n    \"\"\"\n    # Check model mapping\n    for prefix, encoding in self._config.model_mapping.items():\n        if prefix.lower() in model.lower():\n            return encoding\n\n    # Default encoding\n    return self._config.encoding\n</code></pre>"},{"location":"api/tokens/tracker/","title":"UsageTracker","text":"<p>Track token usage across requests.</p>"},{"location":"api/tokens/tracker/#quick-example","title":"Quick Example","text":"<pre><code>from pydantic_agent.tokens import UsageTracker\n\ntracker = UsageTracker()\n\n# Record usage\ntracker.record_usage(\n    prompt_tokens=100,\n    completion_tokens=50,\n    model=\"gpt-4o\",\n)\n\n# Get aggregate\nusage = tracker.get_total_usage()\nprint(f\"Total: {usage.total_tokens}\")\n\n# Get history\nfor record in tracker.get_usage_history():\n    print(f\"{record.timestamp}: {record.total_tokens}\")\n\n# Reset\ntracker.reset()\n</code></pre>"},{"location":"api/tokens/tracker/#data-classes","title":"Data Classes","text":""},{"location":"api/tokens/tracker/#tokenusage","title":"TokenUsage","text":"<p>Aggregate usage statistics.</p>"},{"location":"api/tokens/tracker/#usagerecord","title":"UsageRecord","text":"<p>Single usage record.</p>"},{"location":"api/tokens/tracker/#api-reference","title":"API Reference","text":""},{"location":"api/tokens/tracker/#pydantic_agent.tokens.tracker.UsageTracker","title":"UsageTracker","text":"<pre><code>UsageTracker(cost_rates: dict[str, float] | None = None)\n</code></pre> <p>Track token usage across requests.</p> <p>Provides per-request tracking, session aggregates, and cost estimation.</p> <p>Initialize the usage tracker.</p> PARAMETER DESCRIPTION <code>cost_rates</code> <p>Optional cost per 1000 tokens for different models.</p> <p> TYPE: <code>dict[str, float] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/pydantic_agent/tokens/tracker.py</code> <pre><code>def __init__(\n    self,\n    cost_rates: dict[str, float] | None = None,\n) -&gt; None:\n    \"\"\"Initialize the usage tracker.\n\n    Args:\n        cost_rates: Optional cost per 1000 tokens for different models.\n    \"\"\"\n    self._records: list[UsageRecord] = []\n    self._totals = TokenUsage()\n    self._cost_rates = cost_rates or {}\n</code></pre>"},{"location":"api/tokens/tracker/#pydantic_agent.tokens.tracker.UsageTracker.record_usage","title":"record_usage","text":"<pre><code>record_usage(\n    usage: Usage,\n    model: str | None = None,\n    tool_name: str | None = None,\n) -&gt; None\n</code></pre> <p>Record usage from a pydantic-ai result.</p> PARAMETER DESCRIPTION <code>usage</code> <p>Usage object from pydantic-ai.</p> <p> TYPE: <code>Usage</code> </p> <code>model</code> <p>Optional model name.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>tool_name</code> <p>Optional tool name for tool calls.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/pydantic_agent/tokens/tracker.py</code> <pre><code>def record_usage(\n    self,\n    usage: Usage,\n    model: str | None = None,\n    tool_name: str | None = None,\n) -&gt; None:\n    \"\"\"Record usage from a pydantic-ai result.\n\n    Args:\n        usage: Usage object from pydantic-ai.\n        model: Optional model name.\n        tool_name: Optional tool name for tool calls.\n    \"\"\"\n    # Extract token counts from pydantic-ai Usage\n    # Use new API (input_tokens/output_tokens) with fallback to deprecated names\n    prompt_tokens = (\n        getattr(usage, \"input_tokens\", None) or getattr(usage, \"request_tokens\", None) or 0\n    )\n    completion_tokens = (\n        getattr(usage, \"output_tokens\", None) or getattr(usage, \"response_tokens\", None) or 0\n    )\n    total_tokens = usage.total_tokens or (prompt_tokens + completion_tokens)\n\n    record = UsageRecord(\n        timestamp=datetime.now(),\n        prompt_tokens=prompt_tokens,\n        completion_tokens=completion_tokens,\n        total_tokens=total_tokens,\n        model=model,\n        tool_name=tool_name,\n    )\n\n    self._records.append(record)\n\n    # Update totals\n    self._totals.prompt_tokens += prompt_tokens\n    self._totals.completion_tokens += completion_tokens\n    self._totals.total_tokens += total_tokens\n    self._totals.request_count += 1\n</code></pre>"},{"location":"api/tokens/tracker/#pydantic_agent.tokens.tracker.UsageTracker.record_raw","title":"record_raw","text":"<pre><code>record_raw(\n    prompt_tokens: int,\n    completion_tokens: int,\n    model: str | None = None,\n    tool_name: str | None = None,\n) -&gt; None\n</code></pre> <p>Record raw token counts.</p> PARAMETER DESCRIPTION <code>prompt_tokens</code> <p>Number of prompt tokens.</p> <p> TYPE: <code>int</code> </p> <code>completion_tokens</code> <p>Number of completion tokens.</p> <p> TYPE: <code>int</code> </p> <code>model</code> <p>Optional model name.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>tool_name</code> <p>Optional tool name.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/pydantic_agent/tokens/tracker.py</code> <pre><code>def record_raw(\n    self,\n    prompt_tokens: int,\n    completion_tokens: int,\n    model: str | None = None,\n    tool_name: str | None = None,\n) -&gt; None:\n    \"\"\"Record raw token counts.\n\n    Args:\n        prompt_tokens: Number of prompt tokens.\n        completion_tokens: Number of completion tokens.\n        model: Optional model name.\n        tool_name: Optional tool name.\n    \"\"\"\n    total = prompt_tokens + completion_tokens\n\n    record = UsageRecord(\n        timestamp=datetime.now(),\n        prompt_tokens=prompt_tokens,\n        completion_tokens=completion_tokens,\n        total_tokens=total,\n        model=model,\n        tool_name=tool_name,\n    )\n\n    self._records.append(record)\n\n    self._totals.prompt_tokens += prompt_tokens\n    self._totals.completion_tokens += completion_tokens\n    self._totals.total_tokens += total\n    self._totals.request_count += 1\n</code></pre>"},{"location":"api/tokens/tracker/#pydantic_agent.tokens.tracker.UsageTracker.get_total_usage","title":"get_total_usage","text":"<pre><code>get_total_usage() -&gt; TokenUsage\n</code></pre> <p>Get total usage statistics.</p> RETURNS DESCRIPTION <code>TokenUsage</code> <p>TokenUsage with aggregate statistics.</p> Source code in <code>src/pydantic_agent/tokens/tracker.py</code> <pre><code>def get_total_usage(self) -&gt; TokenUsage:\n    \"\"\"Get total usage statistics.\n\n    Returns:\n        TokenUsage with aggregate statistics.\n    \"\"\"\n    return self._totals\n</code></pre>"},{"location":"api/tokens/tracker/#pydantic_agent.tokens.tracker.UsageTracker.get_usage_history","title":"get_usage_history","text":"<pre><code>get_usage_history() -&gt; list[UsageRecord]\n</code></pre> <p>Get usage history.</p> RETURNS DESCRIPTION <code>list[UsageRecord]</code> <p>List of all usage records.</p> Source code in <code>src/pydantic_agent/tokens/tracker.py</code> <pre><code>def get_usage_history(self) -&gt; list[UsageRecord]:\n    \"\"\"Get usage history.\n\n    Returns:\n        List of all usage records.\n    \"\"\"\n    return self._records.copy()\n</code></pre>"},{"location":"api/tokens/tracker/#pydantic_agent.tokens.tracker.UsageTracker.get_cost_estimate","title":"get_cost_estimate","text":"<pre><code>get_cost_estimate(model: str | None = None) -&gt; float\n</code></pre> <p>Estimate cost based on usage.</p> PARAMETER DESCRIPTION <code>model</code> <p>Model to use for cost calculation.    If None, uses default rate.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>float</code> <p>Estimated cost in USD.</p> Source code in <code>src/pydantic_agent/tokens/tracker.py</code> <pre><code>def get_cost_estimate(self, model: str | None = None) -&gt; float:\n    \"\"\"Estimate cost based on usage.\n\n    Args:\n        model: Model to use for cost calculation.\n               If None, uses default rate.\n\n    Returns:\n        Estimated cost in USD.\n    \"\"\"\n    # Get rate per 1000 tokens\n    rate = 0.0\n    if model and model in self._cost_rates:\n        rate = self._cost_rates[model]\n    elif \"default\" in self._cost_rates:\n        rate = self._cost_rates[\"default\"]\n\n    # Calculate cost\n    return (self._totals.total_tokens / 1000) * rate\n</code></pre>"},{"location":"api/tokens/tracker/#pydantic_agent.tokens.tracker.UsageTracker.get_breakdown_by_tool","title":"get_breakdown_by_tool","text":"<pre><code>get_breakdown_by_tool() -&gt; dict[str, TokenUsage]\n</code></pre> <p>Get token usage broken down by tool.</p> RETURNS DESCRIPTION <code>dict[str, TokenUsage]</code> <p>Dictionary mapping tool names to usage.</p> Source code in <code>src/pydantic_agent/tokens/tracker.py</code> <pre><code>def get_breakdown_by_tool(self) -&gt; dict[str, TokenUsage]:\n    \"\"\"Get token usage broken down by tool.\n\n    Returns:\n        Dictionary mapping tool names to usage.\n    \"\"\"\n    breakdown: dict[str, TokenUsage] = {}\n\n    for record in self._records:\n        key = record.tool_name or \"_agent\"\n\n        if key not in breakdown:\n            breakdown[key] = TokenUsage()\n\n        breakdown[key].prompt_tokens += record.prompt_tokens\n        breakdown[key].completion_tokens += record.completion_tokens\n        breakdown[key].total_tokens += record.total_tokens\n        breakdown[key].request_count += 1\n\n    return breakdown\n</code></pre>"},{"location":"api/tokens/tracker/#pydantic_agent.tokens.tracker.UsageTracker.reset","title":"reset","text":"<pre><code>reset() -&gt; None\n</code></pre> <p>Reset all tracking data.</p> Source code in <code>src/pydantic_agent/tokens/tracker.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Reset all tracking data.\"\"\"\n    self._records.clear()\n    self._totals = TokenUsage()\n</code></pre>"},{"location":"api/tokens/tracker/#pydantic_agent.tokens.tracker.TokenUsage","title":"TokenUsage  <code>dataclass</code>","text":"<pre><code>TokenUsage(\n    prompt_tokens: int = 0,\n    completion_tokens: int = 0,\n    total_tokens: int = 0,\n    request_count: int = 0,\n    cached_tokens: int = 0,\n)\n</code></pre> <p>Aggregate token usage statistics.</p> ATTRIBUTE DESCRIPTION <code>prompt_tokens</code> <p>Total prompt tokens.</p> <p> TYPE: <code>int</code> </p> <code>completion_tokens</code> <p>Total completion tokens.</p> <p> TYPE: <code>int</code> </p> <code>total_tokens</code> <p>Total tokens.</p> <p> TYPE: <code>int</code> </p> <code>request_count</code> <p>Number of requests.</p> <p> TYPE: <code>int</code> </p> <code>cached_tokens</code> <p>Tokens served from cache.</p> <p> TYPE: <code>int</code> </p>"},{"location":"api/tokens/tracker/#pydantic_agent.tokens.tracker.UsageRecord","title":"UsageRecord  <code>dataclass</code>","text":"<pre><code>UsageRecord(\n    timestamp: datetime,\n    prompt_tokens: int,\n    completion_tokens: int,\n    total_tokens: int,\n    model: str | None = None,\n    tool_name: str | None = None,\n)\n</code></pre> <p>A single usage record.</p> ATTRIBUTE DESCRIPTION <code>timestamp</code> <p>When the usage was recorded.</p> <p> TYPE: <code>datetime</code> </p> <code>prompt_tokens</code> <p>Tokens in the prompt.</p> <p> TYPE: <code>int</code> </p> <code>completion_tokens</code> <p>Tokens in the completion.</p> <p> TYPE: <code>int</code> </p> <code>total_tokens</code> <p>Total tokens used.</p> <p> TYPE: <code>int</code> </p> <code>model</code> <p>Model used for this request.</p> <p> TYPE: <code>str | None</code> </p> <code>tool_name</code> <p>Optional tool name if tool call.</p> <p> TYPE: <code>str | None</code> </p>"},{"location":"api/tools/","title":"Tools Module","text":"<p>Built-in tools for agent use.</p>"},{"location":"api/tools/#available-tools","title":"Available Tools","text":"Tool Description Filesystem File operations Bash Shell commands Glob Pattern matching Grep Content search ToolRegistry Tool management"},{"location":"api/tools/#quick-example","title":"Quick Example","text":"<pre><code>from pydantic_agent import Agent\nfrom pydantic_agent.tools import (\n    read_file,\n    write_file,\n    list_directory,\n    glob_search,\n    grep_search,\n    run_bash,\n)\n\nagent = Agent(\n    \"gpt-4o\",\n    tools=[read_file, write_file, glob_search, grep_search, run_bash],\n)\n</code></pre>"},{"location":"api/tools/#tool-categories","title":"Tool Categories","text":""},{"location":"api/tools/#file-operations","title":"File Operations","text":"<ul> <li><code>read_file</code> - Read file contents</li> <li><code>write_file</code> - Write to file</li> <li><code>append_file</code> - Append to file</li> <li><code>list_directory</code> - List directory</li> <li><code>file_info</code> - Get file metadata</li> <li><code>delete_file</code> - Delete file</li> <li><code>move_file</code> - Move/rename file</li> <li><code>copy_file</code> - Copy file</li> </ul>"},{"location":"api/tools/#search","title":"Search","text":"<ul> <li><code>glob_search</code> - Find files by pattern</li> <li><code>grep_search</code> - Search file contents</li> </ul>"},{"location":"api/tools/#shell","title":"Shell","text":"<ul> <li><code>run_bash</code> - Execute commands</li> </ul>"},{"location":"api/tools/bash/","title":"Bash Tool","text":"<p>Execute shell commands.</p>"},{"location":"api/tools/bash/#quick-example","title":"Quick Example","text":"<pre><code>from pydantic_agent.tools import run_bash\n\n# Run a command\nresult = run_bash(\"ls -la\")\nprint(result.stdout)\n\n# With timeout\nresult = run_bash(\"long_command\", timeout=60)\n\n# Check result\nif result.return_code == 0:\n    print(\"Success!\")\nelse:\n    print(f\"Error: {result.stderr}\")\n\nif result.timed_out:\n    print(\"Command timed out\")\n</code></pre>"},{"location":"api/tools/bash/#bashresult","title":"BashResult","text":"Field Type Description <code>stdout</code> str Standard output <code>stderr</code> str Standard error <code>return_code</code> int Exit code <code>timed_out</code> bool Did it timeout?"},{"location":"api/tools/bash/#api-reference","title":"API Reference","text":""},{"location":"api/tools/bash/#pydantic_agent.tools.bash.run_bash","title":"run_bash","text":"<pre><code>run_bash(\n    command: str,\n    working_dir: str = \".\",\n    timeout: int = 30,\n    env: dict[str, str] | None = None,\n) -&gt; BashResult\n</code></pre> <p>Execute a shell command.</p> PARAMETER DESCRIPTION <code>command</code> <p>The shell command to execute.</p> <p> TYPE: <code>str</code> </p> <code>working_dir</code> <p>Working directory for the command.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'.'</code> </p> <code>timeout</code> <p>Timeout in seconds (default: 30).</p> <p> TYPE: <code>int</code> DEFAULT: <code>30</code> </p> <code>env</code> <p>Optional environment variables to add.</p> <p> TYPE: <code>dict[str, str] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>BashResult</code> <p>BashResult with stdout, stderr, and return code.</p> RAISES DESCRIPTION <code>TimeoutError</code> <p>If the command times out.</p> Source code in <code>src/pydantic_agent/tools/bash.py</code> <pre><code>def run_bash(\n    command: str,\n    working_dir: str = \".\",\n    timeout: int = 30,\n    env: dict[str, str] | None = None,\n) -&gt; BashResult:\n    \"\"\"Execute a shell command.\n\n    Args:\n        command: The shell command to execute.\n        working_dir: Working directory for the command.\n        timeout: Timeout in seconds (default: 30).\n        env: Optional environment variables to add.\n\n    Returns:\n        BashResult with stdout, stderr, and return code.\n\n    Raises:\n        TimeoutError: If the command times out.\n    \"\"\"\n    import os\n\n    # Merge environment\n    full_env = os.environ.copy()\n    if env:\n        full_env.update(env)\n\n    try:\n        result = subprocess.run(\n            command,\n            shell=True,\n            cwd=working_dir,\n            env=full_env,\n            capture_output=True,\n            text=True,\n            timeout=timeout,\n        )\n        return BashResult(\n            stdout=result.stdout,\n            stderr=result.stderr,\n            return_code=result.returncode,\n        )\n    except subprocess.TimeoutExpired as e:\n        return BashResult(\n            stdout=e.stdout or \"\" if isinstance(e.stdout, str) else (e.stdout or b\"\").decode(),\n            stderr=e.stderr or \"\" if isinstance(e.stderr, str) else (e.stderr or b\"\").decode(),\n            return_code=-1,\n            timed_out=True,\n        )\n</code></pre>"},{"location":"api/tools/bash/#pydantic_agent.tools.bash.BashResult","title":"BashResult  <code>dataclass</code>","text":"<pre><code>BashResult(\n    stdout: str,\n    stderr: str,\n    return_code: int,\n    timed_out: bool = False,\n)\n</code></pre> <p>Result of a bash command execution.</p> ATTRIBUTE DESCRIPTION <code>stdout</code> <p>Standard output from the command.</p> <p> TYPE: <code>str</code> </p> <code>stderr</code> <p>Standard error from the command.</p> <p> TYPE: <code>str</code> </p> <code>return_code</code> <p>Exit code of the command.</p> <p> TYPE: <code>int</code> </p> <code>timed_out</code> <p>Whether the command timed out.</p> <p> TYPE: <code>bool</code> </p>"},{"location":"api/tools/filesystem/","title":"Filesystem Tools","text":"<p>File operations tools.</p>"},{"location":"api/tools/filesystem/#available-functions","title":"Available Functions","text":"Function Description <code>read_file</code> Read file contents <code>write_file</code> Write/overwrite file <code>append_file</code> Append to file <code>list_directory</code> List directory contents <code>file_info</code> Get file metadata <code>delete_file</code> Delete file <code>move_file</code> Move/rename file <code>copy_file</code> Copy file"},{"location":"api/tools/filesystem/#quick-example","title":"Quick Example","text":"<pre><code>from pydantic_agent.tools import (\n    read_file,\n    write_file,\n    list_directory,\n    file_info,\n)\n\n# Read file\ncontent = read_file(\"config.json\")\n\n# Write file\nwrite_file(\"output.txt\", \"Hello!\")\n\n# List directory\nentries = list_directory(\"/project\", recursive=True)\n\n# Get file info\ninfo = file_info(\"README.md\")\nprint(f\"Size: {info.size}\")\n</code></pre>"},{"location":"api/tools/filesystem/#security","title":"Security","text":"<pre><code>from pydantic_agent.tools.filesystem import FilesystemSecurity\n\nsecurity = FilesystemSecurity(\n    sandbox_mode=True,\n    base_directory=\"/safe/path\",\n    allowed_extensions=[\".txt\", \".json\"],\n)\n\n# Use with tools\ncontent = read_file(\"data.txt\", security=security)\n</code></pre>"},{"location":"api/tools/filesystem/#api-reference","title":"API Reference","text":""},{"location":"api/tools/filesystem/#pydantic_agent.tools.filesystem.read.read_file","title":"read_file","text":"<pre><code>read_file(\n    path: str,\n    encoding: str = \"utf-8\",\n    security: FilesystemSecurity | None = None,\n) -&gt; str\n</code></pre> <p>Read contents of a file.</p> PARAMETER DESCRIPTION <code>path</code> <p>Path to the file to read.</p> <p> TYPE: <code>str</code> </p> <code>encoding</code> <p>Character encoding (default: utf-8).</p> <p> TYPE: <code>str</code> DEFAULT: <code>'utf-8'</code> </p> <code>security</code> <p>Optional security context for path validation.</p> <p> TYPE: <code>FilesystemSecurity | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The file contents as a string.</p> RAISES DESCRIPTION <code>FileNotFoundError</code> <p>If the file does not exist.</p> <code>PermissionError</code> <p>If access is denied or path is outside sandbox.</p> Source code in <code>src/pydantic_agent/tools/filesystem/read.py</code> <pre><code>def read_file(\n    path: str,\n    encoding: str = \"utf-8\",\n    security: FilesystemSecurity | None = None,\n) -&gt; str:\n    \"\"\"Read contents of a file.\n\n    Args:\n        path: Path to the file to read.\n        encoding: Character encoding (default: utf-8).\n        security: Optional security context for path validation.\n\n    Returns:\n        The file contents as a string.\n\n    Raises:\n        FileNotFoundError: If the file does not exist.\n        PermissionError: If access is denied or path is outside sandbox.\n    \"\"\"\n    if security is not None:\n        validated_path = security.validate_path(path)\n        security.validate_read(validated_path)\n    else:\n        validated_path = Path(path)\n        if not validated_path.exists():\n            raise FileNotFoundError(f\"File not found: {path}\")\n\n    return validated_path.read_text(encoding=encoding)\n</code></pre>"},{"location":"api/tools/filesystem/#pydantic_agent.tools.filesystem.write.write_file","title":"write_file","text":"<pre><code>write_file(\n    path: str,\n    content: str,\n    encoding: str = \"utf-8\",\n    create_parents: bool = False,\n    security: FilesystemSecurity | None = None,\n) -&gt; str\n</code></pre> <p>Write or overwrite a file.</p> PARAMETER DESCRIPTION <code>path</code> <p>Path to the file to write.</p> <p> TYPE: <code>str</code> </p> <code>content</code> <p>Content to write to the file.</p> <p> TYPE: <code>str</code> </p> <code>encoding</code> <p>Character encoding (default: utf-8).</p> <p> TYPE: <code>str</code> DEFAULT: <code>'utf-8'</code> </p> <code>create_parents</code> <p>Create parent directories if they don't exist.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>security</code> <p>Optional security context for path validation.</p> <p> TYPE: <code>FilesystemSecurity | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The path of the written file.</p> RAISES DESCRIPTION <code>PermissionError</code> <p>If access is denied or path is outside sandbox.</p> <code>FileNotFoundError</code> <p>If parent directory doesn't exist and create_parents is False.</p> Source code in <code>src/pydantic_agent/tools/filesystem/write.py</code> <pre><code>def write_file(\n    path: str,\n    content: str,\n    encoding: str = \"utf-8\",\n    create_parents: bool = False,\n    security: FilesystemSecurity | None = None,\n) -&gt; str:\n    \"\"\"Write or overwrite a file.\n\n    Args:\n        path: Path to the file to write.\n        content: Content to write to the file.\n        encoding: Character encoding (default: utf-8).\n        create_parents: Create parent directories if they don't exist.\n        security: Optional security context for path validation.\n\n    Returns:\n        The path of the written file.\n\n    Raises:\n        PermissionError: If access is denied or path is outside sandbox.\n        FileNotFoundError: If parent directory doesn't exist and create_parents is False.\n    \"\"\"\n    if security is not None:\n        validated_path = security.validate_path(path)\n    else:\n        validated_path = Path(path)\n\n    if create_parents:\n        validated_path.parent.mkdir(parents=True, exist_ok=True)\n\n    validated_path.write_text(content, encoding=encoding)\n    return str(validated_path)\n</code></pre>"},{"location":"api/tools/filesystem/#pydantic_agent.tools.filesystem.directory.list_directory","title":"list_directory","text":"<pre><code>list_directory(\n    path: str,\n    recursive: bool = False,\n    max_depth: int = 2,\n    security: FilesystemSecurity | None = None,\n) -&gt; list[dict[str, Any]]\n</code></pre> <p>List contents of a directory.</p> PARAMETER DESCRIPTION <code>path</code> <p>Path to the directory to list.</p> <p> TYPE: <code>str</code> </p> <code>recursive</code> <p>Whether to list recursively.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>max_depth</code> <p>Maximum depth for recursive listing.</p> <p> TYPE: <code>int</code> DEFAULT: <code>2</code> </p> <code>security</code> <p>Optional security context for path validation.</p> <p> TYPE: <code>FilesystemSecurity | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>list[dict[str, Any]]</code> <p>List of dictionaries with file/directory information.</p> RAISES DESCRIPTION <code>FileNotFoundError</code> <p>If the directory does not exist.</p> <code>NotADirectoryError</code> <p>If the path is not a directory.</p> <code>PermissionError</code> <p>If access is denied or path is outside sandbox.</p> Source code in <code>src/pydantic_agent/tools/filesystem/directory.py</code> <pre><code>def list_directory(\n    path: str,\n    recursive: bool = False,\n    max_depth: int = 2,\n    security: FilesystemSecurity | None = None,\n) -&gt; list[dict[str, Any]]:\n    \"\"\"List contents of a directory.\n\n    Args:\n        path: Path to the directory to list.\n        recursive: Whether to list recursively.\n        max_depth: Maximum depth for recursive listing.\n        security: Optional security context for path validation.\n\n    Returns:\n        List of dictionaries with file/directory information.\n\n    Raises:\n        FileNotFoundError: If the directory does not exist.\n        NotADirectoryError: If the path is not a directory.\n        PermissionError: If access is denied or path is outside sandbox.\n    \"\"\"\n    if security is not None:\n        validated_path = security.validate_path(path)\n    else:\n        validated_path = Path(path)\n\n    if not validated_path.exists():\n        raise FileNotFoundError(f\"Directory not found: {path}\")\n\n    if not validated_path.is_dir():\n        raise NotADirectoryError(f\"Not a directory: {path}\")\n\n    entries: list[dict[str, Any]] = []\n\n    def process_entry(entry_path: Path, current_depth: int) -&gt; None:\n        \"\"\"Process a single directory entry.\"\"\"\n        if current_depth &gt; max_depth:\n            return\n\n        try:\n            stat = entry_path.stat()\n            entry_info = {\n                \"name\": entry_path.name,\n                \"path\": str(entry_path),\n                \"is_file\": entry_path.is_file(),\n                \"is_dir\": entry_path.is_dir(),\n                \"size\": stat.st_size if entry_path.is_file() else None,\n                \"modified\": datetime.fromtimestamp(stat.st_mtime).isoformat(),\n            }\n            entries.append(entry_info)\n\n            # Recurse into directories if requested\n            if recursive and entry_path.is_dir():\n                for child in entry_path.iterdir():\n                    process_entry(child, current_depth + 1)\n\n        except PermissionError:\n            # Skip entries we can't access\n            entries.append(\n                {\n                    \"name\": entry_path.name,\n                    \"path\": str(entry_path),\n                    \"error\": \"Permission denied\",\n                }\n            )\n\n    for entry in validated_path.iterdir():\n        process_entry(entry, 1)\n\n    return entries\n</code></pre>"},{"location":"api/tools/filesystem/#pydantic_agent.tools.filesystem.info.file_info","title":"file_info","text":"<pre><code>file_info(\n    path: str, security: FilesystemSecurity | None = None\n) -&gt; dict[str, Any]\n</code></pre> <p>Get file or directory metadata.</p> PARAMETER DESCRIPTION <code>path</code> <p>Path to the file or directory.</p> <p> TYPE: <code>str</code> </p> <code>security</code> <p>Optional security context for path validation.</p> <p> TYPE: <code>FilesystemSecurity | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>dict[str, Any]</code> <p>Dictionary with file metadata including:</p> <code>dict[str, Any]</code> <ul> <li>name: The file name</li> </ul> <code>dict[str, Any]</code> <ul> <li>path: Full path</li> </ul> <code>dict[str, Any]</code> <ul> <li>is_file: Whether it's a file</li> </ul> <code>dict[str, Any]</code> <ul> <li>is_dir: Whether it's a directory</li> </ul> <code>dict[str, Any]</code> <ul> <li>size: Size in bytes (files only)</li> </ul> <code>dict[str, Any]</code> <ul> <li>modified: Modification time (ISO format)</li> </ul> <code>dict[str, Any]</code> <ul> <li>created: Creation time (ISO format)</li> </ul> RAISES DESCRIPTION <code>FileNotFoundError</code> <p>If the file does not exist.</p> <code>PermissionError</code> <p>If access is denied or path is outside sandbox.</p> Source code in <code>src/pydantic_agent/tools/filesystem/info.py</code> <pre><code>def file_info(\n    path: str,\n    security: FilesystemSecurity | None = None,\n) -&gt; dict[str, Any]:\n    \"\"\"Get file or directory metadata.\n\n    Args:\n        path: Path to the file or directory.\n        security: Optional security context for path validation.\n\n    Returns:\n        Dictionary with file metadata including:\n        - name: The file name\n        - path: Full path\n        - is_file: Whether it's a file\n        - is_dir: Whether it's a directory\n        - size: Size in bytes (files only)\n        - modified: Modification time (ISO format)\n        - created: Creation time (ISO format)\n\n    Raises:\n        FileNotFoundError: If the file does not exist.\n        PermissionError: If access is denied or path is outside sandbox.\n    \"\"\"\n    if security is not None:\n        validated_path = security.validate_path(path)\n    else:\n        validated_path = Path(path)\n\n    if not validated_path.exists():\n        raise FileNotFoundError(f\"File not found: {path}\")\n\n    stat = validated_path.stat()\n\n    return {\n        \"name\": validated_path.name,\n        \"path\": str(validated_path),\n        \"is_file\": validated_path.is_file(),\n        \"is_dir\": validated_path.is_dir(),\n        \"size\": stat.st_size,\n        \"modified\": datetime.fromtimestamp(stat.st_mtime).isoformat(),\n        \"created\": datetime.fromtimestamp(stat.st_ctime).isoformat(),\n    }\n</code></pre>"},{"location":"api/tools/glob/","title":"Glob Tool","text":"<p>Find files by pattern.</p>"},{"location":"api/tools/glob/#quick-example","title":"Quick Example","text":"<pre><code>from pydantic_agent.tools import glob_search\n\n# Find Python files\nfiles = glob_search(\"**/*.py\")\n\n# In specific directory\nfiles = glob_search(\"*.json\", root_dir=\"/config\")\n\n# Multiple patterns\nfiles = glob_search(\"**/*.{py,js,ts}\")\n</code></pre>"},{"location":"api/tools/glob/#pattern-syntax","title":"Pattern Syntax","text":"Pattern Matches <code>*</code> Any characters in filename <code>**</code> Any directories <code>?</code> Single character <code>[abc]</code> Character set <code>{a,b}</code> Alternatives"},{"location":"api/tools/glob/#api-reference","title":"API Reference","text":""},{"location":"api/tools/glob/#pydantic_agent.tools.glob.glob_search","title":"glob_search","text":"<pre><code>glob_search(\n    pattern: str,\n    root_dir: str = \".\",\n    recursive: bool = True,\n    max_results: int = 1000,\n    security: FilesystemSecurity | None = None,\n) -&gt; list[str]\n</code></pre> <p>Find files matching a glob pattern.</p> PARAMETER DESCRIPTION <code>pattern</code> <p>Glob pattern to match (e.g., \".py\", \"/.txt\").</p> <p> TYPE: <code>str</code> </p> <code>root_dir</code> <p>Root directory to search from.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'.'</code> </p> <code>recursive</code> <p>Whether to search recursively (default: True).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>max_results</code> <p>Maximum number of results to return.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1000</code> </p> <code>security</code> <p>Optional security context for path validation.</p> <p> TYPE: <code>FilesystemSecurity | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>list[str]</code> <p>List of matching file paths.</p> RAISES DESCRIPTION <code>PermissionError</code> <p>If access is denied or path is outside sandbox.</p> Source code in <code>src/pydantic_agent/tools/glob.py</code> <pre><code>def glob_search(\n    pattern: str,\n    root_dir: str = \".\",\n    recursive: bool = True,\n    max_results: int = 1000,\n    security: FilesystemSecurity | None = None,\n) -&gt; list[str]:\n    \"\"\"Find files matching a glob pattern.\n\n    Args:\n        pattern: Glob pattern to match (e.g., \"*.py\", \"**/*.txt\").\n        root_dir: Root directory to search from.\n        recursive: Whether to search recursively (default: True).\n        max_results: Maximum number of results to return.\n        security: Optional security context for path validation.\n\n    Returns:\n        List of matching file paths.\n\n    Raises:\n        PermissionError: If access is denied or path is outside sandbox.\n    \"\"\"\n    if security is not None:\n        root = security.validate_path(root_dir)\n    else:\n        root = Path(root_dir)\n\n    if not root.exists():\n        raise FileNotFoundError(f\"Directory not found: {root_dir}\")\n\n    if not root.is_dir():\n        raise NotADirectoryError(f\"Not a directory: {root_dir}\")\n\n    # Use rglob for recursive, glob for non-recursive\n    if recursive:\n        matches = root.rglob(pattern)\n    else:\n        matches = root.glob(pattern)\n\n    results: list[str] = []\n    for match in matches:\n        if len(results) &gt;= max_results:\n            break\n        results.append(str(match))\n\n    return results\n</code></pre>"},{"location":"api/tools/grep/","title":"Grep Tool","text":"<p>Search file contents with regex.</p>"},{"location":"api/tools/grep/#quick-example","title":"Quick Example","text":"<pre><code>from pydantic_agent.tools import grep_search\n\n# Search for pattern\nmatches = grep_search(\n    pattern=r\"def \\w+\\(\",\n    path=\"/project\",\n)\n\n# With file filter\nmatches = grep_search(\n    pattern=\"TODO\",\n    path=\"/src\",\n    file_pattern=\"*.py\",\n)\n\n# With context lines\nmatches = grep_search(\n    pattern=\"error\",\n    path=\"/logs\",\n    context_lines=2,\n)\n\n# Process results\nfor match in matches:\n    print(f\"{match.file}:{match.line}: {match.content}\")\n</code></pre>"},{"location":"api/tools/grep/#api-reference","title":"API Reference","text":""},{"location":"api/tools/grep/#pydantic_agent.tools.grep.grep_search","title":"grep_search","text":"<pre><code>grep_search(\n    pattern: str,\n    path: str,\n    recursive: bool = True,\n    file_pattern: str = \"*\",\n    context_lines: int = 0,\n    ignore_case: bool = False,\n    regex: bool = True,\n    max_results: int = 100,\n    security: FilesystemSecurity | None = None,\n) -&gt; list[GrepMatch]\n</code></pre> <p>Search file contents for a pattern.</p> PARAMETER DESCRIPTION <code>pattern</code> <p>Pattern to search for (string or regex).</p> <p> TYPE: <code>str</code> </p> <code>path</code> <p>File or directory to search.</p> <p> TYPE: <code>str</code> </p> <code>recursive</code> <p>Search directories recursively.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>file_pattern</code> <p>Glob pattern for files to search (e.g., \"*.py\").</p> <p> TYPE: <code>str</code> DEFAULT: <code>'*'</code> </p> <code>context_lines</code> <p>Number of lines to include before/after matches.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>ignore_case</code> <p>Case-insensitive search.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>regex</code> <p>Treat pattern as regex (default: True).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>max_results</code> <p>Maximum number of matches to return.</p> <p> TYPE: <code>int</code> DEFAULT: <code>100</code> </p> <code>security</code> <p>Optional security context for path validation.</p> <p> TYPE: <code>FilesystemSecurity | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>list[GrepMatch]</code> <p>List of GrepMatch objects.</p> RAISES DESCRIPTION <code>FileNotFoundError</code> <p>If the path doesn't exist.</p> <code>PermissionError</code> <p>If access is denied.</p> Source code in <code>src/pydantic_agent/tools/grep.py</code> <pre><code>def grep_search(\n    pattern: str,\n    path: str,\n    recursive: bool = True,\n    file_pattern: str = \"*\",\n    context_lines: int = 0,\n    ignore_case: bool = False,\n    regex: bool = True,\n    max_results: int = 100,\n    security: FilesystemSecurity | None = None,\n) -&gt; list[GrepMatch]:\n    \"\"\"Search file contents for a pattern.\n\n    Args:\n        pattern: Pattern to search for (string or regex).\n        path: File or directory to search.\n        recursive: Search directories recursively.\n        file_pattern: Glob pattern for files to search (e.g., \"*.py\").\n        context_lines: Number of lines to include before/after matches.\n        ignore_case: Case-insensitive search.\n        regex: Treat pattern as regex (default: True).\n        max_results: Maximum number of matches to return.\n        security: Optional security context for path validation.\n\n    Returns:\n        List of GrepMatch objects.\n\n    Raises:\n        FileNotFoundError: If the path doesn't exist.\n        PermissionError: If access is denied.\n    \"\"\"\n    if security is not None:\n        search_path = security.validate_path(path)\n    else:\n        search_path = Path(path)\n\n    if not search_path.exists():\n        raise FileNotFoundError(f\"Path not found: {path}\")\n\n    # Compile the pattern\n    flags = re.IGNORECASE if ignore_case else 0\n    if regex:\n        compiled = re.compile(pattern, flags)\n    else:\n        # Escape special regex characters for literal search\n        compiled = re.compile(re.escape(pattern), flags)\n\n    matches: list[GrepMatch] = []\n\n    # Get files to search\n    if search_path.is_file():\n        files = [search_path]\n    else:\n        if recursive:\n            files = list(search_path.rglob(file_pattern))\n        else:\n            files = list(search_path.glob(file_pattern))\n\n    for file_path in files:\n        if not file_path.is_file():\n            continue\n\n        if len(matches) &gt;= max_results:\n            break\n\n        try:\n            # Skip binary files\n            content = file_path.read_bytes()\n            if b\"\\x00\" in content[:8192]:  # Check first 8KB for null bytes\n                continue\n\n            lines = content.decode(\"utf-8\", errors=\"replace\").splitlines()\n\n            for i, line in enumerate(lines):\n                if len(matches) &gt;= max_results:\n                    break\n\n                if compiled.search(line):\n                    # Get context lines\n                    start = max(0, i - context_lines)\n                    end = min(len(lines), i + context_lines + 1)\n\n                    match = GrepMatch(\n                        file=str(file_path),\n                        line_number=i + 1,  # 1-indexed\n                        line=line,\n                        context_before=lines[start:i],\n                        context_after=lines[i + 1 : end],\n                    )\n                    matches.append(match)\n\n        except (PermissionError, OSError):\n            # Skip files we can't read\n            continue\n\n    return matches\n</code></pre>"},{"location":"api/tools/registry/","title":"ToolRegistry","text":"<p>Registry for organizing and managing tools.</p>"},{"location":"api/tools/registry/#quick-example","title":"Quick Example","text":"<pre><code>from pydantic_agent.tools import ToolRegistry\nfrom pydantic_agent.tools import read_file, write_file\n\nregistry = ToolRegistry()\n\n# Register tools\nregistry.register(read_file)\nregistry.register(write_file)\n\n# Get all tools\nall_tools = registry.get_all()\n\n# Use with agent\nfrom pydantic_agent import Agent\nagent = Agent(\"gpt-4o\", tools=all_tools)\n</code></pre>"},{"location":"api/tools/registry/#api-reference","title":"API Reference","text":""},{"location":"api/tools/registry/#pydantic_agent.tools.registry.ToolRegistry","title":"ToolRegistry","text":"<pre><code>ToolRegistry()\n</code></pre> <p>Registry for managing tool functions.</p> <p>Provides tool registration, enable/disable, and grouping functionality.</p> <p>Initialize an empty tool registry.</p> Source code in <code>src/pydantic_agent/tools/registry.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize an empty tool registry.\"\"\"\n    self._tools: dict[str, ToolInfo] = {}\n</code></pre>"},{"location":"api/tools/registry/#pydantic_agent.tools.registry.ToolRegistry.register","title":"register","text":"<pre><code>register(\n    func: Callable[..., Any] | None = None,\n    *,\n    name: str | None = None,\n    description: str | None = None,\n    group: str | None = None,\n) -&gt; Callable[..., Any]\n</code></pre> <p>Register a tool function.</p> <p>Can be used as a decorator with or without arguments.</p> PARAMETER DESCRIPTION <code>func</code> <p>The tool function to register.</p> <p> TYPE: <code>Callable[..., Any] | None</code> DEFAULT: <code>None</code> </p> <code>name</code> <p>Optional custom name (defaults to function name).</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>description</code> <p>Optional description (defaults to docstring).</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>group</code> <p>Optional group/namespace.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Callable[..., Any]</code> <p>The original function (for decorator use).</p> Source code in <code>src/pydantic_agent/tools/registry.py</code> <pre><code>def register(\n    self,\n    func: Callable[..., Any] | None = None,\n    *,\n    name: str | None = None,\n    description: str | None = None,\n    group: str | None = None,\n) -&gt; Callable[..., Any]:\n    \"\"\"Register a tool function.\n\n    Can be used as a decorator with or without arguments.\n\n    Args:\n        func: The tool function to register.\n        name: Optional custom name (defaults to function name).\n        description: Optional description (defaults to docstring).\n        group: Optional group/namespace.\n\n    Returns:\n        The original function (for decorator use).\n    \"\"\"\n\n    def decorator(f: Callable[..., Any]) -&gt; Callable[..., Any]:\n        tool_name = name or f.__name__\n        tool_desc = description or f.__doc__ or \"\"\n\n        self._tools[tool_name] = ToolInfo(\n            name=tool_name,\n            func=f,\n            description=tool_desc,\n            group=group,\n        )\n        return f\n\n    if func is not None:\n        return decorator(func)\n    return decorator\n</code></pre>"},{"location":"api/tools/registry/#pydantic_agent.tools.registry.ToolRegistry.get","title":"get","text":"<pre><code>get(name: str) -&gt; ToolInfo | None\n</code></pre> <p>Get a tool by name.</p> PARAMETER DESCRIPTION <code>name</code> <p>The tool name.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>ToolInfo | None</code> <p>ToolInfo if found, None otherwise.</p> Source code in <code>src/pydantic_agent/tools/registry.py</code> <pre><code>def get(self, name: str) -&gt; ToolInfo | None:\n    \"\"\"Get a tool by name.\n\n    Args:\n        name: The tool name.\n\n    Returns:\n        ToolInfo if found, None otherwise.\n    \"\"\"\n    return self._tools.get(name)\n</code></pre>"},{"location":"api/tools/registry/#pydantic_agent.tools.registry.ToolRegistry.get_enabled","title":"get_enabled","text":"<pre><code>get_enabled() -&gt; list[ToolInfo]\n</code></pre> <p>Get all enabled tools.</p> RETURNS DESCRIPTION <code>list[ToolInfo]</code> <p>List of enabled ToolInfo objects.</p> Source code in <code>src/pydantic_agent/tools/registry.py</code> <pre><code>def get_enabled(self) -&gt; list[ToolInfo]:\n    \"\"\"Get all enabled tools.\n\n    Returns:\n        List of enabled ToolInfo objects.\n    \"\"\"\n    return [t for t in self._tools.values() if t.enabled]\n</code></pre>"},{"location":"api/tools/registry/#pydantic_agent.tools.registry.ToolRegistry.get_by_group","title":"get_by_group","text":"<pre><code>get_by_group(group: str) -&gt; list[ToolInfo]\n</code></pre> <p>Get tools by group.</p> PARAMETER DESCRIPTION <code>group</code> <p>The group name.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list[ToolInfo]</code> <p>List of ToolInfo objects in the group.</p> Source code in <code>src/pydantic_agent/tools/registry.py</code> <pre><code>def get_by_group(self, group: str) -&gt; list[ToolInfo]:\n    \"\"\"Get tools by group.\n\n    Args:\n        group: The group name.\n\n    Returns:\n        List of ToolInfo objects in the group.\n    \"\"\"\n    return [t for t in self._tools.values() if t.group == group]\n</code></pre>"},{"location":"api/tools/registry/#pydantic_agent.tools.registry.ToolRegistry.enable","title":"enable","text":"<pre><code>enable(name: str) -&gt; bool\n</code></pre> <p>Enable a tool.</p> PARAMETER DESCRIPTION <code>name</code> <p>The tool name.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the tool was found and enabled.</p> Source code in <code>src/pydantic_agent/tools/registry.py</code> <pre><code>def enable(self, name: str) -&gt; bool:\n    \"\"\"Enable a tool.\n\n    Args:\n        name: The tool name.\n\n    Returns:\n        True if the tool was found and enabled.\n    \"\"\"\n    if name in self._tools:\n        self._tools[name].enabled = True\n        return True\n    return False\n</code></pre>"},{"location":"api/tools/registry/#pydantic_agent.tools.registry.ToolRegistry.disable","title":"disable","text":"<pre><code>disable(name: str) -&gt; bool\n</code></pre> <p>Disable a tool.</p> PARAMETER DESCRIPTION <code>name</code> <p>The tool name.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the tool was found and disabled.</p> Source code in <code>src/pydantic_agent/tools/registry.py</code> <pre><code>def disable(self, name: str) -&gt; bool:\n    \"\"\"Disable a tool.\n\n    Args:\n        name: The tool name.\n\n    Returns:\n        True if the tool was found and disabled.\n    \"\"\"\n    if name in self._tools:\n        self._tools[name].enabled = False\n        return True\n    return False\n</code></pre>"},{"location":"api/tools/registry/#pydantic_agent.tools.registry.ToolRegistry.list_all","title":"list_all","text":"<pre><code>list_all() -&gt; list[str]\n</code></pre> <p>List all registered tool names.</p> RETURNS DESCRIPTION <code>list[str]</code> <p>List of tool names.</p> Source code in <code>src/pydantic_agent/tools/registry.py</code> <pre><code>def list_all(self) -&gt; list[str]:\n    \"\"\"List all registered tool names.\n\n    Returns:\n        List of tool names.\n    \"\"\"\n    return list(self._tools.keys())\n</code></pre>"},{"location":"api/tools/registry/#pydantic_agent.tools.registry.ToolRegistry.as_functions","title":"as_functions","text":"<pre><code>as_functions() -&gt; list[Callable[..., Any]]\n</code></pre> <p>Get all enabled tools as a list of functions.</p> RETURNS DESCRIPTION <code>list[Callable[..., Any]]</code> <p>List of tool functions.</p> Source code in <code>src/pydantic_agent/tools/registry.py</code> <pre><code>def as_functions(self) -&gt; list[Callable[..., Any]]:\n    \"\"\"Get all enabled tools as a list of functions.\n\n    Returns:\n        List of tool functions.\n    \"\"\"\n    return [t.func for t in self.get_enabled()]\n</code></pre>"},{"location":"api/workflows/","title":"Workflows Module","text":"<p>Workflow orchestration for multi-step agent execution.</p>"},{"location":"api/workflows/#classes","title":"Classes","text":"Class Description Workflow Abstract base class for workflows ReActWorkflow Built-in ReAct implementation WorkflowConfig Base workflow configuration WorkflowHooks Lifecycle callbacks"},{"location":"api/workflows/#quick-example","title":"Quick Example","text":"<pre><code>from pydantic_agent import Agent\nfrom pydantic_agent.workflows import ReActWorkflow, ReActConfig\n\nagent = Agent(\"gpt-4o\", tools=[read_file, run_bash])\nworkflow = ReActWorkflow(agent=agent, config=ReActConfig(max_iterations=10))\n\nresult = await workflow.run(\"Find bugs in the code\")\nprint(result.output)\n</code></pre>"},{"location":"api/workflows/#imports","title":"Imports","text":"<pre><code># Main exports\nfrom pydantic_agent import (\n    Workflow,\n    WorkflowConfig,\n    WorkflowHooks,\n    WorkflowResult,\n    WorkflowState,\n    WorkflowStep,\n)\n\n# ReAct workflow\nfrom pydantic_agent.workflows import (\n    ReActWorkflow,\n    ReActConfig,\n    ReActState,\n    ReActHooks,\n)\n</code></pre>"},{"location":"api/workflows/base/","title":"Workflow Base Classes","text":"<p>Base classes for creating custom workflows.</p>"},{"location":"api/workflows/base/#classes","title":"Classes","text":""},{"location":"api/workflows/base/#workflow","title":"Workflow","text":"<p>Abstract base class for workflow implementations.</p> <pre><code>from pydantic_agent import Workflow, WorkflowConfig, WorkflowState\n\nclass MyWorkflow(Workflow[None, str, dict]):\n    @property\n    def name(self) -&gt; str:\n        return \"my_workflow\"\n\n    def _create_initial_state(self, prompt: str) -&gt; WorkflowState[dict]:\n        return WorkflowState(context={\"prompt\": prompt})\n\n    async def _execute(self, prompt, state, deps=None) -&gt; str:\n        # Implementation\n        return \"result\"\n</code></pre>"},{"location":"api/workflows/base/#workflowstate","title":"WorkflowState","text":"<p>Tracks workflow progress and execution history.</p>"},{"location":"api/workflows/base/#workflowstep","title":"WorkflowStep","text":"<p>Represents a single step in workflow execution.</p>"},{"location":"api/workflows/base/#workflowresult","title":"WorkflowResult","text":"<p>Result of workflow execution.</p>"},{"location":"api/workflows/base/#api-reference","title":"API Reference","text":""},{"location":"api/workflows/base/#pydantic_agent.workflows.base.Workflow","title":"Workflow","text":"<pre><code>Workflow(\n    config: WorkflowConfig | None = None,\n    hooks: WorkflowHooks[StateT, OutputT] | None = None,\n)\n</code></pre> <p>               Bases: <code>ABC</code>, <code>Generic[DepsT, OutputT, StateT]</code></p> <p>Abstract base class for agentic workflows.</p> <p>Workflows orchestrate Agent instances through multi-step execution patterns. Subclasses implement specific workflow types (ReAct, Plan-Execute, Reflection).</p> Example <p>from pydantic_agent import Agent from pydantic_agent.workflows import Workflow, WorkflowConfig</p> <p>Initialize workflow.</p> PARAMETER DESCRIPTION <code>config</code> <p>Workflow execution configuration.</p> <p> TYPE: <code>WorkflowConfig | None</code> DEFAULT: <code>None</code> </p> <code>hooks</code> <p>Optional hooks for observability.</p> <p> TYPE: <code>WorkflowHooks[StateT, OutputT] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/pydantic_agent/workflows/base.py</code> <pre><code>def __init__(\n    self,\n    config: WorkflowConfig | None = None,\n    hooks: WorkflowHooks[StateT, OutputT] | None = None,\n) -&gt; None:\n    \"\"\"Initialize workflow.\n\n    Args:\n        config: Workflow execution configuration.\n        hooks: Optional hooks for observability.\n    \"\"\"\n    from pydantic_agent.workflows.config import WorkflowConfig\n    from pydantic_agent.workflows.hooks import WorkflowHooks\n\n    self._config = config or WorkflowConfig()\n    self._hooks: WorkflowHooks[StateT, OutputT] = hooks or WorkflowHooks()\n</code></pre>"},{"location":"api/workflows/base/#pydantic_agent.workflows.base.Workflow--create-a-custom-workflow-by-extending-workflow","title":"Create a custom workflow by extending Workflow","text":"<p>class MyWorkflow(Workflow[None, str, dict]): ...     @property ...     def name(self) -&gt; str: ...         return \"my_workflow\" ... ...     def _create_initial_state(self, prompt: str) -&gt; WorkflowState[dict]: ...         return WorkflowState(context={\"prompt\": prompt}) ... ...     async def _execute(self, prompt, state, deps): ...         # Implement workflow logic ...         return \"result\"</p>"},{"location":"api/workflows/base/#pydantic_agent.workflows.base.Workflow.name","title":"name  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Get the workflow name/type identifier.</p> RETURNS DESCRIPTION <code>str</code> <p>Workflow type identifier.</p>"},{"location":"api/workflows/base/#pydantic_agent.workflows.base.Workflow.config","title":"config  <code>property</code>","text":"<pre><code>config: WorkflowConfig\n</code></pre> <p>Get workflow configuration.</p>"},{"location":"api/workflows/base/#pydantic_agent.workflows.base.Workflow.hooks","title":"hooks  <code>property</code>","text":"<pre><code>hooks: WorkflowHooks[StateT, OutputT]\n</code></pre> <p>Get workflow hooks.</p>"},{"location":"api/workflows/base/#pydantic_agent.workflows.base.Workflow.run","title":"run  <code>async</code>","text":"<pre><code>run(\n    prompt: str, deps: DepsT | None = None\n) -&gt; WorkflowResult[OutputT, StateT]\n</code></pre> <p>Run the workflow.</p> PARAMETER DESCRIPTION <code>prompt</code> <p>Initial user prompt/task.</p> <p> TYPE: <code>str</code> </p> <code>deps</code> <p>Optional dependencies for agent calls.</p> <p> TYPE: <code>DepsT | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>WorkflowResult[OutputT, StateT]</code> <p>WorkflowResult with output and execution details.</p> Source code in <code>src/pydantic_agent/workflows/base.py</code> <pre><code>async def run(\n    self,\n    prompt: str,\n    deps: DepsT | None = None,\n) -&gt; WorkflowResult[OutputT, StateT]:\n    \"\"\"Run the workflow.\n\n    Args:\n        prompt: Initial user prompt/task.\n        deps: Optional dependencies for agent calls.\n\n    Returns:\n        WorkflowResult with output and execution details.\n    \"\"\"\n    start_time = datetime.now(UTC)\n    state = self._create_initial_state(prompt)\n\n    try:\n        # Trigger workflow start hook\n        if self._config.enable_hooks:\n            await self._hooks.trigger_workflow_start(state)\n\n        # Execute workflow with timeout\n        if self._config.timeout_seconds:\n            output = await asyncio.wait_for(\n                self._execute(prompt, state, deps),\n                timeout=self._config.timeout_seconds,\n            )\n        else:\n            output = await self._execute(prompt, state, deps)\n\n        state.is_complete = True\n        duration = (datetime.now(UTC) - start_time).total_seconds()\n\n        result: WorkflowResult[OutputT, StateT] = WorkflowResult.ok(\n            output=output,\n            state=state,\n            duration=duration,\n            reason=\"completed\",\n        )\n\n        # Trigger workflow complete hook\n        if self._config.enable_hooks:\n            await self._hooks.trigger_workflow_complete(result)\n\n        return result\n\n    except asyncio.TimeoutError:\n        duration = (datetime.now(UTC) - start_time).total_seconds()\n        state.is_failed = True\n        return WorkflowResult.fail(\n            error=f\"Workflow exceeded timeout of {self._config.timeout_seconds}s\",\n            state=state,\n            duration=duration,\n            reason=\"timeout\",\n        )\n\n    except Exception as e:\n        duration = (datetime.now(UTC) - start_time).total_seconds()\n        state.is_failed = True\n\n        # Trigger error hook\n        if self._config.enable_hooks:\n            await self._hooks.trigger_workflow_error(state, e)\n\n        return WorkflowResult.fail(\n            error=str(e),\n            state=state,\n            duration=duration,\n            reason=\"error\",\n        )\n</code></pre>"},{"location":"api/workflows/base/#pydantic_agent.workflows.base.Workflow.run_sync","title":"run_sync","text":"<pre><code>run_sync(\n    prompt: str, deps: DepsT | None = None\n) -&gt; WorkflowResult[OutputT, StateT]\n</code></pre> <p>Run the workflow synchronously.</p> PARAMETER DESCRIPTION <code>prompt</code> <p>Initial user prompt/task.</p> <p> TYPE: <code>str</code> </p> <code>deps</code> <p>Optional dependencies for agent calls.</p> <p> TYPE: <code>DepsT | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>WorkflowResult[OutputT, StateT]</code> <p>WorkflowResult with output and execution details.</p> Source code in <code>src/pydantic_agent/workflows/base.py</code> <pre><code>def run_sync(\n    self,\n    prompt: str,\n    deps: DepsT | None = None,\n) -&gt; WorkflowResult[OutputT, StateT]:\n    \"\"\"Run the workflow synchronously.\n\n    Args:\n        prompt: Initial user prompt/task.\n        deps: Optional dependencies for agent calls.\n\n    Returns:\n        WorkflowResult with output and execution details.\n    \"\"\"\n    return asyncio.run(self.run(prompt, deps))\n</code></pre>"},{"location":"api/workflows/base/#pydantic_agent.workflows.base.WorkflowState","title":"WorkflowState  <code>dataclass</code>","text":"<pre><code>WorkflowState(\n    current_step: int = 1,\n    total_steps: int = 0,\n    iteration_count: int = 0,\n    is_complete: bool = False,\n    is_failed: bool = False,\n    steps: list[WorkflowStep[Any]] = list(),\n    context: StateT | None = None,\n    metadata: dict[str, Any] = dict(),\n)\n</code></pre> <p>               Bases: <code>Generic[StateT]</code></p> <p>Current state of workflow execution.</p> <p>Tracks progress, decisions, and execution history.</p> ATTRIBUTE DESCRIPTION <code>current_step</code> <p>Current step number (1-indexed).</p> <p> TYPE: <code>int</code> </p> <code>total_steps</code> <p>Total steps executed so far.</p> <p> TYPE: <code>int</code> </p> <code>iteration_count</code> <p>Current iteration count within workflow.</p> <p> TYPE: <code>int</code> </p> <code>is_complete</code> <p>Whether workflow has completed.</p> <p> TYPE: <code>bool</code> </p> <code>is_failed</code> <p>Whether workflow failed.</p> <p> TYPE: <code>bool</code> </p> <code>steps</code> <p>List of all executed steps.</p> <p> TYPE: <code>list[WorkflowStep[Any]]</code> </p> <code>context</code> <p>Workflow-specific state data.</p> <p> TYPE: <code>StateT | None</code> </p> <code>metadata</code> <p>Additional workflow metadata.</p> <p> TYPE: <code>dict[str, Any]</code> </p>"},{"location":"api/workflows/base/#pydantic_agent.workflows.base.WorkflowState.add_step","title":"add_step","text":"<pre><code>add_step(step: WorkflowStep[Any]) -&gt; None\n</code></pre> <p>Add a completed step to history.</p> Source code in <code>src/pydantic_agent/workflows/base.py</code> <pre><code>def add_step(self, step: WorkflowStep[Any]) -&gt; None:\n    \"\"\"Add a completed step to history.\"\"\"\n    self.steps.append(step)\n    self.total_steps = len(self.steps)\n    self.current_step = self.total_steps + 1\n</code></pre>"},{"location":"api/workflows/base/#pydantic_agent.workflows.base.WorkflowState.get_latest_step","title":"get_latest_step","text":"<pre><code>get_latest_step() -&gt; WorkflowStep[Any] | None\n</code></pre> <p>Get the most recent step.</p> Source code in <code>src/pydantic_agent/workflows/base.py</code> <pre><code>def get_latest_step(self) -&gt; WorkflowStep[Any] | None:\n    \"\"\"Get the most recent step.\"\"\"\n    return self.steps[-1] if self.steps else None\n</code></pre>"},{"location":"api/workflows/base/#pydantic_agent.workflows.base.WorkflowState.get_step","title":"get_step","text":"<pre><code>get_step(step_number: int) -&gt; WorkflowStep[Any] | None\n</code></pre> <p>Get step by number (1-indexed).</p> Source code in <code>src/pydantic_agent/workflows/base.py</code> <pre><code>def get_step(self, step_number: int) -&gt; WorkflowStep[Any] | None:\n    \"\"\"Get step by number (1-indexed).\"\"\"\n    idx = step_number - 1\n    return self.steps[idx] if 0 &lt;= idx &lt; len(self.steps) else None\n</code></pre>"},{"location":"api/workflows/base/#pydantic_agent.workflows.base.WorkflowStep","title":"WorkflowStep  <code>dataclass</code>","text":"<pre><code>WorkflowStep(\n    step_number: int,\n    step_type: str,\n    description: str,\n    input_data: Any,\n    output_data: OutputT | None = None,\n    agent_result: Any = None,\n    error: str | None = None,\n    started_at: datetime = (lambda: now(UTC))(),\n    completed_at: datetime | None = None,\n    metadata: dict[str, Any] = dict(),\n)\n</code></pre> <p>               Bases: <code>Generic[OutputT]</code></p> <p>A single step in workflow execution.</p> ATTRIBUTE DESCRIPTION <code>step_number</code> <p>Sequential step number (1-indexed).</p> <p> TYPE: <code>int</code> </p> <code>step_type</code> <p>Type identifier (e.g., \"agent_call\", \"decision\", \"reflection\").</p> <p> TYPE: <code>str</code> </p> <code>description</code> <p>Human-readable step description.</p> <p> TYPE: <code>str</code> </p> <code>input_data</code> <p>Input provided to this step.</p> <p> TYPE: <code>Any</code> </p> <code>output_data</code> <p>Output produced by this step.</p> <p> TYPE: <code>OutputT | None</code> </p> <code>agent_result</code> <p>AgentResult if step invoked an agent.</p> <p> TYPE: <code>Any</code> </p> <code>error</code> <p>Error message if step failed.</p> <p> TYPE: <code>str | None</code> </p> <code>started_at</code> <p>Step start timestamp.</p> <p> TYPE: <code>datetime</code> </p> <code>completed_at</code> <p>Step completion timestamp.</p> <p> TYPE: <code>datetime | None</code> </p> <code>metadata</code> <p>Additional step-specific metadata.</p> <p> TYPE: <code>dict[str, Any]</code> </p>"},{"location":"api/workflows/base/#pydantic_agent.workflows.base.WorkflowStep.duration_seconds","title":"duration_seconds  <code>property</code>","text":"<pre><code>duration_seconds: float | None\n</code></pre> <p>Calculate step duration in seconds.</p>"},{"location":"api/workflows/base/#pydantic_agent.workflows.base.WorkflowStep.success","title":"success  <code>property</code>","text":"<pre><code>success: bool\n</code></pre> <p>Check if step completed successfully.</p>"},{"location":"api/workflows/base/#pydantic_agent.workflows.base.WorkflowResult","title":"WorkflowResult  <code>dataclass</code>","text":"<pre><code>WorkflowResult(\n    success: bool,\n    output: OutputT | None = None,\n    state: WorkflowState[StateT] | None = None,\n    error: str | None = None,\n    total_steps: int = 0,\n    total_iterations: int = 0,\n    duration_seconds: float = 0.0,\n    termination_reason: str = \"unknown\",\n)\n</code></pre> <p>               Bases: <code>Generic[OutputT, StateT]</code></p> <p>Result of workflow execution.</p> ATTRIBUTE DESCRIPTION <code>success</code> <p>Whether workflow completed successfully.</p> <p> TYPE: <code>bool</code> </p> <code>output</code> <p>Final workflow output.</p> <p> TYPE: <code>OutputT | None</code> </p> <code>state</code> <p>Final workflow state.</p> <p> TYPE: <code>WorkflowState[StateT] | None</code> </p> <code>error</code> <p>Error message if workflow failed.</p> <p> TYPE: <code>str | None</code> </p> <code>total_steps</code> <p>Total steps executed.</p> <p> TYPE: <code>int</code> </p> <code>total_iterations</code> <p>Total iterations across all steps.</p> <p> TYPE: <code>int</code> </p> <code>duration_seconds</code> <p>Total execution time.</p> <p> TYPE: <code>float</code> </p> <code>termination_reason</code> <p>Why the workflow stopped.</p> <p> TYPE: <code>str</code> </p>"},{"location":"api/workflows/base/#pydantic_agent.workflows.base.WorkflowResult.ok","title":"ok  <code>classmethod</code>","text":"<pre><code>ok(\n    output: OutputT,\n    state: WorkflowState[StateT],\n    duration: float,\n    reason: str = \"completed\",\n) -&gt; WorkflowResult[OutputT, StateT]\n</code></pre> <p>Create successful result.</p> Source code in <code>src/pydantic_agent/workflows/base.py</code> <pre><code>@classmethod\ndef ok(\n    cls,\n    output: OutputT,\n    state: WorkflowState[StateT],\n    duration: float,\n    reason: str = \"completed\",\n) -&gt; WorkflowResult[OutputT, StateT]:\n    \"\"\"Create successful result.\"\"\"\n    return cls(\n        success=True,\n        output=output,\n        state=state,\n        total_steps=state.total_steps,\n        total_iterations=state.iteration_count,\n        duration_seconds=duration,\n        termination_reason=reason,\n    )\n</code></pre>"},{"location":"api/workflows/base/#pydantic_agent.workflows.base.WorkflowResult.fail","title":"fail  <code>classmethod</code>","text":"<pre><code>fail(\n    error: str,\n    state: WorkflowState[StateT] | None = None,\n    duration: float = 0.0,\n    reason: str = \"error\",\n) -&gt; WorkflowResult[Any, StateT]\n</code></pre> <p>Create failed result.</p> Source code in <code>src/pydantic_agent/workflows/base.py</code> <pre><code>@classmethod\ndef fail(\n    cls,\n    error: str,\n    state: WorkflowState[StateT] | None = None,\n    duration: float = 0.0,\n    reason: str = \"error\",\n) -&gt; WorkflowResult[Any, StateT]:\n    \"\"\"Create failed result.\"\"\"\n    return cls(\n        success=False,\n        error=error,\n        state=state,\n        total_steps=state.total_steps if state else 0,\n        total_iterations=state.iteration_count if state else 0,\n        duration_seconds=duration,\n        termination_reason=reason,\n    )\n</code></pre>"},{"location":"api/workflows/config/","title":"WorkflowConfig","text":"<p>Base configuration for workflows.</p>"},{"location":"api/workflows/config/#quick-example","title":"Quick Example","text":"<pre><code>from pydantic_agent import WorkflowConfig\n\nconfig = WorkflowConfig(\n    max_steps=50,\n    max_iterations=10,\n    timeout_seconds=300.0,\n    step_timeout_seconds=30.0,\n    enable_hooks=True,\n    track_state=True,\n)\n</code></pre>"},{"location":"api/workflows/config/#configuration-options","title":"Configuration Options","text":"Option Type Default Description <code>max_steps</code> int 50 Maximum workflow steps <code>max_iterations</code> int 10 Max iterations per step <code>timeout_seconds</code> float 300.0 Total workflow timeout <code>step_timeout_seconds</code> float 30.0 Per-step timeout <code>enable_hooks</code> bool True Enable hook callbacks <code>track_state</code> bool True Track detailed state"},{"location":"api/workflows/config/#api-reference","title":"API Reference","text":""},{"location":"api/workflows/config/#pydantic_agent.workflows.config.WorkflowConfig","title":"WorkflowConfig","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration for workflow execution.</p> ATTRIBUTE DESCRIPTION <code>max_steps</code> <p>Maximum workflow steps before termination.</p> <p> TYPE: <code>int</code> </p> <code>max_iterations</code> <p>Maximum iterations per step.</p> <p> TYPE: <code>int</code> </p> <code>timeout_seconds</code> <p>Total workflow timeout in seconds (None for unlimited).</p> <p> TYPE: <code>float | None</code> </p> <code>step_timeout_seconds</code> <p>Per-step timeout in seconds (None for unlimited).</p> <p> TYPE: <code>float | None</code> </p> <code>enable_hooks</code> <p>Whether to invoke hooks during execution.</p> <p> TYPE: <code>bool</code> </p> <code>track_state</code> <p>Whether to track detailed state history.</p> <p> TYPE: <code>bool</code> </p>"},{"location":"api/workflows/hooks/","title":"WorkflowHooks","text":"<p>Lifecycle callbacks for workflow observability.</p>"},{"location":"api/workflows/hooks/#quick-example","title":"Quick Example","text":"<pre><code>from pydantic_agent import WorkflowHooks\n\ndef log_step(state, step):\n    print(f\"Step {step.step_number}: {step.description}\")\n\nhooks = WorkflowHooks(\n    on_workflow_start=lambda s: print(\"Starting...\"),\n    on_workflow_complete=lambda r: print(f\"Done: {r.success}\"),\n    on_workflow_error=lambda s, e: print(f\"Error: {e}\"),\n    on_step_start=lambda s, n, t: print(f\"Step {n}\"),\n    on_step_complete=log_step,\n    on_step_error=lambda s, step, e: print(f\"Step failed: {e}\"),\n    on_iteration_start=lambda s, i: print(f\"Iteration {i}\"),\n    on_iteration_complete=lambda s, i: print(f\"Iteration {i} done\"),\n)\n</code></pre>"},{"location":"api/workflows/hooks/#available-hooks","title":"Available Hooks","text":"Hook Parameters Description <code>on_workflow_start</code> (state) Workflow begins <code>on_workflow_complete</code> (result) Workflow completes <code>on_workflow_error</code> (state, error) Workflow fails <code>on_step_start</code> (state, step_num, step_type) Step starts <code>on_step_complete</code> (state, step) Step completes <code>on_step_error</code> (state, step, error) Step fails <code>on_iteration_start</code> (state, iteration) Iteration starts <code>on_iteration_complete</code> (state, iteration) Iteration ends"},{"location":"api/workflows/hooks/#api-reference","title":"API Reference","text":""},{"location":"api/workflows/hooks/#pydantic_agent.workflows.hooks.WorkflowHooks","title":"WorkflowHooks","text":"<pre><code>WorkflowHooks(\n    on_workflow_start: WorkflowStartHook[StateT]\n    | None = None,\n    on_workflow_complete: WorkflowCompleteHook[\n        OutputT, StateT\n    ]\n    | None = None,\n    on_workflow_error: WorkflowErrorHook[StateT]\n    | None = None,\n    on_step_start: StepStartHook[StateT] | None = None,\n    on_step_complete: StepCompleteHook[StateT]\n    | None = None,\n    on_step_error: StepErrorHook[StateT] | None = None,\n    on_iteration_start: IterationStartHook[StateT]\n    | None = None,\n    on_iteration_complete: IterationCompleteHook[StateT]\n    | None = None,\n)\n</code></pre> <p>               Bases: <code>Generic[StateT, OutputT]</code></p> <p>Hook callbacks for workflow execution events.</p> <p>All hooks are optional and receive workflow state/context. Hooks can be sync or async functions.</p> ATTRIBUTE DESCRIPTION <code>on_workflow_start</code> <p>Called when workflow begins.</p> <p> </p> <code>on_workflow_complete</code> <p>Called when workflow completes successfully.</p> <p> </p> <code>on_workflow_error</code> <p>Called when workflow fails.</p> <p> </p> <code>on_step_start</code> <p>Called before each step executes.</p> <p> </p> <code>on_step_complete</code> <p>Called after each step completes.</p> <p> </p> <code>on_step_error</code> <p>Called when a step fails.</p> <p> </p> <code>on_iteration_start</code> <p>Called at the start of each iteration.</p> <p> </p> <code>on_iteration_complete</code> <p>Called at the end of each iteration.</p> <p> </p> <p>Initialize workflow hooks.</p> PARAMETER DESCRIPTION <code>on_workflow_start</code> <p>Called when workflow begins.</p> <p> TYPE: <code>WorkflowStartHook[StateT] | None</code> DEFAULT: <code>None</code> </p> <code>on_workflow_complete</code> <p>Called when workflow completes successfully.</p> <p> TYPE: <code>WorkflowCompleteHook[OutputT, StateT] | None</code> DEFAULT: <code>None</code> </p> <code>on_workflow_error</code> <p>Called when workflow fails.</p> <p> TYPE: <code>WorkflowErrorHook[StateT] | None</code> DEFAULT: <code>None</code> </p> <code>on_step_start</code> <p>Called before each step executes.</p> <p> TYPE: <code>StepStartHook[StateT] | None</code> DEFAULT: <code>None</code> </p> <code>on_step_complete</code> <p>Called after each step completes.</p> <p> TYPE: <code>StepCompleteHook[StateT] | None</code> DEFAULT: <code>None</code> </p> <code>on_step_error</code> <p>Called when a step fails.</p> <p> TYPE: <code>StepErrorHook[StateT] | None</code> DEFAULT: <code>None</code> </p> <code>on_iteration_start</code> <p>Called at the start of each iteration.</p> <p> TYPE: <code>IterationStartHook[StateT] | None</code> DEFAULT: <code>None</code> </p> <code>on_iteration_complete</code> <p>Called at the end of each iteration.</p> <p> TYPE: <code>IterationCompleteHook[StateT] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/pydantic_agent/workflows/hooks.py</code> <pre><code>def __init__(\n    self,\n    on_workflow_start: WorkflowStartHook[StateT] | None = None,\n    on_workflow_complete: WorkflowCompleteHook[OutputT, StateT] | None = None,\n    on_workflow_error: WorkflowErrorHook[StateT] | None = None,\n    on_step_start: StepStartHook[StateT] | None = None,\n    on_step_complete: StepCompleteHook[StateT] | None = None,\n    on_step_error: StepErrorHook[StateT] | None = None,\n    on_iteration_start: IterationStartHook[StateT] | None = None,\n    on_iteration_complete: IterationCompleteHook[StateT] | None = None,\n) -&gt; None:\n    \"\"\"Initialize workflow hooks.\n\n    Args:\n        on_workflow_start: Called when workflow begins.\n        on_workflow_complete: Called when workflow completes successfully.\n        on_workflow_error: Called when workflow fails.\n        on_step_start: Called before each step executes.\n        on_step_complete: Called after each step completes.\n        on_step_error: Called when a step fails.\n        on_iteration_start: Called at the start of each iteration.\n        on_iteration_complete: Called at the end of each iteration.\n    \"\"\"\n    self.on_workflow_start = on_workflow_start\n    self.on_workflow_complete = on_workflow_complete\n    self.on_workflow_error = on_workflow_error\n    self.on_step_start = on_step_start\n    self.on_step_complete = on_step_complete\n    self.on_step_error = on_step_error\n    self.on_iteration_start = on_iteration_start\n    self.on_iteration_complete = on_iteration_complete\n</code></pre>"},{"location":"api/workflows/hooks/#pydantic_agent.workflows.hooks.WorkflowHooks.trigger_workflow_start","title":"trigger_workflow_start  <code>async</code>","text":"<pre><code>trigger_workflow_start(\n    state: WorkflowState[StateT],\n) -&gt; None\n</code></pre> <p>Trigger workflow start hook.</p> PARAMETER DESCRIPTION <code>state</code> <p>Current workflow state.</p> <p> TYPE: <code>WorkflowState[StateT]</code> </p> Source code in <code>src/pydantic_agent/workflows/hooks.py</code> <pre><code>async def trigger_workflow_start(self, state: WorkflowState[StateT]) -&gt; None:\n    \"\"\"Trigger workflow start hook.\n\n    Args:\n        state: Current workflow state.\n    \"\"\"\n    if self.on_workflow_start:\n        await self._call_hook(self.on_workflow_start, state)\n</code></pre>"},{"location":"api/workflows/hooks/#pydantic_agent.workflows.hooks.WorkflowHooks.trigger_workflow_complete","title":"trigger_workflow_complete  <code>async</code>","text":"<pre><code>trigger_workflow_complete(\n    result: WorkflowResult[OutputT, StateT],\n) -&gt; None\n</code></pre> <p>Trigger workflow complete hook.</p> PARAMETER DESCRIPTION <code>result</code> <p>Workflow result.</p> <p> TYPE: <code>WorkflowResult[OutputT, StateT]</code> </p> Source code in <code>src/pydantic_agent/workflows/hooks.py</code> <pre><code>async def trigger_workflow_complete(\n    self,\n    result: WorkflowResult[OutputT, StateT],\n) -&gt; None:\n    \"\"\"Trigger workflow complete hook.\n\n    Args:\n        result: Workflow result.\n    \"\"\"\n    if self.on_workflow_complete:\n        await self._call_hook(self.on_workflow_complete, result)\n</code></pre>"},{"location":"api/workflows/hooks/#pydantic_agent.workflows.hooks.WorkflowHooks.trigger_workflow_error","title":"trigger_workflow_error  <code>async</code>","text":"<pre><code>trigger_workflow_error(\n    state: WorkflowState[StateT], error: Exception\n) -&gt; None\n</code></pre> <p>Trigger workflow error hook.</p> PARAMETER DESCRIPTION <code>state</code> <p>Current workflow state.</p> <p> TYPE: <code>WorkflowState[StateT]</code> </p> <code>error</code> <p>The exception that caused the failure.</p> <p> TYPE: <code>Exception</code> </p> Source code in <code>src/pydantic_agent/workflows/hooks.py</code> <pre><code>async def trigger_workflow_error(\n    self,\n    state: WorkflowState[StateT],\n    error: Exception,\n) -&gt; None:\n    \"\"\"Trigger workflow error hook.\n\n    Args:\n        state: Current workflow state.\n        error: The exception that caused the failure.\n    \"\"\"\n    if self.on_workflow_error:\n        await self._call_hook(self.on_workflow_error, state, error)\n</code></pre>"},{"location":"api/workflows/hooks/#pydantic_agent.workflows.hooks.WorkflowHooks.trigger_step_start","title":"trigger_step_start  <code>async</code>","text":"<pre><code>trigger_step_start(\n    state: WorkflowState[StateT],\n    step_number: int,\n    step_type: str,\n) -&gt; None\n</code></pre> <p>Trigger step start hook.</p> PARAMETER DESCRIPTION <code>state</code> <p>Current workflow state.</p> <p> TYPE: <code>WorkflowState[StateT]</code> </p> <code>step_number</code> <p>The step number about to execute.</p> <p> TYPE: <code>int</code> </p> <code>step_type</code> <p>Type identifier of the step.</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/pydantic_agent/workflows/hooks.py</code> <pre><code>async def trigger_step_start(\n    self,\n    state: WorkflowState[StateT],\n    step_number: int,\n    step_type: str,\n) -&gt; None:\n    \"\"\"Trigger step start hook.\n\n    Args:\n        state: Current workflow state.\n        step_number: The step number about to execute.\n        step_type: Type identifier of the step.\n    \"\"\"\n    if self.on_step_start:\n        await self._call_hook(self.on_step_start, state, step_number, step_type)\n</code></pre>"},{"location":"api/workflows/hooks/#pydantic_agent.workflows.hooks.WorkflowHooks.trigger_step_complete","title":"trigger_step_complete  <code>async</code>","text":"<pre><code>trigger_step_complete(\n    state: WorkflowState[StateT], step: WorkflowStep[Any]\n) -&gt; None\n</code></pre> <p>Trigger step complete hook.</p> PARAMETER DESCRIPTION <code>state</code> <p>Current workflow state.</p> <p> TYPE: <code>WorkflowState[StateT]</code> </p> <code>step</code> <p>The completed step.</p> <p> TYPE: <code>WorkflowStep[Any]</code> </p> Source code in <code>src/pydantic_agent/workflows/hooks.py</code> <pre><code>async def trigger_step_complete(\n    self,\n    state: WorkflowState[StateT],\n    step: WorkflowStep[Any],\n) -&gt; None:\n    \"\"\"Trigger step complete hook.\n\n    Args:\n        state: Current workflow state.\n        step: The completed step.\n    \"\"\"\n    if self.on_step_complete:\n        await self._call_hook(self.on_step_complete, state, step)\n</code></pre>"},{"location":"api/workflows/hooks/#pydantic_agent.workflows.hooks.WorkflowHooks.trigger_step_error","title":"trigger_step_error  <code>async</code>","text":"<pre><code>trigger_step_error(\n    state: WorkflowState[StateT],\n    step: WorkflowStep[Any],\n    error: Exception,\n) -&gt; None\n</code></pre> <p>Trigger step error hook.</p> PARAMETER DESCRIPTION <code>state</code> <p>Current workflow state.</p> <p> TYPE: <code>WorkflowState[StateT]</code> </p> <code>step</code> <p>The failed step.</p> <p> TYPE: <code>WorkflowStep[Any]</code> </p> <code>error</code> <p>The exception that caused the failure.</p> <p> TYPE: <code>Exception</code> </p> Source code in <code>src/pydantic_agent/workflows/hooks.py</code> <pre><code>async def trigger_step_error(\n    self,\n    state: WorkflowState[StateT],\n    step: WorkflowStep[Any],\n    error: Exception,\n) -&gt; None:\n    \"\"\"Trigger step error hook.\n\n    Args:\n        state: Current workflow state.\n        step: The failed step.\n        error: The exception that caused the failure.\n    \"\"\"\n    if self.on_step_error:\n        await self._call_hook(self.on_step_error, state, step, error)\n</code></pre>"},{"location":"api/workflows/hooks/#pydantic_agent.workflows.hooks.WorkflowHooks.trigger_iteration_start","title":"trigger_iteration_start  <code>async</code>","text":"<pre><code>trigger_iteration_start(\n    state: WorkflowState[StateT], iteration: int\n) -&gt; None\n</code></pre> <p>Trigger iteration start hook.</p> PARAMETER DESCRIPTION <code>state</code> <p>Current workflow state.</p> <p> TYPE: <code>WorkflowState[StateT]</code> </p> <code>iteration</code> <p>The iteration number starting.</p> <p> TYPE: <code>int</code> </p> Source code in <code>src/pydantic_agent/workflows/hooks.py</code> <pre><code>async def trigger_iteration_start(\n    self,\n    state: WorkflowState[StateT],\n    iteration: int,\n) -&gt; None:\n    \"\"\"Trigger iteration start hook.\n\n    Args:\n        state: Current workflow state.\n        iteration: The iteration number starting.\n    \"\"\"\n    if self.on_iteration_start:\n        await self._call_hook(self.on_iteration_start, state, iteration)\n</code></pre>"},{"location":"api/workflows/hooks/#pydantic_agent.workflows.hooks.WorkflowHooks.trigger_iteration_complete","title":"trigger_iteration_complete  <code>async</code>","text":"<pre><code>trigger_iteration_complete(\n    state: WorkflowState[StateT], iteration: int\n) -&gt; None\n</code></pre> <p>Trigger iteration complete hook.</p> PARAMETER DESCRIPTION <code>state</code> <p>Current workflow state.</p> <p> TYPE: <code>WorkflowState[StateT]</code> </p> <code>iteration</code> <p>The iteration number completed.</p> <p> TYPE: <code>int</code> </p> Source code in <code>src/pydantic_agent/workflows/hooks.py</code> <pre><code>async def trigger_iteration_complete(\n    self,\n    state: WorkflowState[StateT],\n    iteration: int,\n) -&gt; None:\n    \"\"\"Trigger iteration complete hook.\n\n    Args:\n        state: Current workflow state.\n        iteration: The iteration number completed.\n    \"\"\"\n    if self.on_iteration_complete:\n        await self._call_hook(self.on_iteration_complete, state, iteration)\n</code></pre>"},{"location":"api/workflows/react/","title":"ReActWorkflow","text":"<p>Built-in implementation of the ReAct (Reasoning and Acting) pattern.</p>"},{"location":"api/workflows/react/#quick-example","title":"Quick Example","text":"<pre><code>from pydantic_agent import Agent\nfrom pydantic_agent.workflows import ReActWorkflow, ReActConfig, ReActHooks\nfrom pydantic_agent.tools import read_file, run_bash\n\nagent = Agent(\"gpt-4o\", tools=[read_file, run_bash])\n\nconfig = ReActConfig(\n    max_iterations=15,\n    expose_reasoning=True,\n    auto_compact_in_workflow=True,\n)\n\nhooks = ReActHooks(\n    on_thought=lambda s, t: print(f\"Thought: {t}\"),\n    on_action=lambda s, tool, args: print(f\"Action: {tool}\"),\n)\n\nworkflow = ReActWorkflow(agent=agent, config=config, hooks=hooks)\nresult = await workflow.run(\"Analyze the codebase\")\n\n# Access scratchpad\nfor entry in result.state.context.scratchpad:\n    print(f\"[{entry.entry_type}] {entry.content}\")\n</code></pre>"},{"location":"api/workflows/react/#classes","title":"Classes","text":""},{"location":"api/workflows/react/#reactworkflow_1","title":"ReActWorkflow","text":"<p>The main workflow class.</p>"},{"location":"api/workflows/react/#reactconfig","title":"ReActConfig","text":"<p>Configuration extending WorkflowConfig.</p>"},{"location":"api/workflows/react/#reactstate","title":"ReActState","text":"<p>State tracking for ReAct execution.</p>"},{"location":"api/workflows/react/#reacthooks","title":"ReActHooks","text":"<p>Callbacks extending WorkflowHooks.</p>"},{"location":"api/workflows/react/#api-reference","title":"API Reference","text":""},{"location":"api/workflows/react/#pydantic_agent.workflows.react.workflow.ReActWorkflow","title":"ReActWorkflow","text":"<pre><code>ReActWorkflow(\n    agent: Agent[DepsT, Any],\n    config: ReActConfig | None = None,\n    hooks: ReActHooks | None = None,\n)\n</code></pre> <p>               Bases: <code>Workflow[DepsT, str, ReActState]</code></p> <p>ReAct (Reasoning + Acting) workflow implementation.</p> <p>Implements the Thought -&gt; Action -&gt; Observation loop until the agent calls the final_answer tool to signal task completion.</p> <p>The workflow: 1. Sends the task to the agent 2. Agent thinks and calls tools 3. Tool results become observations 4. Loop continues until final_answer is called or max_iterations reached</p> Example <p>from pydantic_agent import Agent from pydantic_agent.workflows.react import ReActWorkflow, ReActConfig</p> <p>agent = Agent(\"gpt-4o\", tools=[read_file, run_bash]) workflow = ReActWorkflow( ...     agent=agent, ...     config=ReActConfig(max_iterations=10), ... ) result = workflow.run_sync(\"Find the bug in main.py\") print(result.output)  # Final answer print(result.state.context.scratchpad)  # All steps</p> <p>Initialize the ReAct workflow.</p> PARAMETER DESCRIPTION <code>agent</code> <p>Agent instance to use for execution.</p> <p> TYPE: <code>Agent[DepsT, Any]</code> </p> <code>config</code> <p>ReAct-specific configuration.</p> <p> TYPE: <code>ReActConfig | None</code> DEFAULT: <code>None</code> </p> <code>hooks</code> <p>Optional hooks for observability.</p> <p> TYPE: <code>ReActHooks | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/pydantic_agent/workflows/react/workflow.py</code> <pre><code>def __init__(\n    self,\n    agent: Agent[DepsT, Any],\n    config: ReActConfig | None = None,\n    hooks: ReActHooks | None = None,\n) -&gt; None:\n    \"\"\"Initialize the ReAct workflow.\n\n    Args:\n        agent: Agent instance to use for execution.\n        config: ReAct-specific configuration.\n        hooks: Optional hooks for observability.\n    \"\"\"\n    self._react_config = config or ReActConfig()\n    super().__init__(self._react_config, hooks)\n\n    self._agent = agent\n    self._react_hooks: ReActHooks = hooks or ReActHooks()\n    self._last_state: ReActState | None = None\n\n    # Register the final_answer tool\n    self._agent.tool_plain(\n        create_final_answer_tool(),\n        name=self._react_config.final_answer_tool_name,\n        retries=self._react_config.tool_retry_count,\n    )\n</code></pre>"},{"location":"api/workflows/react/#pydantic_agent.workflows.react.workflow.ReActWorkflow.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Get the workflow name.</p>"},{"location":"api/workflows/react/#pydantic_agent.workflows.react.workflow.ReActWorkflow.agent","title":"agent  <code>property</code>","text":"<pre><code>agent: Agent[DepsT, Any]\n</code></pre> <p>Get the agent instance.</p>"},{"location":"api/workflows/react/#pydantic_agent.workflows.react.workflow.ReActWorkflow.react_config","title":"react_config  <code>property</code>","text":"<pre><code>react_config: ReActConfig\n</code></pre> <p>Get the ReAct-specific configuration.</p>"},{"location":"api/workflows/react/#pydantic_agent.workflows.react.workflow.ReActWorkflow.get_token_usage","title":"get_token_usage","text":"<pre><code>get_token_usage() -&gt; TokenUsage\n</code></pre> <p>Get token usage statistics.</p> <p>Delegates to the agent's usage tracker.</p> RETURNS DESCRIPTION <code>TokenUsage</code> <p>TokenUsage with total prompt/completion/total tokens.</p> Source code in <code>src/pydantic_agent/workflows/react/workflow.py</code> <pre><code>def get_token_usage(self) -&gt; TokenUsage:\n    \"\"\"Get token usage statistics.\n\n    Delegates to the agent's usage tracker.\n\n    Returns:\n        TokenUsage with total prompt/completion/total tokens.\n    \"\"\"\n    return self._agent.get_usage()\n</code></pre>"},{"location":"api/workflows/react/#pydantic_agent.workflows.react.workflow.ReActWorkflow.get_cost","title":"get_cost","text":"<pre><code>get_cost() -&gt; float\n</code></pre> <p>Get estimated cost.</p> <p>Delegates to the agent's cost estimator.</p> RETURNS DESCRIPTION <code>float</code> <p>Estimated cost in USD.</p> Source code in <code>src/pydantic_agent/workflows/react/workflow.py</code> <pre><code>def get_cost(self) -&gt; float:\n    \"\"\"Get estimated cost.\n\n    Delegates to the agent's cost estimator.\n\n    Returns:\n        Estimated cost in USD.\n    \"\"\"\n    return self._agent.get_cost()\n</code></pre>"},{"location":"api/workflows/react/#pydantic_agent.workflows.react.workflow.ReActWorkflow.get_scratchpad","title":"get_scratchpad","text":"<pre><code>get_scratchpad() -&gt; list\n</code></pre> <p>Get the scratchpad entries from the last run.</p> RETURNS DESCRIPTION <code>list</code> <p>List of ScratchpadEntry objects, or empty list if no run yet.</p> Source code in <code>src/pydantic_agent/workflows/react/workflow.py</code> <pre><code>def get_scratchpad(self) -&gt; list:\n    \"\"\"Get the scratchpad entries from the last run.\n\n    Returns:\n        List of ScratchpadEntry objects, or empty list if no run yet.\n    \"\"\"\n    if self._last_state is None:\n        return []\n    return self._last_state.scratchpad\n</code></pre>"},{"location":"api/workflows/react/#pydantic_agent.workflows.react.workflow.ReActWorkflow.get_reasoning_trace","title":"get_reasoning_trace","text":"<pre><code>get_reasoning_trace() -&gt; str\n</code></pre> <p>Get formatted reasoning trace from the last run.</p> RETURNS DESCRIPTION <code>str</code> <p>Formatted scratchpad text, or empty string if no run yet.</p> Source code in <code>src/pydantic_agent/workflows/react/workflow.py</code> <pre><code>def get_reasoning_trace(self) -&gt; str:\n    \"\"\"Get formatted reasoning trace from the last run.\n\n    Returns:\n        Formatted scratchpad text, or empty string if no run yet.\n    \"\"\"\n    if self._last_state is None:\n        return \"\"\n    return self._last_state.get_scratchpad_text(self._react_config)\n</code></pre>"},{"location":"api/workflows/react/#pydantic_agent.workflows.react.config.ReActConfig","title":"ReActConfig","text":"<p>               Bases: <code>WorkflowConfig</code></p> <p>Configuration for ReAct workflow execution.</p> <p>Extends WorkflowConfig with ReAct-specific settings for reasoning trace visibility, termination strategy, and context management.</p> ATTRIBUTE DESCRIPTION <code>expose_reasoning</code> <p>Whether Thought steps appear in workflow state.</p> <p> TYPE: <code>bool</code> </p> <code>reasoning_prefix</code> <p>Prefix for reasoning/thought in prompts.</p> <p> TYPE: <code>str</code> </p> <code>action_prefix</code> <p>Prefix for actions in prompts.</p> <p> TYPE: <code>str</code> </p> <code>observation_prefix</code> <p>Prefix for observations in prompts.</p> <p> TYPE: <code>str</code> </p> <code>termination_strategy</code> <p>How to detect workflow completion (\"tool\" only for MVP).</p> <p> TYPE: <code>TerminationStrategy</code> </p> <code>final_answer_tool_name</code> <p>Name of the tool that signals completion.</p> <p> TYPE: <code>str</code> </p> <code>auto_compact_in_workflow</code> <p>Whether to auto-compact context mid-workflow.</p> <p> TYPE: <code>bool</code> </p> <code>compact_threshold_ratio</code> <p>Ratio of context limit to trigger compaction.</p> <p> TYPE: <code>float</code> </p> <code>max_consecutive_thoughts</code> <p>Max thoughts without action before forcing action.</p> <p> TYPE: <code>int</code> </p> <code>include_scratchpad</code> <p>Whether to include full reasoning history in each iteration.</p> <p> TYPE: <code>bool</code> </p> <code>tool_retry_count</code> <p>Number of retries for failed tool calls.</p> <p> TYPE: <code>int</code> </p> Example <p>config = ReActConfig( ...     max_iterations=15, ...     expose_reasoning=True, ...     termination_strategy=\"tool\", ... )</p>"},{"location":"api/workflows/react/#pydantic_agent.workflows.react.state.ReActState","title":"ReActState  <code>dataclass</code>","text":"<pre><code>ReActState(\n    task: str,\n    scratchpad: list[ScratchpadEntry] = list(),\n    current_thought: str | None = None,\n    current_action: str | None = None,\n    current_observation: str | None = None,\n    is_terminated: bool = False,\n    termination_reason: str | None = None,\n    final_answer: str | None = None,\n    iteration_token_counts: list[int] = list(),\n    total_tokens_used: int = 0,\n    compaction_count: int = 0,\n    consecutive_thought_count: int = 0,\n)\n</code></pre> <p>Internal state for ReAct workflow execution.</p> <p>This is stored in WorkflowState.context and tracks the full reasoning trace, termination status, and token usage.</p> ATTRIBUTE DESCRIPTION <code>task</code> <p>The original user task/prompt.</p> <p> TYPE: <code>str</code> </p> <code>scratchpad</code> <p>List of all Thought/Action/Observation entries.</p> <p> TYPE: <code>list[ScratchpadEntry]</code> </p> <code>current_thought</code> <p>The most recent thought generated.</p> <p> TYPE: <code>str | None</code> </p> <code>current_action</code> <p>The most recent action taken.</p> <p> TYPE: <code>str | None</code> </p> <code>current_observation</code> <p>The most recent observation received.</p> <p> TYPE: <code>str | None</code> </p> <code>is_terminated</code> <p>Whether the workflow has terminated.</p> <p> TYPE: <code>bool</code> </p> <code>termination_reason</code> <p>Why the workflow terminated.</p> <p> TYPE: <code>str | None</code> </p> <code>final_answer</code> <p>The final answer if workflow completed successfully.</p> <p> TYPE: <code>str | None</code> </p> <code>iteration_token_counts</code> <p>Token count for each iteration.</p> <p> TYPE: <code>list[int]</code> </p> <code>total_tokens_used</code> <p>Total tokens used across all iterations.</p> <p> TYPE: <code>int</code> </p> <code>compaction_count</code> <p>Number of times context was compacted.</p> <p> TYPE: <code>int</code> </p> <code>consecutive_thought_count</code> <p>Consecutive thoughts without action (for forcing action).</p> <p> TYPE: <code>int</code> </p>"},{"location":"api/workflows/react/#pydantic_agent.workflows.react.state.ReActState.add_thought","title":"add_thought","text":"<pre><code>add_thought(thought: str, token_count: int = 0) -&gt; None\n</code></pre> <p>Add a thought to the scratchpad.</p> PARAMETER DESCRIPTION <code>thought</code> <p>The reasoning/thought content.</p> <p> TYPE: <code>str</code> </p> <code>token_count</code> <p>Estimated token count.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> Source code in <code>src/pydantic_agent/workflows/react/state.py</code> <pre><code>def add_thought(self, thought: str, token_count: int = 0) -&gt; None:\n    \"\"\"Add a thought to the scratchpad.\n\n    Args:\n        thought: The reasoning/thought content.\n        token_count: Estimated token count.\n    \"\"\"\n    self.scratchpad.append(\n        ScratchpadEntry(\n            entry_type=\"thought\",\n            content=thought,\n            token_count=token_count,\n        )\n    )\n    self.current_thought = thought\n    self.consecutive_thought_count += 1\n</code></pre>"},{"location":"api/workflows/react/#pydantic_agent.workflows.react.state.ReActState.add_action","title":"add_action","text":"<pre><code>add_action(\n    action: str,\n    token_count: int = 0,\n    metadata: dict[str, Any] | None = None,\n) -&gt; None\n</code></pre> <p>Add an action to the scratchpad.</p> PARAMETER DESCRIPTION <code>action</code> <p>The action description (tool name and args).</p> <p> TYPE: <code>str</code> </p> <code>token_count</code> <p>Estimated token count.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>metadata</code> <p>Additional metadata (tool_name, tool_args, etc.).</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/pydantic_agent/workflows/react/state.py</code> <pre><code>def add_action(\n    self,\n    action: str,\n    token_count: int = 0,\n    metadata: dict[str, Any] | None = None,\n) -&gt; None:\n    \"\"\"Add an action to the scratchpad.\n\n    Args:\n        action: The action description (tool name and args).\n        token_count: Estimated token count.\n        metadata: Additional metadata (tool_name, tool_args, etc.).\n    \"\"\"\n    self.scratchpad.append(\n        ScratchpadEntry(\n            entry_type=\"action\",\n            content=action,\n            token_count=token_count,\n            metadata=metadata or {},\n        )\n    )\n    self.current_action = action\n    self.consecutive_thought_count = 0  # Reset on action\n</code></pre>"},{"location":"api/workflows/react/#pydantic_agent.workflows.react.state.ReActState.add_observation","title":"add_observation","text":"<pre><code>add_observation(\n    observation: str,\n    token_count: int = 0,\n    metadata: dict[str, Any] | None = None,\n) -&gt; None\n</code></pre> <p>Add an observation to the scratchpad.</p> PARAMETER DESCRIPTION <code>observation</code> <p>The tool result/observation content.</p> <p> TYPE: <code>str</code> </p> <code>token_count</code> <p>Estimated token count.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>metadata</code> <p>Additional metadata (tool_name, is_error, etc.).</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/pydantic_agent/workflows/react/state.py</code> <pre><code>def add_observation(\n    self,\n    observation: str,\n    token_count: int = 0,\n    metadata: dict[str, Any] | None = None,\n) -&gt; None:\n    \"\"\"Add an observation to the scratchpad.\n\n    Args:\n        observation: The tool result/observation content.\n        token_count: Estimated token count.\n        metadata: Additional metadata (tool_name, is_error, etc.).\n    \"\"\"\n    self.scratchpad.append(\n        ScratchpadEntry(\n            entry_type=\"observation\",\n            content=observation,\n            token_count=token_count,\n            metadata=metadata or {},\n        )\n    )\n    self.current_observation = observation\n</code></pre>"},{"location":"api/workflows/react/#pydantic_agent.workflows.react.state.ReActState.get_scratchpad_text","title":"get_scratchpad_text","text":"<pre><code>get_scratchpad_text(config: ReActConfig) -&gt; str\n</code></pre> <p>Format the scratchpad for prompt inclusion.</p> PARAMETER DESCRIPTION <code>config</code> <p>ReActConfig containing prefix settings.</p> <p> TYPE: <code>ReActConfig</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Formatted scratchpad text with prefixes.</p> Source code in <code>src/pydantic_agent/workflows/react/state.py</code> <pre><code>def get_scratchpad_text(self, config: ReActConfig) -&gt; str:\n    \"\"\"Format the scratchpad for prompt inclusion.\n\n    Args:\n        config: ReActConfig containing prefix settings.\n\n    Returns:\n        Formatted scratchpad text with prefixes.\n    \"\"\"\n    if not self.scratchpad:\n        return \"\"\n\n    lines = []\n    for entry in self.scratchpad:\n        prefix = {\n            \"thought\": config.reasoning_prefix,\n            \"action\": config.action_prefix,\n            \"observation\": config.observation_prefix,\n        }[entry.entry_type]\n        lines.append(f\"{prefix}{entry.content}\")\n\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"api/workflows/react/#pydantic_agent.workflows.react.state.ReActState.get_thoughts","title":"get_thoughts","text":"<pre><code>get_thoughts() -&gt; list[str]\n</code></pre> <p>Get all thoughts from the scratchpad.</p> Source code in <code>src/pydantic_agent/workflows/react/state.py</code> <pre><code>def get_thoughts(self) -&gt; list[str]:\n    \"\"\"Get all thoughts from the scratchpad.\"\"\"\n    return [e.content for e in self.scratchpad if e.entry_type == \"thought\"]\n</code></pre>"},{"location":"api/workflows/react/#pydantic_agent.workflows.react.state.ReActState.get_actions","title":"get_actions","text":"<pre><code>get_actions() -&gt; list[str]\n</code></pre> <p>Get all actions from the scratchpad.</p> Source code in <code>src/pydantic_agent/workflows/react/state.py</code> <pre><code>def get_actions(self) -&gt; list[str]:\n    \"\"\"Get all actions from the scratchpad.\"\"\"\n    return [e.content for e in self.scratchpad if e.entry_type == \"action\"]\n</code></pre>"},{"location":"api/workflows/react/#pydantic_agent.workflows.react.state.ReActState.get_observations","title":"get_observations","text":"<pre><code>get_observations() -&gt; list[str]\n</code></pre> <p>Get all observations from the scratchpad.</p> Source code in <code>src/pydantic_agent/workflows/react/state.py</code> <pre><code>def get_observations(self) -&gt; list[str]:\n    \"\"\"Get all observations from the scratchpad.\"\"\"\n    return [e.content for e in self.scratchpad if e.entry_type == \"observation\"]\n</code></pre>"},{"location":"api/workflows/react/#pydantic_agent.workflows.react.hooks.ReActHooks","title":"ReActHooks","text":"<pre><code>ReActHooks(\n    on_workflow_start: Callable[..., Awaitable[None] | None]\n    | None = None,\n    on_workflow_complete: Callable[\n        ..., Awaitable[None] | None\n    ]\n    | None = None,\n    on_workflow_error: Callable[..., Awaitable[None] | None]\n    | None = None,\n    on_step_start: Callable[..., Awaitable[None] | None]\n    | None = None,\n    on_step_complete: Callable[..., Awaitable[None] | None]\n    | None = None,\n    on_step_error: Callable[..., Awaitable[None] | None]\n    | None = None,\n    on_iteration_start: Callable[\n        ..., Awaitable[None] | None\n    ]\n    | None = None,\n    on_iteration_complete: Callable[\n        ..., Awaitable[None] | None\n    ]\n    | None = None,\n    on_thought: ThoughtHook | None = None,\n    on_action: ActionHook | None = None,\n    on_observation: ObservationHook | None = None,\n    on_compaction: CompactionHook | None = None,\n)\n</code></pre> <p>               Bases: <code>WorkflowHooks['ReActState', str]</code></p> <p>Extended hooks for ReAct workflow observability.</p> <p>Inherits the 8 base workflow hooks and adds 4 ReAct-specific hooks: - on_thought: Called when a reasoning trace is generated. - on_action: Called when a tool is about to be executed. - on_observation: Called when a tool result is received. - on_compaction: Called when context is compacted.</p> <p>All hooks can be sync or async functions.</p> Example <p>def log_thought(state: ReActState, thought: str) -&gt; None: ...     print(f\"Thought: {thought}\")</p> <p>hooks = ReActHooks(on_thought=log_thought) workflow = ReActWorkflow(agent, hooks=hooks)</p> <p>Initialize ReAct hooks.</p> PARAMETER DESCRIPTION <code>on_workflow_start</code> <p>Called when workflow begins.</p> <p> TYPE: <code>Callable[..., Awaitable[None] | None] | None</code> DEFAULT: <code>None</code> </p> <code>on_workflow_complete</code> <p>Called when workflow completes successfully.</p> <p> TYPE: <code>Callable[..., Awaitable[None] | None] | None</code> DEFAULT: <code>None</code> </p> <code>on_workflow_error</code> <p>Called when workflow fails.</p> <p> TYPE: <code>Callable[..., Awaitable[None] | None] | None</code> DEFAULT: <code>None</code> </p> <code>on_step_start</code> <p>Called before each step executes.</p> <p> TYPE: <code>Callable[..., Awaitable[None] | None] | None</code> DEFAULT: <code>None</code> </p> <code>on_step_complete</code> <p>Called after each step completes.</p> <p> TYPE: <code>Callable[..., Awaitable[None] | None] | None</code> DEFAULT: <code>None</code> </p> <code>on_step_error</code> <p>Called when a step fails.</p> <p> TYPE: <code>Callable[..., Awaitable[None] | None] | None</code> DEFAULT: <code>None</code> </p> <code>on_iteration_start</code> <p>Called at the start of each iteration.</p> <p> TYPE: <code>Callable[..., Awaitable[None] | None] | None</code> DEFAULT: <code>None</code> </p> <code>on_iteration_complete</code> <p>Called at the end of each iteration.</p> <p> TYPE: <code>Callable[..., Awaitable[None] | None] | None</code> DEFAULT: <code>None</code> </p> <code>on_thought</code> <p>Called when a thought/reasoning is generated.</p> <p> TYPE: <code>ThoughtHook | None</code> DEFAULT: <code>None</code> </p> <code>on_action</code> <p>Called when a tool is about to execute.</p> <p> TYPE: <code>ActionHook | None</code> DEFAULT: <code>None</code> </p> <code>on_observation</code> <p>Called when a tool result is received.</p> <p> TYPE: <code>ObservationHook | None</code> DEFAULT: <code>None</code> </p> <code>on_compaction</code> <p>Called when context is compacted.</p> <p> TYPE: <code>CompactionHook | None</code> DEFAULT: <code>None</code> </p> Source code in <code>src/pydantic_agent/workflows/react/hooks.py</code> <pre><code>def __init__(\n    self,\n    # Inherited from WorkflowHooks\n    on_workflow_start: Callable[..., Awaitable[None] | None] | None = None,\n    on_workflow_complete: Callable[..., Awaitable[None] | None] | None = None,\n    on_workflow_error: Callable[..., Awaitable[None] | None] | None = None,\n    on_step_start: Callable[..., Awaitable[None] | None] | None = None,\n    on_step_complete: Callable[..., Awaitable[None] | None] | None = None,\n    on_step_error: Callable[..., Awaitable[None] | None] | None = None,\n    on_iteration_start: Callable[..., Awaitable[None] | None] | None = None,\n    on_iteration_complete: Callable[..., Awaitable[None] | None] | None = None,\n    # ReAct-specific hooks\n    on_thought: ThoughtHook | None = None,\n    on_action: ActionHook | None = None,\n    on_observation: ObservationHook | None = None,\n    on_compaction: CompactionHook | None = None,\n) -&gt; None:\n    \"\"\"Initialize ReAct hooks.\n\n    Args:\n        on_workflow_start: Called when workflow begins.\n        on_workflow_complete: Called when workflow completes successfully.\n        on_workflow_error: Called when workflow fails.\n        on_step_start: Called before each step executes.\n        on_step_complete: Called after each step completes.\n        on_step_error: Called when a step fails.\n        on_iteration_start: Called at the start of each iteration.\n        on_iteration_complete: Called at the end of each iteration.\n        on_thought: Called when a thought/reasoning is generated.\n        on_action: Called when a tool is about to execute.\n        on_observation: Called when a tool result is received.\n        on_compaction: Called when context is compacted.\n    \"\"\"\n    super().__init__(\n        on_workflow_start=on_workflow_start,\n        on_workflow_complete=on_workflow_complete,\n        on_workflow_error=on_workflow_error,\n        on_step_start=on_step_start,\n        on_step_complete=on_step_complete,\n        on_step_error=on_step_error,\n        on_iteration_start=on_iteration_start,\n        on_iteration_complete=on_iteration_complete,\n    )\n    self.on_thought = on_thought\n    self.on_action = on_action\n    self.on_observation = on_observation\n    self.on_compaction = on_compaction\n</code></pre>"},{"location":"api/workflows/react/#pydantic_agent.workflows.react.hooks.ReActHooks.trigger_thought","title":"trigger_thought  <code>async</code>","text":"<pre><code>trigger_thought(state: ReActState, thought: str) -&gt; None\n</code></pre> <p>Trigger the on_thought hook.</p> PARAMETER DESCRIPTION <code>state</code> <p>Current ReAct state.</p> <p> TYPE: <code>ReActState</code> </p> <code>thought</code> <p>The generated thought/reasoning.</p> <p> TYPE: <code>str</code> </p> Source code in <code>src/pydantic_agent/workflows/react/hooks.py</code> <pre><code>async def trigger_thought(self, state: ReActState, thought: str) -&gt; None:\n    \"\"\"Trigger the on_thought hook.\n\n    Args:\n        state: Current ReAct state.\n        thought: The generated thought/reasoning.\n    \"\"\"\n    if self.on_thought:\n        await self._call_hook(self.on_thought, state, thought)\n</code></pre>"},{"location":"api/workflows/react/#pydantic_agent.workflows.react.hooks.ReActHooks.trigger_action","title":"trigger_action  <code>async</code>","text":"<pre><code>trigger_action(\n    state: ReActState,\n    tool_name: str,\n    tool_args: dict[str, Any],\n) -&gt; None\n</code></pre> <p>Trigger the on_action hook.</p> PARAMETER DESCRIPTION <code>state</code> <p>Current ReAct state.</p> <p> TYPE: <code>ReActState</code> </p> <code>tool_name</code> <p>Name of the tool being called.</p> <p> TYPE: <code>str</code> </p> <code>tool_args</code> <p>Arguments passed to the tool.</p> <p> TYPE: <code>dict[str, Any]</code> </p> Source code in <code>src/pydantic_agent/workflows/react/hooks.py</code> <pre><code>async def trigger_action(\n    self,\n    state: ReActState,\n    tool_name: str,\n    tool_args: dict[str, Any],\n) -&gt; None:\n    \"\"\"Trigger the on_action hook.\n\n    Args:\n        state: Current ReAct state.\n        tool_name: Name of the tool being called.\n        tool_args: Arguments passed to the tool.\n    \"\"\"\n    if self.on_action:\n        await self._call_hook(self.on_action, state, tool_name, tool_args)\n</code></pre>"},{"location":"api/workflows/react/#pydantic_agent.workflows.react.hooks.ReActHooks.trigger_observation","title":"trigger_observation  <code>async</code>","text":"<pre><code>trigger_observation(\n    state: ReActState,\n    observation: str,\n    is_error: bool = False,\n) -&gt; None\n</code></pre> <p>Trigger the on_observation hook.</p> PARAMETER DESCRIPTION <code>state</code> <p>Current ReAct state.</p> <p> TYPE: <code>ReActState</code> </p> <code>observation</code> <p>The tool result or error message.</p> <p> TYPE: <code>str</code> </p> <code>is_error</code> <p>Whether this observation is an error.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>src/pydantic_agent/workflows/react/hooks.py</code> <pre><code>async def trigger_observation(\n    self,\n    state: ReActState,\n    observation: str,\n    is_error: bool = False,\n) -&gt; None:\n    \"\"\"Trigger the on_observation hook.\n\n    Args:\n        state: Current ReAct state.\n        observation: The tool result or error message.\n        is_error: Whether this observation is an error.\n    \"\"\"\n    if self.on_observation:\n        await self._call_hook(self.on_observation, state, observation, is_error)\n</code></pre>"},{"location":"api/workflows/react/#pydantic_agent.workflows.react.hooks.ReActHooks.trigger_compaction","title":"trigger_compaction  <code>async</code>","text":"<pre><code>trigger_compaction(result: CompactionResult) -&gt; None\n</code></pre> <p>Trigger the on_compaction hook.</p> PARAMETER DESCRIPTION <code>result</code> <p>The compaction result with details.</p> <p> TYPE: <code>CompactionResult</code> </p> Source code in <code>src/pydantic_agent/workflows/react/hooks.py</code> <pre><code>async def trigger_compaction(self, result: CompactionResult) -&gt; None:\n    \"\"\"Trigger the on_compaction hook.\n\n    Args:\n        result: The compaction result with details.\n    \"\"\"\n    if self.on_compaction:\n        await self._call_hook(self.on_compaction, result)\n</code></pre>"},{"location":"concepts/","title":"Concepts","text":"<p>Deep dives into the architecture and design of Pydantic Agent.</p>"},{"location":"concepts/#overview","title":"Overview","text":"<ul> <li> <p>:material-sitemap: Architecture Overview</p> <p>Understand how all the components fit together.</p> <p>:octicons-arrow-right-24: Architecture</p> </li> <li> <p>:material-reload: Agent Execution Loop</p> <p>How agents process messages and call tools.</p> <p>:octicons-arrow-right-24: Execution Loop</p> </li> <li> <p>:material-compress: Context Compaction Strategies</p> <p>Deep dive into the 5 compaction strategies.</p> <p>:octicons-arrow-right-24: Compaction Strategies</p> </li> <li> <p>:material-state-machine: Workflow Patterns</p> <p>ReAct, Plan-Execute, and other orchestration patterns.</p> <p>:octicons-arrow-right-24: Workflow Patterns</p> </li> </ul>"},{"location":"concepts/#key-concepts","title":"Key Concepts","text":""},{"location":"concepts/#agent-as-a-thin-wrapper","title":"Agent as a Thin Wrapper","text":"<p>Pydantic Agent wraps pydantic-ai with additional infrastructure:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                  Pydantic Agent                      \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502\n\u2502  \u2502              pydantic-ai Agent               \u2502    \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502\n\u2502  + Context Management (message tracking, compaction)\u2502\n\u2502  + Token Tracking (usage, cost estimation)          \u2502\n\u2502  + Configuration (settings, env vars, files)        \u2502\n\u2502  + Observability (logging, tracing, OTel)          \u2502\n\u2502  + Error Handling (retry, circuit breaker)          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"concepts/#configuration-priority","title":"Configuration Priority","text":"<p>Settings load from multiple sources:</p> <pre><code>1. Constructor arguments     (highest priority)\n2. Environment variables     AGENTS_*\n3. .env file                 project-specific\n4. ~/agents.env              user-wide defaults\n5. config.toml / config.yaml file-based config\n6. Default values            (lowest priority)\n</code></pre>"},{"location":"concepts/#built-in-vs-standalone-components","title":"Built-in vs. Standalone Components","text":"<p>Most features work both integrated and standalone:</p> Feature Built-in (Agent) Standalone Context <code>agent.get_messages()</code> <code>ContextManager</code> Tokens <code>agent.get_usage()</code> <code>TokenCounter</code>, <code>UsageTracker</code> Cost <code>agent.get_cost()</code> <code>CostEstimator</code> Logging Automatic <code>setup_logging()</code>"},{"location":"concepts/#workflows-vs-agent-runs","title":"Workflows vs. Agent Runs","text":"Aspect Agent Run Workflow Scope Single request Multi-step task State Context maintained Full state tracking Control Limited Fine-grained Use case Chat, Q&amp;A Research, analysis"},{"location":"concepts/architecture/","title":"Architecture Overview","text":"<p>Pydantic Agent is a thin wrapper around pydantic-ai that adds enterprise-grade infrastructure.</p>"},{"location":"concepts/architecture/#high-level-architecture","title":"High-Level Architecture","text":"<pre><code>graph TB\n    subgraph \"User Application\"\n        APP[Application Code]\n    end\n\n    subgraph \"Pydantic Agent\"\n        AGENT[Agent]\n        CONFIG[AgentSettings]\n\n        subgraph \"Core Features\"\n            CTX[ContextManager]\n            TOK[TokenCounter]\n            TRACK[UsageTracker]\n            COST[CostEstimator]\n        end\n\n        subgraph \"Extensions\"\n            WORK[Workflows]\n            MCP[MCP Client]\n            TOOLS[Built-in Tools]\n        end\n\n        subgraph \"Infrastructure\"\n            LOG[Logging]\n            TRACE[Tracing]\n            ERR[Error Handling]\n        end\n    end\n\n    subgraph \"External\"\n        PAI[pydantic-ai]\n        LLM[LLM Provider]\n        MCPS[MCP Servers]\n    end\n\n    APP --&gt; AGENT\n    AGENT --&gt; CONFIG\n    AGENT --&gt; CTX\n    AGENT --&gt; TOK\n    AGENT --&gt; TRACK\n    AGENT --&gt; COST\n    AGENT --&gt; PAI\n    PAI --&gt; LLM\n    WORK --&gt; AGENT\n    MCP --&gt; MCPS\n    TOOLS --&gt; AGENT\n    LOG --&gt; AGENT\n    TRACE --&gt; AGENT\n    ERR --&gt; AGENT</code></pre>"},{"location":"concepts/architecture/#module-structure","title":"Module Structure","text":"<pre><code>src/pydantic_agent/\n\u251c\u2500\u2500 agent/           # Core agent (wraps pydantic-ai)\n\u2502   \u251c\u2500\u2500 core.py      # Agent class\n\u2502   \u251c\u2500\u2500 config.py    # AgentConfig\n\u2502   \u2514\u2500\u2500 result.py    # AgentResult\n\u2502\n\u251c\u2500\u2500 config/          # Configuration system\n\u2502   \u251c\u2500\u2500 settings.py  # AgentSettings (root)\n\u2502   \u251c\u2500\u2500 model_backend.py\n\u2502   \u251c\u2500\u2500 logging_config.py\n\u2502   \u2514\u2500\u2500 ...\n\u2502\n\u251c\u2500\u2500 context/         # Context window management\n\u2502   \u251c\u2500\u2500 manager.py   # ContextManager\n\u2502   \u251c\u2500\u2500 config.py    # CompactionConfig\n\u2502   \u2514\u2500\u2500 compaction/  # 5 strategies\n\u2502\n\u251c\u2500\u2500 tokens/          # Token counting &amp; cost\n\u2502   \u251c\u2500\u2500 counter.py   # TokenCounter\n\u2502   \u251c\u2500\u2500 tracker.py   # UsageTracker\n\u2502   \u2514\u2500\u2500 cost.py      # CostEstimator\n\u2502\n\u251c\u2500\u2500 workflows/       # Workflow orchestration\n\u2502   \u251c\u2500\u2500 base.py      # Workflow ABC\n\u2502   \u251c\u2500\u2500 config.py    # WorkflowConfig\n\u2502   \u2514\u2500\u2500 react/       # ReAct implementation\n\u2502\n\u251c\u2500\u2500 tools/           # Built-in tools\n\u2502   \u251c\u2500\u2500 filesystem/  # File operations\n\u2502   \u251c\u2500\u2500 bash.py      # Shell commands\n\u2502   \u251c\u2500\u2500 glob.py      # Pattern matching\n\u2502   \u2514\u2500\u2500 grep.py      # Content search\n\u2502\n\u251c\u2500\u2500 mcp/             # MCP integration\n\u2502   \u251c\u2500\u2500 client.py    # MCPClientManager\n\u2502   \u2514\u2500\u2500 config.py    # MCPServerConfig\n\u2502\n\u251c\u2500\u2500 backends/        # Model backends\n\u2502   \u251c\u2500\u2500 openai_compat.py\n\u2502   \u2514\u2500\u2500 profiles.py\n\u2502\n\u251c\u2500\u2500 observability/   # Logging &amp; tracing\n\u2502   \u251c\u2500\u2500 logging.py\n\u2502   \u251c\u2500\u2500 tracing.py\n\u2502   \u2514\u2500\u2500 otel.py\n\u2502\n\u2514\u2500\u2500 errors/          # Error handling\n    \u251c\u2500\u2500 exceptions.py\n    \u251c\u2500\u2500 circuit_breaker.py\n    \u2514\u2500\u2500 retry.py\n</code></pre>"},{"location":"concepts/architecture/#component-relationships","title":"Component Relationships","text":""},{"location":"concepts/architecture/#agent-core","title":"Agent Core","text":"<p>The <code>Agent</code> class is the central component:</p> <pre><code>class Agent[DepsT, OutputT]:\n    # Delegates to pydantic-ai\n    _agent: PydanticAgent\n\n    # Manages context\n    context_manager: ContextManager | None\n\n    # Tracks tokens\n    token_counter: TokenCounter\n    usage_tracker: UsageTracker\n    cost_estimator: CostEstimator\n\n    # Configuration\n    config: AgentConfig\n    settings: AgentSettings\n</code></pre>"},{"location":"concepts/architecture/#context-flow","title":"Context Flow","text":"<pre><code>sequenceDiagram\n    participant App\n    participant Agent\n    participant Context\n    participant PydanticAI\n    participant LLM\n\n    App-&gt;&gt;Agent: run(prompt)\n    Agent-&gt;&gt;Context: get_messages()\n    Context--&gt;&gt;Agent: history\n    Agent-&gt;&gt;PydanticAI: run(prompt + history)\n    PydanticAI-&gt;&gt;LLM: API call\n    LLM--&gt;&gt;PydanticAI: response\n    PydanticAI--&gt;&gt;Agent: result\n    Agent-&gt;&gt;Context: add_messages(new)\n    Agent-&gt;&gt;Context: check threshold\n    alt Should Compact\n        Agent-&gt;&gt;Context: compact()\n    end\n    Agent--&gt;&gt;App: AgentResult</code></pre>"},{"location":"concepts/architecture/#workflow-orchestration","title":"Workflow Orchestration","text":"<pre><code>graph LR\n    subgraph \"Workflow Layer\"\n        WF[Workflow]\n        REACT[ReActWorkflow]\n    end\n\n    subgraph \"Agent Layer\"\n        AGENT[Agent]\n    end\n\n    subgraph \"Execution Layer\"\n        PAI[pydantic-ai]\n        TOOLS[Tools]\n    end\n\n    WF --&gt; AGENT\n    REACT --&gt; AGENT\n    AGENT --&gt; PAI\n    PAI --&gt; TOOLS</code></pre>"},{"location":"concepts/architecture/#design-principles","title":"Design Principles","text":""},{"location":"concepts/architecture/#1-thin-wrapper","title":"1. Thin Wrapper","text":"<p>Pydantic Agent doesn't reinvent pydantic-ai; it extends it:</p> <ul> <li>Core agent logic delegates to pydantic-ai</li> <li>Infrastructure layers are composable</li> <li>Components work standalone or integrated</li> </ul>"},{"location":"concepts/architecture/#2-configuration-layering","title":"2. Configuration Layering","text":"<p>Multiple configuration sources with clear priority:</p> <pre><code># Priority: constructor &gt; env &gt; .env &gt; file &gt; default\nsettings = AgentSettings()  # Loads from all sources\nagent = Agent(\"gpt-4o\", settings=settings)  # Constructor overrides\n</code></pre>"},{"location":"concepts/architecture/#3-facade-pattern","title":"3. Facade Pattern","text":"<p>Agent provides a simplified interface to complex subsystems:</p> <pre><code># Instead of:\ncounter = TokenCounter()\ntracker = UsageTracker()\ncount = counter.count(text)\ntracker.record_usage(...)\n\n# Just use:\nagent.get_token_count(text)\nagent.get_usage()\n</code></pre>"},{"location":"concepts/architecture/#4-strategy-pattern","title":"4. Strategy Pattern","text":"<p>Interchangeable algorithms for compaction:</p> <pre><code># Same interface, different strategies\nconfig = CompactionConfig(strategy=\"sliding_window\")\nconfig = CompactionConfig(strategy=\"summarize_older\")\nconfig = CompactionConfig(strategy=\"hybrid\")\n</code></pre>"},{"location":"concepts/architecture/#5-hooks-for-extensibility","title":"5. Hooks for Extensibility","text":"<p>Observable lifecycle events:</p> <pre><code>hooks = WorkflowHooks(\n    on_step_start=my_logger,\n    on_step_complete=my_metrics,\n)\n</code></pre>"},{"location":"concepts/architecture/#data-flow","title":"Data Flow","text":""},{"location":"concepts/architecture/#request-lifecycle","title":"Request Lifecycle","text":"<ol> <li>Input - User provides prompt</li> <li>Context - Messages retrieved from history</li> <li>Execution - pydantic-ai runs with tools</li> <li>Tracking - Usage recorded</li> <li>Storage - New messages added to context</li> <li>Compaction - Context pruned if needed</li> <li>Output - Result returned to user</li> </ol>"},{"location":"concepts/architecture/#token-tracking-flow","title":"Token Tracking Flow","text":"<pre><code>Agent.run()\n  \u2192 pydantic-ai execution\n  \u2192 Extract usage from response\n  \u2192 UsageTracker.record_usage()\n  \u2192 CostEstimator.estimate()\n  \u2192 TokenUsage/CostBreakdown available\n</code></pre>"},{"location":"concepts/architecture/#extension-points","title":"Extension Points","text":""},{"location":"concepts/architecture/#custom-tools","title":"Custom Tools","text":"<pre><code>@agent.tool\ndef my_tool(param: str) -&gt; str:\n    return \"result\"\n</code></pre>"},{"location":"concepts/architecture/#custom-workflows","title":"Custom Workflows","text":"<pre><code>class MyWorkflow(Workflow[None, str, dict]):\n    @property\n    def name(self) -&gt; str:\n        return \"my_workflow\"\n\n    async def _execute(self, prompt, state, deps):\n        # Custom logic\n        pass\n</code></pre>"},{"location":"concepts/architecture/#custom-compaction","title":"Custom Compaction","text":"<pre><code>class MyStrategy(CompactionStrategy):\n    def compact(self, messages, config):\n        # Custom compaction logic\n        pass\n</code></pre>"},{"location":"concepts/compaction-strategies/","title":"Context Compaction Strategies","text":"<p>Deep dive into the 5 compaction strategies available in Pydantic Agent.</p>"},{"location":"concepts/compaction-strategies/#overview","title":"Overview","text":"<p>As conversations grow, context windows fill up. Compaction strategies manage this by intelligently reducing message history while preserving important information.</p>"},{"location":"concepts/compaction-strategies/#strategy-comparison","title":"Strategy Comparison","text":"Strategy Speed Quality Best For <code>sliding_window</code> Fast Basic Simple chats <code>summarize_older</code> Slow High Long research <code>selective_pruning</code> Fast Good Tool-heavy work <code>importance_scoring</code> Slow High Mixed content <code>hybrid</code> Medium High General use"},{"location":"concepts/compaction-strategies/#1-sliding-window","title":"1. Sliding Window","text":"<p>Removes oldest messages beyond a threshold.</p>"},{"location":"concepts/compaction-strategies/#how-it-works","title":"How It Works","text":"<pre><code>graph LR\n    A[Messages] --&gt; B{Within Threshold?}\n    B --&gt;|Yes| C[Keep]\n    B --&gt;|No| D[Remove Oldest]\n    D --&gt; E[Until Threshold Met]</code></pre>"},{"location":"concepts/compaction-strategies/#configuration","title":"Configuration","text":"<pre><code>from pydantic_agent import CompactionConfig\n\nconfig = CompactionConfig(\n    strategy=\"sliding_window\",\n    trigger_threshold_tokens=100000,\n    target_tokens=80000,\n    preserve_recent_turns=10,\n    preserve_system_prompt=True,\n)\n</code></pre>"},{"location":"concepts/compaction-strategies/#behavior","title":"Behavior","text":"<ul> <li>Keeps: System prompt + N most recent turns</li> <li>Removes: Oldest messages until target reached</li> <li>Speed: Very fast (no LLM calls)</li> </ul>"},{"location":"concepts/compaction-strategies/#best-for","title":"Best For","text":"<ul> <li>Chat applications</li> <li>When recent context is most important</li> <li>High-volume, fast conversations</li> </ul>"},{"location":"concepts/compaction-strategies/#example","title":"Example","text":"<pre><code>Before: [sys, m1, m2, m3, m4, m5, m6, m7, m8, m9, m10]\nAfter:  [sys, m6, m7, m8, m9, m10]  # Kept last 5 turns\n</code></pre>"},{"location":"concepts/compaction-strategies/#2-summarize-older","title":"2. Summarize Older","text":"<p>Uses an LLM to summarize older messages.</p>"},{"location":"concepts/compaction-strategies/#how-it-works_1","title":"How It Works","text":"<pre><code>graph TD\n    A[Messages] --&gt; B[Split: Recent vs Older]\n    B --&gt; C[Recent: Keep As-Is]\n    B --&gt; D[Older: Send to LLM]\n    D --&gt; E[LLM Summary]\n    E --&gt; F[Replace Older with Summary]\n    C --&gt; G[Final Context]\n    F --&gt; G</code></pre>"},{"location":"concepts/compaction-strategies/#configuration_1","title":"Configuration","text":"<pre><code>config = CompactionConfig(\n    strategy=\"summarize_older\",\n    preserve_recent_turns=5,\n    summarization_model=\"gpt-4o-mini\",  # Or \"same\" for current model\n)\n</code></pre>"},{"location":"concepts/compaction-strategies/#behavior_1","title":"Behavior","text":"<ul> <li>Keeps: System prompt + recent turns + summary</li> <li>Summarizes: All messages before recent turns</li> <li>Speed: Slower (requires LLM call)</li> </ul>"},{"location":"concepts/compaction-strategies/#best-for_1","title":"Best For","text":"<ul> <li>Research and analysis tasks</li> <li>When historical context matters</li> <li>Long-running conversations</li> </ul>"},{"location":"concepts/compaction-strategies/#example_1","title":"Example","text":"<pre><code>Before: [sys, m1, m2, m3, m4, m5, m6, m7, m8]\nAfter:  [sys, summary(\"m1-m5\"), m6, m7, m8]\n</code></pre>"},{"location":"concepts/compaction-strategies/#3-selective-pruning","title":"3. Selective Pruning","text":"<p>Removes completed tool call/result pairs.</p>"},{"location":"concepts/compaction-strategies/#how-it-works_2","title":"How It Works","text":"<pre><code>graph TD\n    A[Messages] --&gt; B{Is Tool Call?}\n    B --&gt;|Yes| C{Has Matching Result?}\n    C --&gt;|Yes| D{Still Relevant?}\n    D --&gt;|No| E[Remove Pair]\n    D --&gt;|Yes| F[Keep]\n    B --&gt;|No| F\n    C --&gt;|No| F</code></pre>"},{"location":"concepts/compaction-strategies/#configuration_2","title":"Configuration","text":"<pre><code>config = CompactionConfig(\n    strategy=\"selective_pruning\",\n    preserve_recent_turns=3,\n)\n</code></pre>"},{"location":"concepts/compaction-strategies/#behavior_2","title":"Behavior","text":"<ul> <li>Keeps: All non-tool messages + recent tool calls</li> <li>Removes: Old tool call/result pairs</li> <li>Speed: Fast (pattern matching)</li> </ul>"},{"location":"concepts/compaction-strategies/#best-for_2","title":"Best For","text":"<ul> <li>Tool-heavy workflows</li> <li>Coding assistants</li> <li>When tool results become stale</li> </ul>"},{"location":"concepts/compaction-strategies/#example_2","title":"Example","text":"<pre><code>Before: [sys, user, tool_call:read_file, tool_result:content, assistant, ...]\nAfter:  [sys, user, assistant, ...]  # Tool pair removed\n</code></pre>"},{"location":"concepts/compaction-strategies/#4-importance-scoring","title":"4. Importance Scoring","text":"<p>Uses LLM to score and prune least important messages.</p>"},{"location":"concepts/compaction-strategies/#how-it-works_3","title":"How It Works","text":"<pre><code>graph TD\n    A[Messages] --&gt; B[Score Each Message]\n    B --&gt; C[LLM Evaluates Importance]\n    C --&gt; D[Rank by Score]\n    D --&gt; E{Above Threshold?}\n    E --&gt;|Yes| F[Keep]\n    E --&gt;|No| G[Remove]</code></pre>"},{"location":"concepts/compaction-strategies/#configuration_3","title":"Configuration","text":"<pre><code>config = CompactionConfig(\n    strategy=\"importance_scoring\",\n    preserve_recent_turns=3,\n)\n</code></pre>"},{"location":"concepts/compaction-strategies/#behavior_3","title":"Behavior","text":"<ul> <li>Scores: Each message for relevance</li> <li>Keeps: High-importance messages</li> <li>Removes: Low-importance messages</li> <li>Speed: Slowest (multiple LLM calls)</li> </ul>"},{"location":"concepts/compaction-strategies/#best-for_3","title":"Best For","text":"<ul> <li>Complex conversations with varying importance</li> <li>When you can't lose any critical info</li> <li>Quality over speed</li> </ul>"},{"location":"concepts/compaction-strategies/#example_3","title":"Example","text":"<pre><code>Scores: [sys:1.0, m1:0.3, m2:0.9, m3:0.2, m4:0.8, m5:0.1]\nAfter:  [sys, m2, m4]  # Kept high-scoring messages\n</code></pre>"},{"location":"concepts/compaction-strategies/#5-hybrid","title":"5. Hybrid","text":"<p>Combines multiple strategies in sequence.</p>"},{"location":"concepts/compaction-strategies/#how-it-works_4","title":"How It Works","text":"<pre><code>graph TD\n    A[Messages] --&gt; B[Selective Pruning]\n    B --&gt; C{At Target?}\n    C --&gt;|Yes| D[Done]\n    C --&gt;|No| E[Sliding Window]\n    E --&gt; F{At Target?}\n    F --&gt;|Yes| D\n    F --&gt;|No| G[Summarize Remaining]\n    G --&gt; D</code></pre>"},{"location":"concepts/compaction-strategies/#configuration_4","title":"Configuration","text":"<pre><code>config = CompactionConfig(\n    strategy=\"hybrid\",\n    preserve_recent_turns=5,\n)\n</code></pre>"},{"location":"concepts/compaction-strategies/#behavior_4","title":"Behavior","text":"<ol> <li>First: Remove old tool pairs (fast)</li> <li>Then: Apply sliding window (fast)</li> <li>Finally: Summarize if still over (slow)</li> </ol>"},{"location":"concepts/compaction-strategies/#best-for_4","title":"Best For","text":"<ul> <li>General-purpose use</li> <li>Unknown conversation patterns</li> <li>Balance of speed and quality</li> </ul>"},{"location":"concepts/compaction-strategies/#choosing-a-strategy","title":"Choosing a Strategy","text":""},{"location":"concepts/compaction-strategies/#decision-tree","title":"Decision Tree","text":"<pre><code>graph TD\n    A[Choose Strategy] --&gt; B{Tool-heavy?}\n    B --&gt;|Yes| C[selective_pruning]\n    B --&gt;|No| D{History Important?}\n    D --&gt;|Yes| E{Speed Critical?}\n    E --&gt;|Yes| F[hybrid]\n    E --&gt;|No| G[summarize_older]\n    D --&gt;|No| H[sliding_window]</code></pre>"},{"location":"concepts/compaction-strategies/#by-use-case","title":"By Use Case","text":"Use Case Recommended Chatbot <code>sliding_window</code> Code assistant <code>selective_pruning</code> Research agent <code>summarize_older</code> General assistant <code>hybrid</code> Complex analysis <code>importance_scoring</code>"},{"location":"concepts/compaction-strategies/#configuration-options","title":"Configuration Options","text":""},{"location":"concepts/compaction-strategies/#common-options","title":"Common Options","text":"Option Type Default Description <code>strategy</code> str <code>\"sliding_window\"</code> Strategy name <code>trigger_threshold_tokens</code> int 100000 When to compact <code>target_tokens</code> int 80000 Target after compaction <code>preserve_recent_turns</code> int 10 Always keep N recent <code>preserve_system_prompt</code> bool True Always keep system"},{"location":"concepts/compaction-strategies/#strategy-specific","title":"Strategy-Specific","text":"Option Strategy Description <code>summarization_model</code> summarize_older Model for summaries"},{"location":"concepts/compaction-strategies/#performance-impact","title":"Performance Impact","text":""},{"location":"concepts/compaction-strategies/#token-savings","title":"Token Savings","text":"<pre><code># Before compaction\nstate = agent.get_context_state()\nprint(f\"Before: {state.token_count} tokens\")\n\n# After compaction\nresult = await agent.compact()\nprint(f\"After: {result.tokens_after} tokens\")\nprint(f\"Saved: {result.tokens_before - result.tokens_after} tokens\")\n</code></pre>"},{"location":"concepts/compaction-strategies/#cost-implications","title":"Cost Implications","text":"<ul> <li>sliding_window: No additional cost</li> <li>selective_pruning: No additional cost</li> <li>summarize_older: Cost of summary generation</li> <li>importance_scoring: Cost of scoring calls</li> <li>hybrid: Variable based on what's needed</li> </ul>"},{"location":"concepts/compaction-strategies/#custom-strategies","title":"Custom Strategies","text":"<p>Implement your own strategy:</p> <pre><code>from pydantic_agent.context.compaction import CompactionStrategy\n\nclass MyStrategy(CompactionStrategy):\n    def compact(self, messages, config):\n        # Your compaction logic\n        return compacted_messages, removed_count\n</code></pre>"},{"location":"concepts/execution-loop/","title":"Agent Execution Loop","text":"<p>Understanding how agents process messages, call tools, and manage state.</p>"},{"location":"concepts/execution-loop/#overview","title":"Overview","text":"<p>The agent execution loop handles:</p> <ol> <li>Message preparation (context + new prompt)</li> <li>Model inference (via pydantic-ai)</li> <li>Tool execution (if requested)</li> <li>Response processing</li> <li>State updates (context, usage tracking)</li> </ol>"},{"location":"concepts/execution-loop/#basic-execution-flow","title":"Basic Execution Flow","text":"<pre><code>sequenceDiagram\n    participant User\n    participant Agent\n    participant Context\n    participant PydanticAI\n    participant Model\n    participant Tools\n\n    User-&gt;&gt;Agent: run(prompt)\n    Agent-&gt;&gt;Context: get_messages()\n    Context--&gt;&gt;Agent: message_history\n\n    loop Until complete or max_iterations\n        Agent-&gt;&gt;PydanticAI: run(messages)\n        PydanticAI-&gt;&gt;Model: API request\n        Model--&gt;&gt;PydanticAI: response\n\n        alt Has tool calls\n            PydanticAI-&gt;&gt;Tools: execute_tool()\n            Tools--&gt;&gt;PydanticAI: tool_result\n            Note over PydanticAI: Add result to messages\n        else No tool calls\n            Note over PydanticAI: Response complete\n        end\n    end\n\n    PydanticAI--&gt;&gt;Agent: RunResult\n    Agent-&gt;&gt;Context: add_messages(new)\n    Agent-&gt;&gt;Agent: track_usage()\n    Agent--&gt;&gt;User: AgentResult</code></pre>"},{"location":"concepts/execution-loop/#iteration-behavior","title":"Iteration Behavior","text":""},{"location":"concepts/execution-loop/#tool-calling-loop","title":"Tool Calling Loop","text":"<p>When the model requests tools, execution continues:</p> <pre><code># Simplified execution logic\nfor iteration in range(max_iterations):\n    response = await model.complete(messages)\n\n    if response.has_tool_calls:\n        for tool_call in response.tool_calls:\n            result = await execute_tool(tool_call)\n            messages.append(tool_result_message(result))\n    else:\n        # No more tool calls, done\n        return response.content\n</code></pre>"},{"location":"concepts/execution-loop/#max-iterations","title":"Max Iterations","text":"<p>Prevents infinite loops:</p> <pre><code>config = AgentConfig(max_iterations=10)  # Default\n\n# If reached:\n# - Execution stops\n# - Current response returned\n# - Warning logged\n</code></pre>"},{"location":"concepts/execution-loop/#context-integration","title":"Context Integration","text":""},{"location":"concepts/execution-loop/#message-history","title":"Message History","text":"<p>Context is automatically included:</p> <pre><code># Before each run\nmessages = [\n    system_prompt,\n    *context_manager.get_messages(),  # History\n    new_user_message,                   # Current prompt\n]\n</code></pre>"},{"location":"concepts/execution-loop/#after-execution","title":"After Execution","text":"<p>New messages are added:</p> <pre><code># After run completes\ncontext_manager.add_messages([\n    user_message,\n    assistant_response,\n    *tool_messages,  # If any\n])\n</code></pre>"},{"location":"concepts/execution-loop/#token-tracking","title":"Token Tracking","text":""},{"location":"concepts/execution-loop/#per-request-tracking","title":"Per-Request Tracking","text":"<pre><code># After each model call\nusage_tracker.record_usage(\n    prompt_tokens=response.usage.prompt_tokens,\n    completion_tokens=response.usage.completion_tokens,\n    model=model_name,\n)\n</code></pre>"},{"location":"concepts/execution-loop/#aggregate-access","title":"Aggregate Access","text":"<pre><code># Available after run\nusage = agent.get_usage()      # TokenUsage\ncost = agent.get_cost()        # float\nhistory = agent.get_usage_history()  # list[UsageRecord]\n</code></pre>"},{"location":"concepts/execution-loop/#auto-compaction","title":"Auto-Compaction","text":""},{"location":"concepts/execution-loop/#threshold-check","title":"Threshold Check","text":"<pre><code># After adding messages\nif config.auto_compact and context_manager.should_compact():\n    await context_manager.compact()\n</code></pre>"},{"location":"concepts/execution-loop/#compaction-triggers","title":"Compaction Triggers","text":"<pre><code># should_compact() returns True when:\ncurrent_tokens = context_manager.get_token_count()\nthreshold = config.context.trigger_threshold_tokens\n\nshould_compact = current_tokens &gt;= threshold\n</code></pre>"},{"location":"concepts/execution-loop/#execution-methods","title":"Execution Methods","text":""},{"location":"concepts/execution-loop/#synchronous","title":"Synchronous","text":"<pre><code>result = agent.run_sync(prompt)\n# Blocks until complete\n</code></pre>"},{"location":"concepts/execution-loop/#asynchronous","title":"Asynchronous","text":"<pre><code>result = await agent.run(prompt)\n# Non-blocking, use in async context\n</code></pre>"},{"location":"concepts/execution-loop/#streaming","title":"Streaming","text":"<pre><code>async for chunk in agent.run_stream(prompt):\n    print(chunk, end=\"\")\n# Yields response incrementally\n</code></pre>"},{"location":"concepts/execution-loop/#tool-execution","title":"Tool Execution","text":""},{"location":"concepts/execution-loop/#tool-discovery","title":"Tool Discovery","text":"<p>Tools are registered at agent creation:</p> <pre><code>agent = Agent(\"gpt-4o\", tools=[read_file, run_bash])\n# Tools are available to pydantic-ai\n</code></pre>"},{"location":"concepts/execution-loop/#tool-call-flow","title":"Tool Call Flow","text":"<pre><code>graph TD\n    A[Model Response] --&gt; B{Has Tool Calls?}\n    B --&gt;|Yes| C[Extract Tool Calls]\n    C --&gt; D[Execute Each Tool]\n    D --&gt; E[Collect Results]\n    E --&gt; F[Add to Messages]\n    F --&gt; G[Continue Loop]\n    B --&gt;|No| H[Return Response]</code></pre>"},{"location":"concepts/execution-loop/#error-handling","title":"Error Handling","text":"<pre><code># Tool errors don't stop execution\ntry:\n    result = await tool.execute(args)\n    return ToolResult(success=True, content=result)\nexcept Exception as e:\n    return ToolResult(success=False, error=str(e))\n# Model receives error and can retry or adjust\n</code></pre>"},{"location":"concepts/execution-loop/#state-management","title":"State Management","text":""},{"location":"concepts/execution-loop/#context-state","title":"Context State","text":"<pre><code>state = agent.get_context_state()\n# ContextState(\n#     token_count=1500,\n#     message_count=12,\n#     system_prompt=\"...\",\n#     compaction_history=[...]\n# )\n</code></pre>"},{"location":"concepts/execution-loop/#usage-state","title":"Usage State","text":"<pre><code>usage = agent.get_usage()\n# TokenUsage(\n#     prompt_tokens=1000,\n#     completion_tokens=500,\n#     total_tokens=1500,\n#     request_count=3\n# )\n</code></pre>"},{"location":"concepts/execution-loop/#reset-operations","title":"Reset Operations","text":"<pre><code># Clear context only\nagent.clear_context()\n\n# Reset usage tracking only\nagent.reset_tracking()\n\n# Reset everything\nagent.reset_all()\n</code></pre>"},{"location":"concepts/execution-loop/#multi-turn-conversations","title":"Multi-Turn Conversations","text":""},{"location":"concepts/execution-loop/#automatic-context","title":"Automatic Context","text":"<pre><code># Turn 1\nagent.run_sync(\"My name is Alice\")\n\n# Turn 2 - context includes Turn 1\nresult = agent.run_sync(\"What's my name?\")\n# Agent remembers \"Alice\"\n</code></pre>"},{"location":"concepts/execution-loop/#manual-context-control","title":"Manual Context Control","text":"<pre><code># Start fresh conversation\nagent.clear_context()\n\n# Or with custom history\nmessages = [...]\nagent.context_manager.add_messages(messages)\n</code></pre>"},{"location":"concepts/execution-loop/#performance-considerations","title":"Performance Considerations","text":""},{"location":"concepts/execution-loop/#token-efficiency","title":"Token Efficiency","text":"<ul> <li>Context grows with each turn</li> <li>Auto-compaction prevents overflow</li> <li>Choose appropriate compaction strategy</li> </ul>"},{"location":"concepts/execution-loop/#latency","title":"Latency","text":"<ul> <li>Each iteration adds latency</li> <li>Tool execution time varies</li> <li>Consider timeouts for long operations</li> </ul>"},{"location":"concepts/execution-loop/#cost","title":"Cost","text":"<ul> <li>More tokens = higher cost</li> <li>Tool calls add iterations</li> <li>Monitor with <code>agent.get_cost()</code></li> </ul>"},{"location":"concepts/execution-loop/#debugging","title":"Debugging","text":""},{"location":"concepts/execution-loop/#enable-debug-logging","title":"Enable Debug Logging","text":"<pre><code>import logging\nlogging.basicConfig(level=logging.DEBUG)\n\n# Shows detailed execution flow\n</code></pre>"},{"location":"concepts/execution-loop/#inspect-messages","title":"Inspect Messages","text":"<pre><code># After a run\nmessages = agent.get_messages()\nfor msg in messages:\n    print(f\"{msg['role']}: {msg['content'][:100]}...\")\n</code></pre>"},{"location":"concepts/execution-loop/#track-iterations","title":"Track Iterations","text":"<pre><code># Via hooks in workflows\ndef on_iteration(state, i):\n    print(f\"Iteration {i}\")\n\nhooks = WorkflowHooks(on_iteration_start=on_iteration)\n</code></pre>"},{"location":"concepts/workflow-patterns/","title":"Workflow Patterns","text":"<p>Design patterns for orchestrating multi-step agent execution.</p>"},{"location":"concepts/workflow-patterns/#overview","title":"Overview","text":"<p>Workflows extend agents beyond single-turn interactions:</p> <ul> <li>Multi-step execution - Chain multiple agent calls</li> <li>Iterative refinement - Loop until goals achieved</li> <li>State tracking - Monitor progress and results</li> <li>Error recovery - Handle failures gracefully</li> </ul>"},{"location":"concepts/workflow-patterns/#pattern-1-react-reasoning-and-acting","title":"Pattern 1: ReAct (Reasoning and Acting)","text":"<p>The built-in ReAct workflow implements iterative reasoning.</p>"},{"location":"concepts/workflow-patterns/#concept","title":"Concept","text":"<pre><code>THOUGHT: I need to find the bug\nACTION: read_file(\"src/main.py\")\nOBSERVATION: [file contents]\nTHOUGHT: I see an issue on line 42\nACTION: final_answer(\"The bug is...\")\n</code></pre>"},{"location":"concepts/workflow-patterns/#flow","title":"Flow","text":"<pre><code>graph TD\n    A[Start] --&gt; B[Thought]\n    B --&gt; C[Action]\n    C --&gt; D[Observation]\n    D --&gt; E{Complete?}\n    E --&gt;|No| B\n    E --&gt;|Yes| F[Final Answer]</code></pre>"},{"location":"concepts/workflow-patterns/#implementation","title":"Implementation","text":"<pre><code>from pydantic_agent import Agent\nfrom pydantic_agent.workflows import ReActWorkflow, ReActConfig\n\nagent = Agent(\"gpt-4o\", tools=[read_file, run_bash])\nworkflow = ReActWorkflow(agent=agent, config=ReActConfig(max_iterations=15))\n\nresult = await workflow.run(\"Find and fix the bug in main.py\")\n</code></pre>"},{"location":"concepts/workflow-patterns/#best-for","title":"Best For","text":"<ul> <li>Open-ended tasks requiring exploration</li> <li>Debugging and analysis</li> <li>Research tasks</li> </ul>"},{"location":"concepts/workflow-patterns/#pattern-2-plan-execute","title":"Pattern 2: Plan-Execute","text":"<p>Separate planning from execution for complex tasks.</p>"},{"location":"concepts/workflow-patterns/#concept_1","title":"Concept","text":"<pre><code>PLAN: [step1, step2, step3]\nEXECUTE: step1 \u2192 result1\nEXECUTE: step2 \u2192 result2\nEXECUTE: step3 \u2192 result3\nSYNTHESIZE: final answer\n</code></pre>"},{"location":"concepts/workflow-patterns/#flow_1","title":"Flow","text":"<pre><code>graph TD\n    A[Task] --&gt; B[Planner Agent]\n    B --&gt; C[Plan: Steps]\n    C --&gt; D[Executor Agent]\n    D --&gt; E[Step 1]\n    E --&gt; F[Step 2]\n    F --&gt; G[Step N]\n    G --&gt; H[Synthesizer]\n    H --&gt; I[Final Result]</code></pre>"},{"location":"concepts/workflow-patterns/#implementation_1","title":"Implementation","text":"<pre><code>from pydantic_agent import Agent, Workflow, WorkflowConfig, WorkflowState\n\nclass PlanExecuteWorkflow(Workflow[None, str, dict]):\n    def __init__(self, planner: Agent, executor: Agent, config=None):\n        super().__init__(config=config)\n        self.planner = planner\n        self.executor = executor\n\n    @property\n    def name(self) -&gt; str:\n        return \"plan_execute\"\n\n    def _create_initial_state(self, prompt: str) -&gt; WorkflowState[dict]:\n        return WorkflowState(context={\"prompt\": prompt, \"plan\": [], \"results\": []})\n\n    async def _execute(self, prompt, state, deps=None):\n        # Phase 1: Plan\n        plan_result = await self.planner.run(f\"Create a plan for: {prompt}\")\n        state.context[\"plan\"] = plan_result.output.split(\"\\n\")\n\n        # Phase 2: Execute each step\n        for step in state.context[\"plan\"]:\n            result = await self.executor.run(step)\n            state.context[\"results\"].append(result.output)\n\n        # Phase 3: Synthesize\n        synthesis = await self.planner.run(\n            f\"Summarize results: {state.context['results']}\"\n        )\n        return synthesis.output\n</code></pre>"},{"location":"concepts/workflow-patterns/#best-for_1","title":"Best For","text":"<ul> <li>Complex multi-step tasks</li> <li>When order matters</li> <li>Predictable execution paths</li> </ul>"},{"location":"concepts/workflow-patterns/#pattern-3-reflection","title":"Pattern 3: Reflection","text":"<p>Self-critique and improvement loop.</p>"},{"location":"concepts/workflow-patterns/#concept_2","title":"Concept","text":"<pre><code>DRAFT: initial response\nCRITIQUE: identify weaknesses\nREVISE: improve based on critique\nREPEAT: until satisfactory\n</code></pre>"},{"location":"concepts/workflow-patterns/#flow_2","title":"Flow","text":"<pre><code>graph TD\n    A[Task] --&gt; B[Draft Response]\n    B --&gt; C[Critique]\n    C --&gt; D{Satisfactory?}\n    D --&gt;|No| E[Revise]\n    E --&gt; C\n    D --&gt;|Yes| F[Final Response]</code></pre>"},{"location":"concepts/workflow-patterns/#implementation_2","title":"Implementation","text":"<pre><code>class ReflectionWorkflow(Workflow[None, str, dict]):\n    def __init__(self, agent: Agent, max_revisions: int = 3, config=None):\n        super().__init__(config=config)\n        self.agent = agent\n        self.max_revisions = max_revisions\n\n    async def _execute(self, prompt, state, deps=None):\n        # Initial draft\n        draft = await self.agent.run(f\"Respond to: {prompt}\")\n        state.context[\"draft\"] = draft.output\n\n        for i in range(self.max_revisions):\n            # Critique\n            critique = await self.agent.run(\n                f\"Critique this response:\\n{state.context['draft']}\"\n            )\n\n            # Check if satisfactory\n            if \"no improvements needed\" in critique.output.lower():\n                break\n\n            # Revise\n            revision = await self.agent.run(\n                f\"Improve based on critique:\\n{critique.output}\\n\\n\"\n                f\"Original:\\n{state.context['draft']}\"\n            )\n            state.context[\"draft\"] = revision.output\n\n        return state.context[\"draft\"]\n</code></pre>"},{"location":"concepts/workflow-patterns/#best-for_2","title":"Best For","text":"<ul> <li>Quality-critical outputs</li> <li>Writing and content creation</li> <li>Code review</li> </ul>"},{"location":"concepts/workflow-patterns/#pattern-4-tool-use","title":"Pattern 4: Tool Use","text":"<p>Structured tool calling with validation.</p>"},{"location":"concepts/workflow-patterns/#concept_3","title":"Concept","text":"<pre><code>DECIDE: which tool to use\nVALIDATE: check parameters\nEXECUTE: call the tool\nVERIFY: check result\n</code></pre>"},{"location":"concepts/workflow-patterns/#flow_3","title":"Flow","text":"<pre><code>graph TD\n    A[Task] --&gt; B[Select Tool]\n    B --&gt; C[Validate Params]\n    C --&gt; D{Valid?}\n    D --&gt;|No| E[Request Correction]\n    E --&gt; B\n    D --&gt;|Yes| F[Execute Tool]\n    F --&gt; G[Verify Result]\n    G --&gt; H{Success?}\n    H --&gt;|No| I[Retry/Fallback]\n    I --&gt; B\n    H --&gt;|Yes| J[Return Result]</code></pre>"},{"location":"concepts/workflow-patterns/#best-for_3","title":"Best For","text":"<ul> <li>Reliable tool execution</li> <li>API integrations</li> <li>Data processing pipelines</li> </ul>"},{"location":"concepts/workflow-patterns/#pattern-5-retrieval-augmented","title":"Pattern 5: Retrieval-Augmented","text":"<p>Combine retrieval with generation.</p>"},{"location":"concepts/workflow-patterns/#concept_4","title":"Concept","text":"<pre><code>QUERY: extract search terms\nRETRIEVE: fetch relevant documents\nGENERATE: answer using context\n</code></pre>"},{"location":"concepts/workflow-patterns/#flow_4","title":"Flow","text":"<pre><code>graph TD\n    A[Question] --&gt; B[Extract Query]\n    B --&gt; C[Search/Retrieve]\n    C --&gt; D[Relevant Docs]\n    D --&gt; E[Generate Answer]\n    E --&gt; F[Final Response]</code></pre>"},{"location":"concepts/workflow-patterns/#implementation_3","title":"Implementation","text":"<pre><code>class RAGWorkflow(Workflow[None, str, dict]):\n    def __init__(self, agent: Agent, retriever, config=None):\n        super().__init__(config=config)\n        self.agent = agent\n        self.retriever = retriever\n\n    async def _execute(self, prompt, state, deps=None):\n        # Retrieve relevant documents\n        docs = await self.retriever.search(prompt)\n        context = \"\\n\".join(doc.content for doc in docs)\n\n        # Generate with context\n        result = await self.agent.run(\n            f\"Context:\\n{context}\\n\\nQuestion: {prompt}\"\n        )\n        return result.output\n</code></pre>"},{"location":"concepts/workflow-patterns/#best-for_4","title":"Best For","text":"<ul> <li>Question answering</li> <li>Knowledge-based tasks</li> <li>Documentation queries</li> </ul>"},{"location":"concepts/workflow-patterns/#combining-patterns","title":"Combining Patterns","text":""},{"location":"concepts/workflow-patterns/#react-reflection","title":"ReAct + Reflection","text":"<pre><code>class ReActWithReflection(Workflow):\n    async def _execute(self, prompt, state, deps):\n        # ReAct phase\n        react_result = await self.react_workflow.run(prompt)\n\n        # Reflection phase\n        critique = await self.agent.run(f\"Critique: {react_result.output}\")\n\n        if needs_improvement(critique):\n            return await self.react_workflow.run(\n                f\"Improve based on: {critique.output}\"\n            )\n\n        return react_result.output\n</code></pre>"},{"location":"concepts/workflow-patterns/#plan-execute-tool-use","title":"Plan-Execute + Tool Use","text":"<pre><code>class PlanWithToolValidation(Workflow):\n    async def _execute(self, prompt, state, deps):\n        plan = await self.planner.run(prompt)\n\n        for step in plan.steps:\n            # Validate tool call\n            if not self.validate_tool(step):\n                step = await self.fix_tool_call(step)\n\n            result = await self.executor.run(step)\n            # Continue...\n</code></pre>"},{"location":"concepts/workflow-patterns/#choosing-a-pattern","title":"Choosing a Pattern","text":"Task Type Recommended Pattern Open exploration ReAct Structured tasks Plan-Execute Quality output Reflection API integration Tool Use Knowledge queries RAG Complex tasks Combine patterns"},{"location":"concepts/workflow-patterns/#implementation-tips","title":"Implementation Tips","text":""},{"location":"concepts/workflow-patterns/#1-set-clear-termination-conditions","title":"1. Set Clear Termination Conditions","text":"<pre><code>config = WorkflowConfig(\n    max_iterations=15,\n    timeout_seconds=300,\n)\n</code></pre>"},{"location":"concepts/workflow-patterns/#2-use-hooks-for-monitoring","title":"2. Use Hooks for Monitoring","text":"<pre><code>hooks = WorkflowHooks(\n    on_step_complete=lambda s, step: log_step(step),\n)\n</code></pre>"},{"location":"concepts/workflow-patterns/#3-handle-failures-gracefully","title":"3. Handle Failures Gracefully","text":"<pre><code>try:\n    result = await workflow.run(task)\nexcept WorkflowError as e:\n    if e.partial_result:\n        return e.partial_result\n    raise\n</code></pre>"},{"location":"concepts/workflow-patterns/#4-track-costs","title":"4. Track Costs","text":"<pre><code>result = await workflow.run(task)\nprint(f\"Workflow cost: ${workflow.get_cost():.4f}\")\n</code></pre>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Welcome to Pydantic Agent! This section will help you get up and running quickly.</p>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.12+ - Pydantic Agent requires Python 3.12 or later</li> <li>API Key - An API key for your chosen model provider (OpenAI, Anthropic, etc.), or a local model server</li> </ul>"},{"location":"getting-started/#whats-in-this-section","title":"What's in this section","text":"<ul> <li> <p>:material-download: Installation</p> <p>Install Pydantic Agent using uv or pip, including optional dependencies.</p> <p>:octicons-arrow-right-24: Installation</p> </li> <li> <p>:material-rocket-launch: Quick Start</p> <p>Create and run your first agent in under 5 minutes.</p> <p>:octicons-arrow-right-24: Quick Start</p> </li> <li> <p>:material-cog: Configuration</p> <p>Learn how to configure the agent using environment variables, <code>.env</code> files, and TOML.</p> <p>:octicons-arrow-right-24: Configuration</p> </li> </ul>"},{"location":"getting-started/#overview","title":"Overview","text":"<p>Pydantic Agent is a thin wrapper around pydantic-ai that adds enterprise-grade infrastructure:</p> Feature Description Context Management Automatic message tracking with 5 compaction strategies Token Tracking Built-in usage and cost estimation Workflows Orchestration patterns like ReAct for multi-step tasks MCP Integration Connect to Model Context Protocol servers Observability Structured logging, tracing, and OpenTelemetry Error Handling Retry logic and circuit breaker patterns <p>The simplest way to start is:</p> <pre><code>from pydantic_agent import Agent\n\nagent = Agent(\"gpt-4o\")\nresult = agent.run_sync(\"Hello!\")\nprint(result.output)\n</code></pre> <p>Continue to the Installation guide to get started.</p>"},{"location":"getting-started/configuration/","title":"Configuration","text":"<p>Pydantic Agent uses a layered configuration system that loads settings from multiple sources.</p>"},{"location":"getting-started/configuration/#configuration-sources","title":"Configuration Sources","text":"<p>Settings are loaded in the following priority order (highest to lowest):</p> <ol> <li>Constructor arguments - Passed directly when creating an Agent</li> <li>Environment variables - Using the <code>AGENTS_</code> prefix</li> <li><code>.env</code> file - Project-specific settings</li> <li><code>~/agents.env</code> - User-wide defaults</li> <li><code>config.toml</code> / <code>config.yaml</code> - Configuration files</li> <li>Default values - Built-in defaults</li> </ol>"},{"location":"getting-started/configuration/#environment-variables","title":"Environment Variables","text":"<p>All settings use the <code>AGENTS_</code> prefix. Use double underscore (<code>__</code>) for nested settings:</p> <pre><code># Model configuration\nAGENTS_MODEL_BACKEND__MODEL=gpt-4o\nAGENTS_MODEL_BACKEND__API_KEY=sk-...\nAGENTS_MODEL_BACKEND__BASE_URL=https://api.openai.com/v1\nAGENTS_MODEL_BACKEND__TEMPERATURE=0.7\n\n# Logging\nAGENTS_LOGGING__LEVEL=INFO\nAGENTS_LOGGING__FORMAT=json\n\n# Retry behavior\nAGENTS_RETRY__MAX_RETRIES=3\nAGENTS_RETRY__RETRY_LEVEL=2\n\n# Context compaction\nAGENTS_CONTEXT__STRATEGY=hybrid\nAGENTS_CONTEXT__TRIGGER_THRESHOLD_TOKENS=100000\nAGENTS_CONTEXT__TARGET_TOKENS=80000\n</code></pre>"},{"location":"getting-started/configuration/#env-files","title":".env Files","text":"<p>Create a <code>.env</code> file in your project directory:</p> <pre><code># .env\nAGENTS_MODEL_BACKEND__MODEL=gpt-4o\nAGENTS_MODEL_BACKEND__API_KEY=sk-your-api-key-here\n\nAGENTS_LOGGING__LEVEL=DEBUG\n</code></pre> <p>For user-wide defaults, create <code>~/agents.env</code>:</p> <pre><code># ~/agents.env\nAGENTS_MODEL_BACKEND__API_KEY=sk-default-api-key\nAGENTS_LOGGING__LEVEL=INFO\n</code></pre>"},{"location":"getting-started/configuration/#toml-configuration","title":"TOML Configuration","text":"<p>Create a <code>config.toml</code> file in your project:</p> <pre><code>[model_backend]\nmodel = \"gpt-4o\"\nbase_url = \"https://api.openai.com/v1\"\ntemperature = 0.7\nmax_tokens = 4096\ntimeout = 30.0\n\n[logging]\nlevel = \"INFO\"\nformat = \"json\"\nredact_sensitive = true\n\n[retry]\nmax_retries = 3\nretry_level = 2\n\n[context]\nstrategy = \"hybrid\"\ntrigger_threshold_tokens = 100000\ntarget_tokens = 80000\npreserve_recent_turns = 10\npreserve_system_prompt = true\n\n[streaming]\nenabled = true\nchunk_size = 1024\n</code></pre>"},{"location":"getting-started/configuration/#yaml-configuration","title":"YAML Configuration","text":"<p>Alternatively, use <code>config.yaml</code>:</p> <pre><code>model_backend:\n  model: gpt-4o\n  base_url: https://api.openai.com/v1\n  temperature: 0.7\n\nlogging:\n  level: INFO\n  format: json\n\nretry:\n  max_retries: 3\n  retry_level: 2\n\ncontext:\n  strategy: hybrid\n  trigger_threshold_tokens: 100000\n  target_tokens: 80000\n</code></pre>"},{"location":"getting-started/configuration/#using-agentsettings","title":"Using AgentSettings","text":"<p>Load settings programmatically:</p> <pre><code>from pydantic_agent import AgentSettings, Agent\n\n# Load from all sources (env, .env, config files)\nsettings = AgentSettings()\n\n# Access settings\nprint(f\"Model: {settings.model_backend.model}\")\nprint(f\"Log level: {settings.logging.level}\")\n\n# Create agent with settings\nagent = Agent(settings=settings)\n</code></pre>"},{"location":"getting-started/configuration/#settings-reference","title":"Settings Reference","text":""},{"location":"getting-started/configuration/#modelbackendsettings","title":"ModelBackendSettings","text":"Setting Type Default Description <code>model</code> str <code>\"llama3.2\"</code> Model identifier <code>api_key</code> SecretStr None API key (never logged) <code>base_url</code> str <code>\"http://localhost:11434/v1\"</code> API endpoint <code>temperature</code> float <code>0.7</code> Sampling temperature (0.0-2.0) <code>max_tokens</code> int None Max tokens to generate <code>timeout</code> float <code>30.0</code> Request timeout in seconds <code>max_retries</code> int <code>3</code> Retry attempts"},{"location":"getting-started/configuration/#loggingconfig","title":"LoggingConfig","text":"Setting Type Default Description <code>level</code> str <code>\"INFO\"</code> Log level <code>format</code> str <code>\"text\"</code> Output format (<code>text</code>, <code>json</code>) <code>redact_sensitive</code> bool <code>true</code> Redact API keys from logs"},{"location":"getting-started/configuration/#errorrecoveryconfig","title":"ErrorRecoveryConfig","text":"Setting Type Default Description <code>max_retries</code> int <code>3</code> Maximum retry attempts <code>retry_level</code> int <code>2</code> Retry aggressiveness (1-3) <code>base_wait</code> float <code>1.0</code> Base wait time for backoff"},{"location":"getting-started/configuration/#compactionconfig","title":"CompactionConfig","text":"Setting Type Default Description <code>strategy</code> str <code>\"sliding_window\"</code> Compaction strategy <code>trigger_threshold_tokens</code> int <code>100000</code> Token count to trigger compaction <code>target_tokens</code> int <code>80000</code> Target token count after compaction <code>preserve_recent_turns</code> int <code>10</code> Recent turns to always preserve <code>preserve_system_prompt</code> bool <code>true</code> Always keep system prompt"},{"location":"getting-started/configuration/#override-settings-in-code","title":"Override Settings in Code","text":"<p>You can override settings when creating an agent:</p> <pre><code>from pydantic_agent import Agent, AgentSettings, AgentConfig, CompactionConfig\n\nsettings = AgentSettings()\n\n# Override model while using settings for api_key, base_url\nagent = Agent(\"gpt-4o-mini\", settings=settings)\n\n# Override with custom config\nconfig = AgentConfig(\n    system_prompt=\"You are helpful.\",\n    context=CompactionConfig(\n        strategy=\"summarize_older\",\n        trigger_threshold_tokens=50000,\n    ),\n)\nagent = Agent(\"gpt-4o\", settings=settings, config=config)\n</code></pre>"},{"location":"getting-started/configuration/#secrets-handling","title":"Secrets Handling","text":"<p>Security</p> <p>API keys are stored as <code>SecretStr</code> and are never logged or serialized to plain text.</p> <pre><code># API key is protected\nsettings = AgentSettings()\nprint(settings.model_backend.api_key)  # SecretStr('**********')\n\n# Access the actual value when needed (carefully!)\nactual_key = settings.model_backend.api_key.get_secret_value()\n</code></pre>"},{"location":"getting-started/configuration/#next-steps","title":"Next Steps","text":"<ul> <li>Agent Basics - Learn the Agent API</li> <li>Model Backends - Configure local models</li> <li>AgentSettings API - Full settings reference</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.12 or later</li> <li>An API key for your model provider (or a local model server)</li> </ul>"},{"location":"getting-started/installation/#basic-installation","title":"Basic Installation","text":"uv (recommended)pipFrom source <pre><code>uv add pydantic-agent\n</code></pre> <pre><code>pip install pydantic-agent\n</code></pre> <pre><code>git clone https://github.com/sequenzia/pydantic-agent.git\ncd pydantic-agent\nuv sync\n</code></pre>"},{"location":"getting-started/installation/#optional-dependencies","title":"Optional Dependencies","text":""},{"location":"getting-started/installation/#opentelemetry-support","title":"OpenTelemetry Support","text":"<p>For OpenTelemetry integration (tracing and metrics export):</p> uvpip <pre><code>uv add pydantic-agent[otel]\n</code></pre> <pre><code>pip install pydantic-agent[otel]\n</code></pre> <p>This installs:</p> <ul> <li><code>opentelemetry-api</code></li> <li><code>opentelemetry-sdk</code></li> </ul>"},{"location":"getting-started/installation/#dependencies","title":"Dependencies","text":"<p>Pydantic Agent automatically installs the following core dependencies:</p> Package Purpose <code>pydantic-ai</code> Core agent framework <code>pydantic</code> Data validation <code>pydantic-settings</code> Configuration management <code>httpx</code> HTTP client <code>tenacity</code> Retry logic <code>tiktoken</code> Token counting <code>python-dotenv</code> Environment variable loading <code>pyyaml</code> YAML configuration support"},{"location":"getting-started/installation/#verifying-installation","title":"Verifying Installation","text":"<p>After installation, verify everything is working:</p> <pre><code>from pydantic_agent import Agent, AgentSettings\n\n# Check version\nimport pydantic_agent\nprint(f\"Pydantic Agent version: {pydantic_agent.__version__}\")\n\n# Create a simple agent (requires OPENAI_API_KEY)\nagent = Agent(\"gpt-4o\")\nresult = agent.run_sync(\"Say hello!\")\nprint(result.output)\n</code></pre>"},{"location":"getting-started/installation/#development-installation","title":"Development Installation","text":"<p>For contributing to Pydantic Agent:</p> <pre><code># Clone the repository\ngit clone https://github.com/sequenzia/pydantic-agent.git\ncd pydantic-agent\n\n# Install with dev dependencies\nuv sync --group dev\n\n# Run tests\nuv run pytest\n\n# Run linting\nuv run ruff check\nuv run ruff format --check\n</code></pre>"},{"location":"getting-started/installation/#documentation-development","title":"Documentation Development","text":"<p>To build and preview the documentation locally:</p> <pre><code># Install docs dependencies\nuv sync --group docs\n\n# Serve docs locally\nuv run mkdocs serve\n\n# Build docs\nuv run mkdocs build\n</code></pre>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start - Create your first agent</li> <li>Configuration - Set up your environment</li> </ul>"},{"location":"getting-started/quickstart/","title":"Quick Start","text":"<p>This guide will get you running your first agent in under 5 minutes.</p>"},{"location":"getting-started/quickstart/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, make sure you have:</p> <ol> <li>Python 3.12+ installed</li> <li>Pydantic Agent installed (<code>uv add pydantic-agent</code>)</li> <li>An API key for your model provider</li> </ol>"},{"location":"getting-started/quickstart/#step-1-set-up-your-api-key","title":"Step 1: Set Up Your API Key","text":"<p>The simplest way to provide your API key is through an environment variable:</p> OpenAIAnthropic.env file <pre><code>export OPENAI_API_KEY=\"sk-...\"\n</code></pre> <pre><code>export ANTHROPIC_API_KEY=\"sk-ant-...\"\n</code></pre> <p>Create a <code>.env</code> file in your project: <pre><code>AGENTS_MODEL_BACKEND__API_KEY=sk-...\nAGENTS_MODEL_BACKEND__MODEL=gpt-4o\n</code></pre></p>"},{"location":"getting-started/quickstart/#step-2-create-your-first-agent","title":"Step 2: Create Your First Agent","text":"<pre><code>from pydantic_agent import Agent\n\n# Create an agent with a model\nagent = Agent(\"gpt-4o\")\n\n# Run the agent synchronously\nresult = agent.run_sync(\"What is 2 + 2?\")\nprint(result.output)\n</code></pre>"},{"location":"getting-started/quickstart/#step-3-add-a-system-prompt","title":"Step 3: Add a System Prompt","text":"<pre><code>from pydantic_agent import Agent, AgentConfig\n\nagent = Agent(\n    \"gpt-4o\",\n    config=AgentConfig(\n        system_prompt=\"You are a helpful coding assistant. Be concise.\"\n    ),\n)\n\nresult = agent.run_sync(\"How do I read a file in Python?\")\nprint(result.output)\n</code></pre>"},{"location":"getting-started/quickstart/#step-4-use-built-in-tools","title":"Step 4: Use Built-in Tools","text":"<p>Give your agent the ability to interact with the filesystem:</p> <pre><code>from pydantic_agent import Agent\nfrom pydantic_agent.tools import read_file, list_directory, glob_search\n\nagent = Agent(\n    \"gpt-4o\",\n    tools=[read_file, list_directory, glob_search],\n)\n\nresult = agent.run_sync(\"What Python files are in the current directory?\")\nprint(result.output)\n</code></pre>"},{"location":"getting-started/quickstart/#step-5-track-usage-and-cost","title":"Step 5: Track Usage and Cost","text":"<pre><code>from pydantic_agent import Agent\n\nagent = Agent(\"gpt-4o\")\n\n# Run a few queries\nagent.run_sync(\"Hello!\")\nagent.run_sync(\"Tell me about Python\")\nagent.run_sync(\"What are decorators?\")\n\n# Check aggregate usage\nusage = agent.get_usage()\nprint(f\"Total tokens: {usage.total_tokens}\")\nprint(f\"Requests: {usage.request_count}\")\n\n# Check estimated cost\ncost = agent.get_cost()\nprint(f\"Estimated cost: ${cost:.4f}\")\n</code></pre>"},{"location":"getting-started/quickstart/#step-6-multi-turn-conversations","title":"Step 6: Multi-turn Conversations","text":"<p>Context is maintained automatically across runs:</p> <pre><code>from pydantic_agent import Agent\n\nagent = Agent(\"gpt-4o\")\n\n# First turn\nagent.run_sync(\"My name is Alice\")\n\n# Second turn - agent remembers the context\nresult = agent.run_sync(\"What's my name?\")\nprint(result.output)  # \"Your name is Alice\"\n\n# Check context state\nstate = agent.get_context_state()\nprint(f\"Messages in context: {state.message_count}\")\nprint(f\"Tokens used: {state.token_count}\")\n</code></pre>"},{"location":"getting-started/quickstart/#step-7-using-settings","title":"Step 7: Using Settings","text":"<p>For more control, use the settings system:</p> <pre><code>from pydantic_agent import Agent, AgentSettings\n\n# Load settings from env vars, .env files, and config.toml\nsettings = AgentSettings()\n\n# Create agent with settings\nagent = Agent(settings=settings)\n\n# Or override the model while using other settings\nagent = Agent(\"gpt-4o-mini\", settings=settings)\n</code></pre>"},{"location":"getting-started/quickstart/#complete-example","title":"Complete Example","text":"<p>Here's a complete example bringing it all together:</p> <pre><code>import asyncio\nfrom pydantic_agent import Agent, AgentConfig, AgentSettings\nfrom pydantic_agent.tools import read_file, run_bash\n\nasync def main():\n    # Load settings\n    settings = AgentSettings()\n\n    # Create agent with tools and custom system prompt\n    agent = Agent(\n        \"gpt-4o\",\n        settings=settings,\n        tools=[read_file, run_bash],\n        config=AgentConfig(\n            system_prompt=\"You are a helpful DevOps assistant.\",\n        ),\n    )\n\n    # Run queries\n    result = await agent.run(\"What's the current directory listing?\")\n    print(result.output)\n\n    # Print usage summary\n    usage = agent.get_usage()\n    print(f\"\\nUsage Summary:\")\n    print(f\"  Tokens: {usage.total_tokens}\")\n    print(f\"  Cost: ${agent.get_cost():.4f}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Configuration - Learn about all configuration options</li> <li>Agent Basics - Deep dive into the Agent API</li> <li>Working with Tools - Learn about built-in tools</li> <li>Workflows - Multi-step orchestration with ReAct</li> </ul>"},{"location":"tutorials/","title":"Tutorials","text":"<p>Step-by-step guides for common use cases with Pydantic Agent.</p>"},{"location":"tutorials/#available-tutorials","title":"Available Tutorials","text":"<ul> <li> <p>:material-code-braces: Building a Code Assistant</p> <p>Build a complete coding assistant that can read, analyze, and modify code.</p> <p>Topics: Tools, multi-turn conversations, file operations</p> <p>:octicons-arrow-right-24: Start Tutorial</p> </li> <li> <p>:material-tools: Creating Custom Tools</p> <p>Learn to create, test, and register custom tools for your agents.</p> <p>Topics: Tool decorators, type hints, error handling</p> <p>:octicons-arrow-right-24: Start Tutorial</p> </li> <li> <p>:material-state-machine: ReAct Workflow Deep Dive</p> <p>Master the ReAct workflow pattern for complex multi-step tasks.</p> <p>Topics: Workflows, reasoning traces, hooks</p> <p>:octicons-arrow-right-24: Start Tutorial</p> </li> <li> <p>:material-server: Local LLM Setup</p> <p>Configure and use local models with Ollama, vLLM, or LM Studio.</p> <p>Topics: Model backends, configuration, troubleshooting</p> <p>:octicons-arrow-right-24: Start Tutorial</p> </li> </ul>"},{"location":"tutorials/#prerequisites","title":"Prerequisites","text":"<p>Before starting these tutorials, make sure you have:</p> <ol> <li>Python 3.12+ installed</li> <li>Pydantic Agent installed (<code>uv add pydantic-agent</code>)</li> <li>API access to a model provider (or local model server)</li> </ol>"},{"location":"tutorials/#tutorial-structure","title":"Tutorial Structure","text":"<p>Each tutorial follows a consistent structure:</p> <ol> <li>Overview - What you'll build and learn</li> <li>Prerequisites - What you need before starting</li> <li>Step-by-step guide - Detailed instructions with code</li> <li>Complete example - Full working code</li> <li>Next steps - Where to go from here</li> </ol>"},{"location":"tutorials/#quick-links","title":"Quick Links","text":"Tutorial Difficulty Time Code Assistant Intermediate 20 min Custom Tools Beginner 15 min ReAct Workflow Advanced 30 min Local LLM Setup Beginner 15 min"},{"location":"tutorials/code-assistant/","title":"Building a Code Assistant","text":"<p>In this tutorial, you'll build a coding assistant that can read files, search code, run commands, and help with development tasks.</p>"},{"location":"tutorials/code-assistant/#what-youll-build","title":"What You'll Build","text":"<p>A code assistant that can:</p> <ul> <li>Read and analyze source code files</li> <li>Search for patterns across the codebase</li> <li>Run shell commands</li> <li>Maintain context across conversations</li> </ul>"},{"location":"tutorials/code-assistant/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.12+</li> <li>Pydantic Agent installed</li> <li>OpenAI API key (or local model)</li> </ul>"},{"location":"tutorials/code-assistant/#step-1-project-setup","title":"Step 1: Project Setup","text":"<p>Create a new file <code>code_assistant.py</code>:</p> <pre><code>import asyncio\nfrom pydantic_agent import Agent, AgentConfig, AgentSettings\nfrom pydantic_agent.tools import (\n    read_file,\n    write_file,\n    list_directory,\n    glob_search,\n    grep_search,\n    run_bash,\n)\n</code></pre>"},{"location":"tutorials/code-assistant/#step-2-configure-the-agent","title":"Step 2: Configure the Agent","text":"<pre><code># Load settings (uses env vars, .env, config files)\nsettings = AgentSettings()\n\n# Create agent with coding tools\nagent = Agent(\n    \"gpt-4o\",\n    settings=settings,\n    tools=[\n        read_file,\n        write_file,\n        list_directory,\n        glob_search,\n        grep_search,\n        run_bash,\n    ],\n    config=AgentConfig(\n        system_prompt=\"\"\"You are a helpful coding assistant. You can:\n- Read and analyze code files\n- Search for patterns in the codebase\n- Run shell commands\n- Help with debugging and code review\n\nWhen analyzing code:\n1. First understand the file structure\n2. Read relevant files\n3. Provide clear explanations\n\nBe concise but thorough. Use code blocks for code snippets.\"\"\",\n    ),\n)\n</code></pre>"},{"location":"tutorials/code-assistant/#step-3-create-the-chat-loop","title":"Step 3: Create the Chat Loop","text":"<pre><code>async def chat():\n    \"\"\"Interactive chat loop.\"\"\"\n    print(\"Code Assistant ready! Type 'quit' to exit.\\n\")\n\n    while True:\n        # Get user input\n        user_input = input(\"You: \").strip()\n\n        if user_input.lower() in (\"quit\", \"exit\", \"q\"):\n            print(\"Goodbye!\")\n            break\n\n        if not user_input:\n            continue\n\n        # Run the agent\n        try:\n            result = await agent.run(user_input)\n            print(f\"\\nAssistant: {result.output}\\n\")\n\n            # Show usage stats\n            usage = agent.get_usage()\n            print(f\"[Tokens: {usage.total_tokens}, Cost: ${agent.get_cost():.4f}]\\n\")\n\n        except Exception as e:\n            print(f\"\\nError: {e}\\n\")\n</code></pre>"},{"location":"tutorials/code-assistant/#step-4-add-the-main-entry-point","title":"Step 4: Add the Main Entry Point","text":"<pre><code>async def main():\n    \"\"\"Main entry point.\"\"\"\n    print(\"=\" * 50)\n    print(\"Code Assistant\")\n    print(\"=\" * 50)\n    print()\n\n    await chat()\n\n    # Print final usage summary\n    print(\"\\nSession Summary:\")\n    usage = agent.get_usage()\n    print(f\"  Total tokens: {usage.total_tokens}\")\n    print(f\"  Total requests: {usage.request_count}\")\n    print(f\"  Total cost: ${agent.get_cost():.4f}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"tutorials/code-assistant/#step-5-run-the-assistant","title":"Step 5: Run the Assistant","text":"<pre><code>python code_assistant.py\n</code></pre>"},{"location":"tutorials/code-assistant/#example-conversation","title":"Example Conversation","text":"<p>``` Code Assistant ready! Type 'quit' to exit.</p> <p>You: What Python files are in this directory?</p>"},{"location":"tutorials/custom-tools/","title":"Creating Custom Tools","text":"<p>Learn how to create, test, and register custom tools for your Pydantic Agent.</p>"},{"location":"tutorials/custom-tools/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>Create tools using decorators</li> <li>Handle parameters and return values</li> <li>Implement error handling</li> <li>Test your tools</li> </ul>"},{"location":"tutorials/custom-tools/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.12+</li> <li>Pydantic Agent installed</li> <li>Basic understanding of type hints</li> </ul>"},{"location":"tutorials/custom-tools/#step-1-simple-tool-with-decorator","title":"Step 1: Simple Tool with Decorator","text":"<p>The simplest way to create a tool is with the <code>@agent.tool</code> decorator:</p> <pre><code>from pydantic_agent import Agent\n\nagent = Agent(\"gpt-4o\")\n\n@agent.tool\ndef greet(name: str) -&gt; str:\n    \"\"\"\n    Greet a person by name.\n\n    Args:\n        name: The person's name to greet\n\n    Returns:\n        A friendly greeting message\n    \"\"\"\n    return f\"Hello, {name}! Nice to meet you.\"\n</code></pre>"},{"location":"tutorials/custom-tools/#step-2-tool-with-multiple-parameters","title":"Step 2: Tool with Multiple Parameters","text":"<pre><code>@agent.tool\ndef calculate_area(length: float, width: float, unit: str = \"meters\") -&gt; str:\n    \"\"\"\n    Calculate the area of a rectangle.\n\n    Args:\n        length: The length of the rectangle\n        width: The width of the rectangle\n        unit: The unit of measurement (default: meters)\n\n    Returns:\n        The calculated area with units\n    \"\"\"\n    area = length * width\n    return f\"The area is {area:.2f} square {unit}\"\n</code></pre>"},{"location":"tutorials/custom-tools/#step-3-async-tools","title":"Step 3: Async Tools","text":"<p>For operations that need to be async:</p> <pre><code>import httpx\n\n@agent.tool\nasync def fetch_weather(city: str) -&gt; str:\n    \"\"\"\n    Fetch weather information for a city.\n\n    Args:\n        city: The city name\n\n    Returns:\n        Weather information for the city\n    \"\"\"\n    async with httpx.AsyncClient() as client:\n        # Using a mock API for demonstration\n        response = await client.get(\n            f\"https://api.weather.example.com/{city}\"\n        )\n        data = response.json()\n        return f\"Weather in {city}: {data['temperature']}\u00b0C, {data['conditions']}\"\n</code></pre>"},{"location":"tutorials/custom-tools/#step-4-tools-with-error-handling","title":"Step 4: Tools with Error Handling","text":"<p>Always handle errors gracefully:</p> <pre><code>@agent.tool\ndef read_json_file(filepath: str) -&gt; str:\n    \"\"\"\n    Read and parse a JSON file.\n\n    Args:\n        filepath: Path to the JSON file\n\n    Returns:\n        The parsed JSON content or an error message\n    \"\"\"\n    import json\n\n    try:\n        with open(filepath) as f:\n            data = json.load(f)\n        return json.dumps(data, indent=2)\n    except FileNotFoundError:\n        return f\"Error: File '{filepath}' not found\"\n    except json.JSONDecodeError as e:\n        return f\"Error: Invalid JSON - {e}\"\n    except PermissionError:\n        return f\"Error: Permission denied for '{filepath}'\"\n</code></pre>"},{"location":"tutorials/custom-tools/#step-5-using-tool_plain","title":"Step 5: Using tool_plain","text":"<p>Use <code>tool_plain</code> when you don't need the agent context:</p> <pre><code>@agent.tool_plain\ndef get_current_time() -&gt; str:\n    \"\"\"Get the current date and time.\"\"\"\n    from datetime import datetime\n    return datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n\n@agent.tool_plain\ndef generate_uuid() -&gt; str:\n    \"\"\"Generate a unique identifier.\"\"\"\n    import uuid\n    return str(uuid.uuid4())\n</code></pre>"},{"location":"tutorials/custom-tools/#step-6-standalone-tool-functions","title":"Step 6: Standalone Tool Functions","text":"<p>Create tools as standalone functions:</p> <pre><code>def search_database(query: str, limit: int = 10) -&gt; list[dict]:\n    \"\"\"\n    Search the database for matching records.\n\n    Args:\n        query: Search query string\n        limit: Maximum results to return\n\n    Returns:\n        List of matching records\n    \"\"\"\n    # Your database logic here\n    results = [\n        {\"id\": 1, \"name\": \"Result 1\"},\n        {\"id\": 2, \"name\": \"Result 2\"},\n    ]\n    return results[:limit]\n\n\n# Register with agent\nagent = Agent(\"gpt-4o\", tools=[search_database])\n</code></pre>"},{"location":"tutorials/custom-tools/#step-7-tools-with-complex-types","title":"Step 7: Tools with Complex Types","text":"<p>Use Pydantic models for complex inputs/outputs:</p> <pre><code>from pydantic import BaseModel\nfrom typing import Optional\n\nclass SearchParams(BaseModel):\n    query: str\n    filters: Optional[dict] = None\n    page: int = 1\n    per_page: int = 10\n\nclass SearchResult(BaseModel):\n    total: int\n    results: list[dict]\n\n@agent.tool\ndef advanced_search(params: SearchParams) -&gt; SearchResult:\n    \"\"\"\n    Perform an advanced search with filters.\n\n    Args:\n        params: Search parameters including query and filters\n\n    Returns:\n        Search results with total count\n    \"\"\"\n    # Search logic here\n    return SearchResult(\n        total=100,\n        results=[{\"id\": 1, \"title\": \"Match\"}]\n    )\n</code></pre>"},{"location":"tutorials/custom-tools/#complete-example","title":"Complete Example","text":"<p>Here's a complete example with multiple tools:</p> <pre><code>import asyncio\nfrom datetime import datetime\nfrom pydantic_agent import Agent, AgentConfig\n\n# Create agent\nagent = Agent(\n    \"gpt-4o\",\n    config=AgentConfig(\n        system_prompt=\"You are a helpful assistant with various tools.\"\n    ),\n)\n\n@agent.tool_plain\ndef get_timestamp() -&gt; str:\n    \"\"\"Get current timestamp.\"\"\"\n    return datetime.now().isoformat()\n\n@agent.tool\ndef math_operation(a: float, b: float, operation: str) -&gt; str:\n    \"\"\"\n    Perform a math operation.\n\n    Args:\n        a: First number\n        b: Second number\n        operation: One of: add, subtract, multiply, divide\n\n    Returns:\n        The result of the operation\n    \"\"\"\n    operations = {\n        \"add\": lambda x, y: x + y,\n        \"subtract\": lambda x, y: x - y,\n        \"multiply\": lambda x, y: x * y,\n        \"divide\": lambda x, y: x / y if y != 0 else \"Error: Division by zero\",\n    }\n\n    if operation not in operations:\n        return f\"Error: Unknown operation '{operation}'\"\n\n    result = operations[operation](a, b)\n    return f\"{a} {operation} {b} = {result}\"\n\n@agent.tool\ndef format_text(text: str, style: str = \"upper\") -&gt; str:\n    \"\"\"\n    Format text in different styles.\n\n    Args:\n        text: The text to format\n        style: Format style (upper, lower, title, reverse)\n\n    Returns:\n        The formatted text\n    \"\"\"\n    styles = {\n        \"upper\": str.upper,\n        \"lower\": str.lower,\n        \"title\": str.title,\n        \"reverse\": lambda s: s[::-1],\n    }\n\n    if style not in styles:\n        return f\"Error: Unknown style '{style}'\"\n\n    return styles[style](text)\n\n\nasync def main():\n    # Test the tools\n    result = await agent.run(\"What time is it?\")\n    print(result.output)\n\n    result = await agent.run(\"Calculate 15 multiplied by 7\")\n    print(result.output)\n\n    result = await agent.run(\"Format 'hello world' in title case\")\n    print(result.output)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"tutorials/custom-tools/#testing-tools","title":"Testing Tools","text":"<p>Test your tools independently:</p> <pre><code>import pytest\n\ndef test_math_operation():\n    result = math_operation(10, 5, \"add\")\n    assert \"15\" in result\n\ndef test_math_operation_divide_by_zero():\n    result = math_operation(10, 0, \"divide\")\n    assert \"Error\" in result\n\ndef test_format_text():\n    result = format_text(\"hello\", \"upper\")\n    assert result == \"HELLO\"\n</code></pre>"},{"location":"tutorials/custom-tools/#best-practices","title":"Best Practices","text":"<ol> <li>Clear Docstrings - The model reads them to understand tool usage</li> <li>Type Hints - Always include parameter and return types</li> <li>Error Handling - Return error messages, don't raise exceptions</li> <li>Validation - Validate inputs before processing</li> <li>Concise Returns - Keep return values informative but not excessive</li> </ol>"},{"location":"tutorials/custom-tools/#next-steps","title":"Next Steps","text":"<ul> <li>Agent Basics - Using tools with agents</li> <li>Tools API - Built-in tools reference</li> <li>ReAct Workflow - Tools in workflows</li> </ul>"},{"location":"tutorials/local-llm-setup/","title":"Local LLM Setup","text":"<p>Configure and use local language models with Ollama, vLLM, or LM Studio.</p>"},{"location":"tutorials/local-llm-setup/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>Install and configure Ollama</li> <li>Set up vLLM for production use</li> <li>Configure LM Studio</li> <li>Troubleshoot common issues</li> </ul>"},{"location":"tutorials/local-llm-setup/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.12+</li> <li>Pydantic Agent installed</li> <li>Sufficient RAM (8GB+ recommended)</li> <li>GPU recommended for faster inference</li> </ul>"},{"location":"tutorials/local-llm-setup/#option-1-ollama-recommended-for-development","title":"Option 1: Ollama (Recommended for Development)","text":""},{"location":"tutorials/local-llm-setup/#step-1-install-ollama","title":"Step 1: Install Ollama","text":"macOS/LinuxWindows <pre><code>curl -fsSL https://ollama.com/install.sh | sh\n</code></pre> <p>Download from ollama.com/download</p>"},{"location":"tutorials/local-llm-setup/#step-2-start-the-server","title":"Step 2: Start the Server","text":"<pre><code>ollama serve\n</code></pre> <p>The server runs on <code>http://localhost:11434</code> by default.</p>"},{"location":"tutorials/local-llm-setup/#step-3-pull-a-model","title":"Step 3: Pull a Model","text":"<pre><code># Small, fast model (3B parameters)\nollama pull llama3.2\n\n# Larger, more capable (8B parameters)\nollama pull llama3.1\n\n# Code-focused model\nollama pull codellama\n\n# List available models\nollama list\n</code></pre>"},{"location":"tutorials/local-llm-setup/#step-4-configure-pydantic-agent","title":"Step 4: Configure Pydantic Agent","text":"<pre><code>from pydantic_agent import Agent, AgentSettings\n\nsettings = AgentSettings(\n    model_backend={\n        \"base_url\": \"http://localhost:11434/v1\",\n        \"model\": \"llama3.2\",\n        \"temperature\": 0.7,\n    }\n)\n\nagent = Agent(settings=settings)\nresult = agent.run_sync(\"Hello!\")\nprint(result.output)\n</code></pre> <p>Or via environment variables:</p> <pre><code>export AGENTS_MODEL_BACKEND__BASE_URL=http://localhost:11434/v1\nexport AGENTS_MODEL_BACKEND__MODEL=llama3.2\n</code></pre>"},{"location":"tutorials/local-llm-setup/#option-2-vllm-production","title":"Option 2: vLLM (Production)","text":""},{"location":"tutorials/local-llm-setup/#step-1-install-vllm","title":"Step 1: Install vLLM","text":"<pre><code>pip install vllm\n</code></pre>"},{"location":"tutorials/local-llm-setup/#step-2-start-the-server_1","title":"Step 2: Start the Server","text":"<pre><code>vllm serve meta-llama/Llama-3.2-3B-Instruct \\\n    --port 8000 \\\n    --max-model-len 4096\n</code></pre>"},{"location":"tutorials/local-llm-setup/#step-3-configure-pydantic-agent","title":"Step 3: Configure Pydantic Agent","text":"<pre><code>from pydantic_agent import Agent, AgentSettings\n\nsettings = AgentSettings(\n    model_backend={\n        \"base_url\": \"http://localhost:8000/v1\",\n        \"model\": \"meta-llama/Llama-3.2-3B-Instruct\",\n    }\n)\n\nagent = Agent(settings=settings)\n</code></pre>"},{"location":"tutorials/local-llm-setup/#vllm-production-options","title":"vLLM Production Options","text":"<pre><code># Multi-GPU setup\nvllm serve meta-llama/Llama-3.2-70B-Instruct \\\n    --tensor-parallel-size 4 \\\n    --port 8000\n\n# With authentication\nvllm serve model-name \\\n    --api-key your-secret-key\n\n# Memory optimization\nvllm serve model-name \\\n    --gpu-memory-utilization 0.9 \\\n    --max-num-batched-tokens 4096\n</code></pre>"},{"location":"tutorials/local-llm-setup/#option-3-lm-studio","title":"Option 3: LM Studio","text":""},{"location":"tutorials/local-llm-setup/#step-1-install-lm-studio","title":"Step 1: Install LM Studio","text":"<p>Download from lmstudio.ai</p>"},{"location":"tutorials/local-llm-setup/#step-2-download-a-model","title":"Step 2: Download a Model","text":"<ol> <li>Open LM Studio</li> <li>Go to the \"Discover\" tab</li> <li>Search for a model (e.g., \"Llama 3.2\")</li> <li>Click \"Download\"</li> </ol>"},{"location":"tutorials/local-llm-setup/#step-3-start-the-server","title":"Step 3: Start the Server","text":"<ol> <li>Go to \"Local Server\" tab</li> <li>Select your downloaded model</li> <li>Click \"Start Server\"</li> <li>Note the port (default: 1234)</li> </ol>"},{"location":"tutorials/local-llm-setup/#step-4-configure-pydantic-agent_1","title":"Step 4: Configure Pydantic Agent","text":"<pre><code>from pydantic_agent import Agent, AgentSettings\n\nsettings = AgentSettings(\n    model_backend={\n        \"base_url\": \"http://localhost:1234/v1\",\n        \"model\": \"local-model\",  # LM Studio uses loaded model\n    }\n)\n\nagent = Agent(settings=settings)\n</code></pre>"},{"location":"tutorials/local-llm-setup/#configuration-file","title":"Configuration File","text":"<p>Create a <code>config.toml</code> for local development:</p> <pre><code>[model_backend]\nbase_url = \"http://localhost:11434/v1\"\nmodel = \"llama3.2\"\ntemperature = 0.7\ntimeout = 60.0  # Local models can be slower\n\n[logging]\nlevel = \"DEBUG\"  # Helpful for debugging\n\n[retry]\nmax_retries = 2\nretry_level = 1  # Conservative for local\n</code></pre>"},{"location":"tutorials/local-llm-setup/#complete-example","title":"Complete Example","text":"<pre><code>import asyncio\nfrom pydantic_agent import Agent, AgentSettings, AgentConfig\nfrom pydantic_agent.tools import read_file, run_bash\n\n\nasync def main():\n    # Configure for local model\n    settings = AgentSettings(\n        model_backend={\n            \"base_url\": \"http://localhost:11434/v1\",\n            \"model\": \"llama3.2\",\n            \"temperature\": 0.7,\n            \"timeout\": 60.0,\n        }\n    )\n\n    # Create agent\n    agent = Agent(\n        settings=settings,\n        tools=[read_file, run_bash],\n        config=AgentConfig(\n            system_prompt=\"You are a helpful coding assistant.\",\n        ),\n    )\n\n    # Run query\n    result = await agent.run(\"List files in the current directory\")\n    print(result.output)\n\n    # Check usage (local models are free!)\n    print(f\"Tokens used: {agent.get_usage().total_tokens}\")\n    print(f\"Cost: ${agent.get_cost():.4f}\")  # Should be $0.00\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"tutorials/local-llm-setup/#troubleshooting","title":"Troubleshooting","text":""},{"location":"tutorials/local-llm-setup/#connection-refused","title":"Connection Refused","text":"<pre><code># Check if server is running\nimport httpx\n\ntry:\n    response = httpx.get(\"http://localhost:11434/v1/models\")\n    print(\"Server is running\")\n    print(f\"Models: {response.json()}\")\nexcept httpx.ConnectError:\n    print(\"Server not running!\")\n    print(\"Start with: ollama serve\")\n</code></pre>"},{"location":"tutorials/local-llm-setup/#model-not-found","title":"Model Not Found","text":"<pre><code># List available models\nollama list\n\n# Pull missing model\nollama pull llama3.2\n</code></pre>"},{"location":"tutorials/local-llm-setup/#out-of-memory","title":"Out of Memory","text":"<pre><code># Use a smaller model\nollama pull llama3.2:1b  # 1B parameters\n\n# Or for vLLM, reduce memory usage\nvllm serve model --gpu-memory-utilization 0.8\n</code></pre>"},{"location":"tutorials/local-llm-setup/#slow-responses","title":"Slow Responses","text":"<pre><code># Increase timeout\nsettings = AgentSettings(\n    model_backend={\n        \"timeout\": 120.0,  # 2 minutes\n    }\n)\n\n# Or use a smaller model\nsettings = AgentSettings(\n    model_backend={\n        \"model\": \"llama3.2:1b\",  # Faster, less capable\n    }\n)\n</code></pre>"},{"location":"tutorials/local-llm-setup/#tool-calling-not-working","title":"Tool Calling Not Working","text":"<p>Not all local models support tool calling. Check model capabilities:</p> <pre><code>from pydantic_agent.backends import get_profile\n\nprofile = get_profile(\"llama3.2\")\nif not profile.supports_tools:\n    print(\"This model doesn't support tool calling\")\n    print(\"Try: llama3.2:70b or use without tools\")\n</code></pre>"},{"location":"tutorials/local-llm-setup/#performance-tips","title":"Performance Tips","text":"<ol> <li>Use GPU - Significantly faster than CPU</li> <li>Smaller models - Faster inference, less RAM</li> <li>Increase timeout - Local models are slower than API</li> <li>Batch requests - vLLM handles batching well</li> <li>Quantized models - Less RAM, similar quality</li> </ol>"},{"location":"tutorials/local-llm-setup/#model-recommendations","title":"Model Recommendations","text":"Use Case Recommended Model Size Quick testing llama3.2:1b 1B Development llama3.2 3B Production llama3.1:8b 8B Code tasks codellama 7B+ Complex reasoning llama3.2:70b 70B"},{"location":"tutorials/local-llm-setup/#next-steps","title":"Next Steps","text":"<ul> <li>Model Backends Guide - More configuration options</li> <li>Configuration - Full config reference</li> <li>Error Handling - Handle connection issues</li> </ul>"},{"location":"tutorials/react-workflow/","title":"ReAct Workflow Deep Dive","text":"<p>Master the ReAct (Reasoning and Acting) workflow pattern for complex multi-step tasks.</p>"},{"location":"tutorials/react-workflow/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>How ReAct works (Thought-Action-Observation loop)</li> <li>Configuring ReAct behavior</li> <li>Using hooks for observability</li> <li>Accessing the reasoning trace</li> <li>Handling workflow completion</li> </ul>"},{"location":"tutorials/react-workflow/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.12+</li> <li>Pydantic Agent installed</li> <li>Familiarity with basic agent concepts</li> </ul>"},{"location":"tutorials/react-workflow/#understanding-react","title":"Understanding ReAct","text":"<p>ReAct implements an iterative reasoning loop:</p> <pre><code>1. THOUGHT: Agent reasons about current state\n2. ACTION: Agent calls a tool\n3. OBSERVATION: Tool result is recorded\n4. REPEAT until final_answer is called\n</code></pre>"},{"location":"tutorials/react-workflow/#step-1-basic-react-setup","title":"Step 1: Basic ReAct Setup","text":"<pre><code>from pydantic_agent import Agent\nfrom pydantic_agent.workflows import ReActWorkflow, ReActConfig\nfrom pydantic_agent.tools import read_file, run_bash, grep_search\n\n# Create agent with tools\nagent = Agent(\n    \"gpt-4o\",\n    tools=[read_file, run_bash, grep_search],\n)\n\n# Create workflow\nworkflow = ReActWorkflow(agent=agent)\n\n# Run\nresult = await workflow.run(\"Find all TODO comments in the codebase\")\n\nprint(f\"Success: {result.success}\")\nprint(f\"Answer: {result.output}\")\n</code></pre>"},{"location":"tutorials/react-workflow/#step-2-custom-configuration","title":"Step 2: Custom Configuration","text":"<pre><code>config = ReActConfig(\n    # Iteration limits\n    max_iterations=15,\n    max_steps=50,\n\n    # Timeouts\n    timeout_seconds=300.0,\n    step_timeout_seconds=30.0,\n\n    # Reasoning trace\n    expose_reasoning=True,\n    reasoning_prefix=\"Thought: \",\n    action_prefix=\"Action: \",\n    observation_prefix=\"Observation: \",\n\n    # Termination\n    final_answer_tool_name=\"final_answer\",\n\n    # Context management\n    auto_compact_in_workflow=True,\n    compact_threshold_ratio=0.8,\n\n    # Behavior\n    max_consecutive_thoughts=3,\n    tool_retry_count=2,\n)\n\nworkflow = ReActWorkflow(agent=agent, config=config)\n</code></pre>"},{"location":"tutorials/react-workflow/#step-3-adding-hooks-for-observability","title":"Step 3: Adding Hooks for Observability","text":"<pre><code>from pydantic_agent.workflows import ReActHooks\n\ndef on_thought(state, thought):\n    print(f\"\\n[THOUGHT] {thought[:100]}...\")\n\ndef on_action(state, tool_name, tool_args):\n    print(f\"[ACTION] {tool_name}({tool_args})\")\n\ndef on_observation(state, content, is_error):\n    status = \"ERROR\" if is_error else \"OK\"\n    preview = content[:100] if len(content) &gt; 100 else content\n    print(f\"[OBSERVATION:{status}] {preview}...\")\n\ndef on_iteration(state, iteration):\n    print(f\"\\n--- Iteration {iteration} ---\")\n\nhooks = ReActHooks(\n    # ReAct-specific hooks\n    on_thought=on_thought,\n    on_action=on_action,\n    on_observation=on_observation,\n\n    # Workflow lifecycle hooks\n    on_workflow_start=lambda s: print(\"Starting ReAct workflow...\"),\n    on_workflow_complete=lambda r: print(f\"\\nCompleted: {r.success}\"),\n    on_iteration_start=on_iteration,\n)\n\nworkflow = ReActWorkflow(agent=agent, config=config, hooks=hooks)\n</code></pre>"},{"location":"tutorials/react-workflow/#step-4-accessing-the-reasoning-trace","title":"Step 4: Accessing the Reasoning Trace","text":"<pre><code>result = await workflow.run(\"Analyze the authentication module\")\n\n# Access the scratchpad\nfor entry in result.state.context.scratchpad:\n    print(f\"[{entry.entry_type.upper()}]\")\n    print(f\"  {entry.content}\")\n    print(f\"  Tokens: {entry.token_count}\")\n    print()\n\n# Or use convenience method\nprint(workflow.get_reasoning_trace())\n</code></pre>"},{"location":"tutorials/react-workflow/#step-5-handling-results","title":"Step 5: Handling Results","text":"<pre><code>result = await workflow.run(\"Debug the login flow\")\n\nif result.success:\n    print(f\"Answer: {result.output}\")\nelse:\n    print(f\"Failed: {result.error}\")\n    print(f\"Reason: {result.termination_reason}\")\n\n# Detailed metrics\nprint(f\"Iterations: {result.total_iterations}\")\nprint(f\"Duration: {result.duration_seconds}s\")\nprint(f\"Steps: {result.total_steps}\")\n\n# Access ReAct-specific state\nreact_state = result.state.context\nprint(f\"Total tokens: {react_state.total_tokens_used}\")\nprint(f\"Compactions: {react_state.compaction_count}\")\n</code></pre>"},{"location":"tutorials/react-workflow/#step-6-token-and-cost-tracking","title":"Step 6: Token and Cost Tracking","text":"<pre><code># Through workflow\nusage = workflow.get_token_usage()\nprint(f\"Tokens: {usage.total_tokens}\")\n\ncost = workflow.get_cost()\nprint(f\"Cost: ${cost:.4f}\")\n\n# Per-iteration tracking\nfor i, count in enumerate(result.state.context.iteration_token_counts):\n    print(f\"Iteration {i+1}: {count} tokens\")\n</code></pre>"},{"location":"tutorials/react-workflow/#complete-example","title":"Complete Example","text":"<pre><code>import asyncio\nfrom pydantic_agent import Agent\nfrom pydantic_agent.workflows import ReActWorkflow, ReActConfig, ReActHooks\nfrom pydantic_agent.tools import read_file, list_directory, grep_search, run_bash\n\n\nasync def main():\n    # Create agent with tools\n    agent = Agent(\n        \"gpt-4o\",\n        tools=[read_file, list_directory, grep_search, run_bash],\n        system_prompt=\"You are a code analyst. Be thorough but concise.\",\n    )\n\n    # Configure ReAct\n    config = ReActConfig(\n        max_iterations=10,\n        expose_reasoning=True,\n        auto_compact_in_workflow=True,\n    )\n\n    # Add hooks for visibility\n    hooks = ReActHooks(\n        on_thought=lambda s, t: print(f\"Thinking: {t[:80]}...\"),\n        on_action=lambda s, tool, args: print(f\"Acting: {tool}\"),\n        on_observation=lambda s, o, e: print(f\"Observed: {len(o)} chars\"),\n        on_workflow_complete=lambda r: print(f\"Done: {r.termination_reason}\"),\n    )\n\n    # Create workflow\n    workflow = ReActWorkflow(agent=agent, config=config, hooks=hooks)\n\n    # Run analysis\n    print(\"Starting code analysis...\\n\")\n    result = await workflow.run(\n        \"Analyze the project structure and identify the main entry points\"\n    )\n\n    # Print results\n    print(\"\\n\" + \"=\" * 50)\n    print(\"RESULTS\")\n    print(\"=\" * 50)\n\n    if result.success:\n        print(f\"\\nAnswer:\\n{result.output}\")\n    else:\n        print(f\"\\nFailed: {result.error}\")\n\n    print(f\"\\nMetrics:\")\n    print(f\"  Iterations: {result.total_iterations}\")\n    print(f\"  Duration: {result.duration_seconds:.1f}s\")\n    print(f\"  Cost: ${workflow.get_cost():.4f}\")\n\n    # Show reasoning trace\n    print(\"\\nReasoning Trace:\")\n    print(\"-\" * 40)\n    for entry in result.state.context.scratchpad[-5:]:  # Last 5 entries\n        print(f\"[{entry.entry_type}] {entry.content[:100]}...\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"tutorials/react-workflow/#advanced-custom-termination","title":"Advanced: Custom Termination","text":"<p>The workflow terminates when <code>final_answer</code> is called:</p> <pre><code># The agent automatically gets a final_answer tool\n# When it calls final_answer(answer=\"...\"), the workflow ends\n\n# You can customize the tool name\nconfig = ReActConfig(\n    final_answer_tool_name=\"submit_response\",\n)\n</code></pre>"},{"location":"tutorials/react-workflow/#advanced-manual-context-management","title":"Advanced: Manual Context Management","text":"<pre><code># Access agent's context during workflow\nmessages = workflow.agent.get_messages()\nstate = workflow.agent.get_context_state()\n\n# Manual compaction if needed\nif workflow.agent.should_compact():\n    await workflow.agent.compact()\n</code></pre>"},{"location":"tutorials/react-workflow/#troubleshooting","title":"Troubleshooting","text":""},{"location":"tutorials/react-workflow/#workflow-never-terminates","title":"Workflow Never Terminates","text":"<pre><code># Increase max_iterations or check your task complexity\nconfig = ReActConfig(\n    max_iterations=20,  # Increase limit\n    max_consecutive_thoughts=5,  # Allow more reasoning\n)\n</code></pre>"},{"location":"tutorials/react-workflow/#too-many-tokens-used","title":"Too Many Tokens Used","text":"<pre><code># Enable auto-compaction\nconfig = ReActConfig(\n    auto_compact_in_workflow=True,\n    compact_threshold_ratio=0.7,  # Compact earlier\n)\n</code></pre>"},{"location":"tutorials/react-workflow/#model-not-using-tools","title":"Model Not Using Tools","text":"<p>Ensure your system prompt encourages tool use:</p> <pre><code>agent = Agent(\n    \"gpt-4o\",\n    tools=[...],\n    system_prompt=\"\"\"You have access to tools. Use them to gather information\nbefore answering. Don't guess - use tools to verify.\"\"\",\n)\n</code></pre>"},{"location":"tutorials/react-workflow/#next-steps","title":"Next Steps","text":"<ul> <li>Workflows Guide - More workflow patterns</li> <li>Workflow Patterns - Design patterns</li> <li>ReActWorkflow API - Full reference</li> </ul>"},{"location":"user-guide/","title":"User Guide","text":"<p>This guide covers all the features of Pydantic Agent in detail.</p>"},{"location":"user-guide/#core-features","title":"Core Features","text":"<ul> <li> <p>:material-robot: Agent Basics</p> <p>Learn how to create and run agents, handle responses, and manage state.</p> <p>:octicons-arrow-right-24: Agent Basics</p> </li> <li> <p>:material-tools: Working with Tools</p> <p>Use built-in tools and create custom tools for your agents.</p> <p>:octicons-arrow-right-24: Tools</p> </li> <li> <p>:material-chat-processing: Context Management</p> <p>Manage conversation context and implement compaction strategies.</p> <p>:octicons-arrow-right-24: Context Management</p> </li> <li> <p>:material-counter: Token Tracking</p> <p>Track token usage and estimate costs across requests.</p> <p>:octicons-arrow-right-24: Token Tracking</p> </li> </ul>"},{"location":"user-guide/#advanced-features","title":"Advanced Features","text":"<ul> <li> <p>:material-state-machine: Workflows</p> <p>Orchestrate multi-step agent execution with ReAct and custom patterns.</p> <p>:octicons-arrow-right-24: Workflows</p> </li> <li> <p>:material-connection: MCP Integration</p> <p>Connect to Model Context Protocol servers for external tools.</p> <p>:octicons-arrow-right-24: MCP Integration</p> </li> <li> <p>:material-server: Model Backends</p> <p>Use local models with Ollama, vLLM, or LM Studio.</p> <p>:octicons-arrow-right-24: Model Backends</p> </li> <li> <p>:material-alert-circle: Error Handling</p> <p>Implement retry logic and circuit breaker patterns.</p> <p>:octicons-arrow-right-24: Error Handling</p> </li> <li> <p>:material-chart-timeline: Observability</p> <p>Set up logging, tracing, and OpenTelemetry integration.</p> <p>:octicons-arrow-right-24: Observability</p> </li> </ul>"},{"location":"user-guide/#quick-reference","title":"Quick Reference","text":"Feature Module Primary Classes Agents <code>pydantic_agent</code> <code>Agent</code>, <code>AgentConfig</code>, <code>AgentResult</code> Tools <code>pydantic_agent.tools</code> <code>read_file</code>, <code>run_bash</code>, <code>glob_search</code> Context <code>pydantic_agent.context</code> <code>ContextManager</code>, <code>CompactionConfig</code> Tokens <code>pydantic_agent.tokens</code> <code>TokenCounter</code>, <code>UsageTracker</code>, <code>CostEstimator</code> Workflows <code>pydantic_agent.workflows</code> <code>Workflow</code>, <code>ReActWorkflow</code> MCP <code>pydantic_agent.mcp</code> <code>MCPClientManager</code>, <code>MCPServerConfig</code> Backends <code>pydantic_agent.backends</code> <code>OpenAICompatibleBackend</code> Errors <code>pydantic_agent.errors</code> <code>CircuitBreaker</code>, <code>AgentError</code> Observability <code>pydantic_agent.observability</code> <code>setup_logging</code>, <code>RequestTracer</code>"},{"location":"user-guide/agent-basics/","title":"Agent Basics","text":"<p>The <code>Agent</code> class is the core of Pydantic Agent. It wraps pydantic-ai's Agent with additional features for context management, token tracking, and more.</p>"},{"location":"user-guide/agent-basics/#creating-an-agent","title":"Creating an Agent","text":""},{"location":"user-guide/agent-basics/#simple-creation","title":"Simple Creation","text":"<pre><code>from pydantic_agent import Agent\n\n# Using a model string (requires OPENAI_API_KEY env var)\nagent = Agent(\"gpt-4o\")\n\n# With a specific provider prefix\nagent = Agent(\"openai:gpt-4o\")\nagent = Agent(\"anthropic:claude-3-5-sonnet-20241022\")\n</code></pre>"},{"location":"user-guide/agent-basics/#using-settings","title":"Using Settings","text":"<pre><code>from pydantic_agent import Agent, AgentSettings\n\n# Load settings from environment, .env, config files\nsettings = AgentSettings()\n\n# Use settings for model, api_key, base_url\nagent = Agent(settings=settings)\n\n# Override model but use other settings\nagent = Agent(\"gpt-4o-mini\", settings=settings)\n</code></pre>"},{"location":"user-guide/agent-basics/#with-custom-configuration","title":"With Custom Configuration","text":"<pre><code>from pydantic_agent import Agent, AgentConfig, CompactionConfig\n\nconfig = AgentConfig(\n    system_prompt=\"You are a helpful assistant.\",\n    max_iterations=15,\n    track_context=True,\n    auto_compact=True,\n    context=CompactionConfig(\n        strategy=\"hybrid\",\n        trigger_threshold_tokens=50000,\n    ),\n)\n\nagent = Agent(\"gpt-4o\", config=config)\n</code></pre>"},{"location":"user-guide/agent-basics/#running-the-agent","title":"Running the Agent","text":""},{"location":"user-guide/agent-basics/#synchronous-execution","title":"Synchronous Execution","text":"<pre><code>result = agent.run_sync(\"What is 2 + 2?\")\nprint(result.output)  # \"4\"\n</code></pre>"},{"location":"user-guide/agent-basics/#asynchronous-execution","title":"Asynchronous Execution","text":"<pre><code>import asyncio\n\nasync def main():\n    result = await agent.run(\"What is 2 + 2?\")\n    print(result.output)\n\nasyncio.run(main())\n</code></pre>"},{"location":"user-guide/agent-basics/#streaming-responses","title":"Streaming Responses","text":"<pre><code>async def stream_example():\n    async for chunk in agent.run_stream(\"Tell me a story\"):\n        print(chunk, end=\"\", flush=True)\n</code></pre>"},{"location":"user-guide/agent-basics/#working-with-results","title":"Working with Results","text":"<p>The <code>AgentResult</code> wraps pydantic-ai's <code>RunResult</code> with additional metadata:</p> <pre><code>result = agent.run_sync(\"Hello!\")\n\n# Access the output\nprint(result.output)  # The model's response\n\n# Access token usage for this run\nusage = result.usage()\nprint(f\"Tokens: {usage.total_tokens}\")\n\n# Get messages from this run\nnew_messages = result.new_messages()\n\n# Get all messages including history\nall_messages = result.all_messages()\n</code></pre>"},{"location":"user-guide/agent-basics/#multi-turn-conversations","title":"Multi-turn Conversations","text":"<p>Context is maintained automatically across runs:</p> <pre><code># First turn\nagent.run_sync(\"My name is Alice\")\n\n# Second turn - context is preserved\nresult = agent.run_sync(\"What's my name?\")\nprint(result.output)  # \"Alice\"\n\n# Third turn\nresult = agent.run_sync(\"And what did I tell you first?\")\nprint(result.output)  # References the first message\n</code></pre>"},{"location":"user-guide/agent-basics/#typed-outputs","title":"Typed Outputs","text":"<p>Use generics to get typed responses:</p> <pre><code>from pydantic import BaseModel\n\nclass Answer(BaseModel):\n    value: int\n    explanation: str\n\n# Create typed agent\nagent: Agent[None, Answer] = Agent(\"gpt-4o\", output_type=Answer)\n\nresult = agent.run_sync(\"What is 2 + 2?\")\nprint(result.output.value)       # 4\nprint(result.output.explanation) # \"Two plus two equals four\"\n</code></pre>"},{"location":"user-guide/agent-basics/#system-prompts","title":"System Prompts","text":"<p>Set the system prompt at creation or runtime:</p> <pre><code># At creation\nagent = Agent(\n    \"gpt-4o\",\n    config=AgentConfig(system_prompt=\"You are a Python expert.\"),\n)\n\n# Or use the system_prompt parameter directly\nagent = Agent(\"gpt-4o\", system_prompt=\"You are a Python expert.\")\n</code></pre>"},{"location":"user-guide/agent-basics/#adding-tools","title":"Adding Tools","text":"<p>Register tools for the agent to use:</p> <pre><code>from pydantic_agent import Agent\nfrom pydantic_agent.tools import read_file, run_bash\n\n# Pass tools at creation\nagent = Agent(\"gpt-4o\", tools=[read_file, run_bash])\n</code></pre>"},{"location":"user-guide/agent-basics/#using-the-tool-decorator","title":"Using the Tool Decorator","text":"<pre><code>@agent.tool\ndef calculate(expression: str) -&gt; str:\n    \"\"\"Evaluate a mathematical expression.\"\"\"\n    return str(eval(expression))\n\n@agent.tool_plain\ndef get_time() -&gt; str:\n    \"\"\"Get the current time.\"\"\"\n    from datetime import datetime\n    return datetime.now().isoformat()\n</code></pre>"},{"location":"user-guide/agent-basics/#context-management","title":"Context Management","text":"<p>Access and manage conversation context:</p> <pre><code># Get all tracked messages\nmessages = agent.get_messages()\n\n# Get context state (token count, message count)\nstate = agent.get_context_state()\nprint(f\"Tokens: {state.token_count}\")\nprint(f\"Messages: {state.message_count}\")\n\n# Check if compaction is needed\nif agent.should_compact():\n    result = await agent.compact()\n    print(f\"Compacted {result.removed_count} messages\")\n\n# Clear context for new conversation\nagent.clear_context()\n</code></pre>"},{"location":"user-guide/agent-basics/#token-and-cost-tracking","title":"Token and Cost Tracking","text":"<p>Track usage across requests:</p> <pre><code># Aggregate usage\nusage = agent.get_usage()\nprint(f\"Total tokens: {usage.total_tokens}\")\nprint(f\"Prompt tokens: {usage.prompt_tokens}\")\nprint(f\"Completion tokens: {usage.completion_tokens}\")\nprint(f\"Requests: {usage.request_count}\")\n\n# Cost estimation\ncost = agent.get_cost()\nprint(f\"Estimated cost: ${cost:.4f}\")\n\n# Detailed breakdown\nbreakdown = agent.get_cost_breakdown()\nprint(f\"Prompt cost: ${breakdown.prompt_cost:.4f}\")\nprint(f\"Completion cost: ${breakdown.completion_cost:.4f}\")\n\n# Per-request history\nhistory = agent.get_usage_history()\nfor record in history:\n    print(f\"{record.timestamp}: {record.total_tokens} tokens\")\n\n# Count tokens for text\ncount = agent.get_token_count(\"Some text to count\")\n</code></pre>"},{"location":"user-guide/agent-basics/#reset-operations","title":"Reset Operations","text":"<pre><code># Clear context only (keeps usage tracking)\nagent.clear_context()\n\n# Reset usage tracking only (keeps context)\nagent.reset_tracking()\n\n# Reset everything\nagent.reset_all()\n</code></pre>"},{"location":"user-guide/agent-basics/#agent-properties","title":"Agent Properties","text":"<pre><code># Access the underlying config\nprint(agent.config)\n\n# Access settings\nprint(agent.settings)\n\n# Get model name\nprint(agent.model_name)\n\n# Access internal managers (advanced)\ncontext_mgr = agent.context_manager\nusage_tracker = agent.usage_tracker\ncost_estimator = agent.cost_estimator\ntoken_counter = agent.token_counter\n</code></pre>"},{"location":"user-guide/agent-basics/#configuration-options","title":"Configuration Options","text":""},{"location":"user-guide/agent-basics/#agentconfig-reference","title":"AgentConfig Reference","text":"Option Type Default Description <code>system_prompt</code> str None System prompt for the agent <code>max_iterations</code> int 10 Maximum tool-calling iterations <code>track_context</code> bool True Enable message tracking <code>auto_compact</code> bool True Auto-compact when threshold reached <code>context</code> CompactionConfig None Custom compaction settings <code>tokenizer</code> TokenizerConfig None Custom tokenizer settings"},{"location":"user-guide/agent-basics/#next-steps","title":"Next Steps","text":"<ul> <li>Working with Tools - Built-in tools and custom tool creation</li> <li>Context Management - Deep dive into context compaction</li> <li>Workflows - Multi-step orchestration</li> </ul>"},{"location":"user-guide/context-management/","title":"Context Management","text":"<p>Pydantic Agent automatically tracks conversation context and provides strategies to manage long conversations.</p>"},{"location":"user-guide/context-management/#overview","title":"Overview","text":"<p>As conversations grow, the context window can exceed model limits. The context management system:</p> <ol> <li>Tracks messages across agent runs</li> <li>Counts tokens to monitor usage</li> <li>Compacts context when thresholds are reached</li> <li>Preserves important messages during compaction</li> </ol>"},{"location":"user-guide/context-management/#built-in-agent-context","title":"Built-in Agent Context","text":"<p>Context tracking is enabled by default:</p> <pre><code>from pydantic_agent import Agent\n\nagent = Agent(\"gpt-4o\")\n\n# Run multiple turns - context is maintained automatically\nagent.run_sync(\"My name is Alice\")\nagent.run_sync(\"I'm working on a Python project\")\nresult = agent.run_sync(\"What's my name and what am I working on?\")\n# Agent remembers both pieces of information\n</code></pre>"},{"location":"user-guide/context-management/#checking-context-state","title":"Checking Context State","text":"<pre><code># Get all tracked messages\nmessages = agent.get_messages()\nprint(f\"Total messages: {len(messages)}\")\n\n# Get context state\nstate = agent.get_context_state()\nprint(f\"Token count: {state.token_count}\")\nprint(f\"Message count: {state.message_count}\")\nprint(f\"Compaction history: {len(state.compaction_history)}\")\n</code></pre>"},{"location":"user-guide/context-management/#manual-compaction","title":"Manual Compaction","text":"<pre><code># Check if compaction is needed\nif agent.should_compact():\n    result = await agent.compact()\n    print(f\"Removed {result.removed_count} messages\")\n    print(f\"Tokens before: {result.tokens_before}\")\n    print(f\"Tokens after: {result.tokens_after}\")\n</code></pre>"},{"location":"user-guide/context-management/#auto-compaction","title":"Auto-compaction","text":"<p>By default, context is automatically compacted when thresholds are reached:</p> <pre><code>from pydantic_agent import Agent, AgentConfig, CompactionConfig\n\nconfig = AgentConfig(\n    auto_compact=True,  # Enabled by default\n    context=CompactionConfig(\n        trigger_threshold_tokens=100000,  # Compact at 100k tokens\n        target_tokens=80000,              # Target 80k after compaction\n    ),\n)\n\nagent = Agent(\"gpt-4o\", config=config)\n\n# Compaction happens automatically when threshold is reached\nfor i in range(100):\n    agent.run_sync(f\"Message {i}: Tell me about topic {i}\")\n</code></pre>"},{"location":"user-guide/context-management/#disabling-context-tracking","title":"Disabling Context Tracking","text":"<pre><code>config = AgentConfig(track_context=False)\nagent = Agent(\"gpt-4o\", config=config)\n\n# No context is maintained between runs\n</code></pre>"},{"location":"user-guide/context-management/#compaction-strategies","title":"Compaction Strategies","text":"<p>Five strategies are available for compacting context:</p>"},{"location":"user-guide/context-management/#1-sliding-window","title":"1. Sliding Window","text":"<p>Removes oldest messages beyond a threshold:</p> <pre><code>config = CompactionConfig(\n    strategy=\"sliding_window\",\n    preserve_recent_turns=10,  # Keep last 10 exchanges\n)\n</code></pre> <p>Best for: Simple conversations where recent context is most important.</p>"},{"location":"user-guide/context-management/#2-summarize-older","title":"2. Summarize Older","text":"<p>Uses an LLM to summarize older messages:</p> <pre><code>config = CompactionConfig(\n    strategy=\"summarize_older\",\n    preserve_recent_turns=5,\n    summarization_model=\"gpt-4o-mini\",  # Model for summarization\n)\n</code></pre> <p>Best for: Long conversations where historical context matters.</p>"},{"location":"user-guide/context-management/#3-selective-pruning","title":"3. Selective Pruning","text":"<p>Removes completed tool call/result pairs:</p> <pre><code>config = CompactionConfig(\n    strategy=\"selective_pruning\",\n)\n</code></pre> <p>Best for: Tool-heavy workflows where tool results are no longer needed.</p>"},{"location":"user-guide/context-management/#4-importance-scoring","title":"4. Importance Scoring","text":"<p>Uses LLM to score and prune least important messages:</p> <pre><code>config = CompactionConfig(\n    strategy=\"importance_scoring\",\n    preserve_recent_turns=3,\n)\n</code></pre> <p>Best for: Complex conversations with varying importance levels.</p>"},{"location":"user-guide/context-management/#5-hybrid","title":"5. Hybrid","text":"<p>Combines multiple strategies in sequence:</p> <pre><code>config = CompactionConfig(\n    strategy=\"hybrid\",\n    preserve_recent_turns=5,\n)\n</code></pre> <p>Best for: General-purpose use with good balance.</p>"},{"location":"user-guide/context-management/#configuration-reference","title":"Configuration Reference","text":""},{"location":"user-guide/context-management/#compactionconfig-options","title":"CompactionConfig Options","text":"Option Type Default Description <code>strategy</code> str <code>\"sliding_window\"</code> Compaction strategy <code>trigger_threshold_tokens</code> int <code>100000</code> Token count triggering compaction <code>target_tokens</code> int <code>80000</code> Target tokens after compaction <code>preserve_recent_turns</code> int <code>10</code> Recent turns to always preserve <code>preserve_system_prompt</code> bool <code>True</code> Always keep system prompt <code>summarization_model</code> str <code>\"same\"</code> Model for summarization (<code>\"same\"</code> uses current)"},{"location":"user-guide/context-management/#standalone-context-manager","title":"Standalone Context Manager","text":"<p>For advanced use cases, use ContextManager directly:</p> <pre><code>from pydantic_agent.context import ContextManager, CompactionConfig\n\n# Create manager with config\nconfig = CompactionConfig(\n    strategy=\"hybrid\",\n    trigger_threshold_tokens=50000,\n    target_tokens=40000,\n)\nmanager = ContextManager(config=config)\n\n# Add messages\nmanager.add_messages([\n    {\"role\": \"user\", \"content\": \"Hello\"},\n    {\"role\": \"assistant\", \"content\": \"Hi there!\"},\n])\n\n# Set system prompt\nmanager.set_system_prompt(\"You are helpful.\")\n\n# Get messages\nmessages = manager.get_messages()\n\n# Check and compact\nif manager.should_compact():\n    result = await manager.compact()\n\n# Get state\nstate = manager.get_context_state()\n\n# Clear all\nmanager.clear()\n</code></pre>"},{"location":"user-guide/context-management/#working-with-message-history","title":"Working with Message History","text":""},{"location":"user-guide/context-management/#message-format","title":"Message Format","text":"<p>Messages follow the pydantic-ai format:</p> <pre><code>messages = agent.get_messages()\n\nfor msg in messages:\n    print(f\"Role: {msg['role']}\")\n    print(f\"Content: {msg['content']}\")\n    if 'tool_calls' in msg:\n        print(f\"Tool calls: {msg['tool_calls']}\")\n</code></pre>"},{"location":"user-guide/context-management/#preserving-specific-messages","title":"Preserving Specific Messages","text":"<p>The system prompt is always preserved:</p> <pre><code>config = CompactionConfig(\n    preserve_system_prompt=True,  # Default\n    preserve_recent_turns=5,\n)\n</code></pre>"},{"location":"user-guide/context-management/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/context-management/#1-choose-the-right-strategy","title":"1. Choose the Right Strategy","text":"Use Case Recommended Strategy Chat applications <code>sliding_window</code> Research/analysis <code>summarize_older</code> Tool-heavy workflows <code>selective_pruning</code> or <code>hybrid</code> Long-running agents <code>hybrid</code>"},{"location":"user-guide/context-management/#2-set-appropriate-thresholds","title":"2. Set Appropriate Thresholds","text":"<p>Consider your model's context window:</p> Model Context Window Suggested Threshold GPT-4o 128k 100k GPT-4o-mini 128k 100k Claude 3.5 200k 150k Llama 3.2 8k-128k 75% of limit"},{"location":"user-guide/context-management/#3-monitor-compaction","title":"3. Monitor Compaction","text":"<pre><code>state = agent.get_context_state()\nfor compaction in state.compaction_history:\n    print(f\"Strategy: {compaction.strategy}\")\n    print(f\"Removed: {compaction.removed_count}\")\n</code></pre>"},{"location":"user-guide/context-management/#next-steps","title":"Next Steps","text":"<ul> <li>Token Tracking - Monitor token usage</li> <li>Compaction Strategies Explained - Deep dive</li> <li>ContextManager API - Full reference</li> </ul>"},{"location":"user-guide/error-handling/","title":"Error Handling","text":"<p>Pydantic Agent provides robust error handling with retry logic and circuit breaker patterns.</p>"},{"location":"user-guide/error-handling/#overview","title":"Overview","text":"<p>The error handling system includes:</p> <ul> <li>Custom exceptions - Typed errors for different failure modes</li> <li>Retry decorators - Automatic retries with exponential backoff</li> <li>Circuit breaker - Prevent cascading failures</li> <li>Configurable levels - Conservative to aggressive retry strategies</li> </ul>"},{"location":"user-guide/error-handling/#exception-hierarchy","title":"Exception Hierarchy","text":"<pre><code>AgentError (base)\n\u251c\u2500\u2500 ConfigurationError - Invalid configuration\n\u251c\u2500\u2500 ModelBackendError - Model API failures\n\u2502   \u251c\u2500\u2500 RateLimitError - Rate limit exceeded\n\u2502   \u251c\u2500\u2500 AuthenticationError - Invalid credentials\n\u2502   \u2514\u2500\u2500 ModelNotFoundError - Model unavailable\n\u251c\u2500\u2500 ToolError - Tool execution failures\n\u251c\u2500\u2500 ContextError - Context management errors\n\u251c\u2500\u2500 WorkflowError - Workflow execution failures\n\u2514\u2500\u2500 MCPError - MCP server errors\n</code></pre>"},{"location":"user-guide/error-handling/#handling-exceptions","title":"Handling Exceptions","text":"<pre><code>from pydantic_agent import Agent\nfrom pydantic_agent.errors import (\n    AgentError,\n    ModelBackendError,\n    RateLimitError,\n    AuthenticationError,\n    ToolError,\n)\n\nagent = Agent(\"gpt-4o\")\n\ntry:\n    result = await agent.run(\"Hello\")\nexcept RateLimitError as e:\n    print(f\"Rate limited, retry after: {e.retry_after}s\")\nexcept AuthenticationError:\n    print(\"Invalid API key\")\nexcept ModelBackendError as e:\n    print(f\"Model error: {e}\")\nexcept ToolError as e:\n    print(f\"Tool failed: {e.tool_name} - {e}\")\nexcept AgentError as e:\n    print(f\"Agent error: {e}\")\n</code></pre>"},{"location":"user-guide/error-handling/#retry-configuration","title":"Retry Configuration","text":""},{"location":"user-guide/error-handling/#retry-levels","title":"Retry Levels","text":"<p>Three preset levels control retry aggressiveness:</p> Level Max Retries Base Wait Max Wait Description 1 (Conservative) 2 1.0s 10s Few retries, quick failure 2 (Balanced) 3 1.0s 30s Default, good balance 3 (Aggressive) 5 0.5s 60s Many retries, persistent"},{"location":"user-guide/error-handling/#setting-retry-level","title":"Setting Retry Level","text":"<pre><code>from pydantic_agent import AgentSettings\n\n# Via settings\nsettings = AgentSettings(\n    retry={\"retry_level\": 2, \"max_retries\": 3}\n)\n\n# Via environment\n# AGENTS_RETRY__RETRY_LEVEL=2\n# AGENTS_RETRY__MAX_RETRIES=3\n</code></pre>"},{"location":"user-guide/error-handling/#errorrecoveryconfig","title":"ErrorRecoveryConfig","text":"<pre><code>from pydantic_agent.config import ErrorRecoveryConfig\n\nconfig = ErrorRecoveryConfig(\n    retry_level=2,\n    max_retries=3,\n    base_wait=1.0,\n    max_wait=30.0,\n    exponential_base=2.0,\n    jitter=True,\n)\n</code></pre>"},{"location":"user-guide/error-handling/#retry-decorators","title":"Retry Decorators","text":""},{"location":"user-guide/error-handling/#using-the-decorator","title":"Using the Decorator","text":"<pre><code>from pydantic_agent.errors import create_retry_decorator\n\n@create_retry_decorator(max_attempts=3, base_wait=1.0)\nasync def call_external_api():\n    # This function will retry on failure\n    response = await httpx.get(\"https://api.example.com\")\n    return response.json()\n</code></pre>"},{"location":"user-guide/error-handling/#custom-retry-logic","title":"Custom Retry Logic","text":"<pre><code>from tenacity import retry, stop_after_attempt, wait_exponential\n\n@retry(\n    stop=stop_after_attempt(3),\n    wait=wait_exponential(multiplier=1, min=1, max=10),\n)\nasync def my_function():\n    ...\n</code></pre>"},{"location":"user-guide/error-handling/#circuit-breaker","title":"Circuit Breaker","text":"<p>The circuit breaker pattern prevents cascading failures:</p>"},{"location":"user-guide/error-handling/#basic-usage","title":"Basic Usage","text":"<pre><code>from pydantic_agent.errors import CircuitBreaker\n\nbreaker = CircuitBreaker(\n    name=\"model-api\",\n    failure_threshold=5,  # Open after 5 failures\n    timeout=30.0,  # Stay open for 30 seconds\n)\n\nasync with breaker:\n    result = await model.complete(messages)\n</code></pre>"},{"location":"user-guide/error-handling/#circuit-states","title":"Circuit States","text":"<ol> <li>Closed - Normal operation, requests pass through</li> <li>Open - Too many failures, requests rejected immediately</li> <li>Half-Open - Testing if service recovered</li> </ol>"},{"location":"user-guide/error-handling/#manual-control","title":"Manual Control","text":"<pre><code># Check state\nif breaker.is_open:\n    print(\"Circuit is open, service unavailable\")\n\n# Get stats\nstats = breaker.get_stats()\nprint(f\"Failures: {stats.failure_count}\")\nprint(f\"Successes: {stats.success_count}\")\nprint(f\"State: {stats.state}\")\n\n# Manual reset\nbreaker.reset()\n</code></pre>"},{"location":"user-guide/error-handling/#multiple-services","title":"Multiple Services","text":"<pre><code># Separate breakers for different services\nmodel_breaker = CircuitBreaker(\"model-api\", failure_threshold=5)\nmcp_breaker = CircuitBreaker(\"mcp-server\", failure_threshold=3)\n\nasync def call_model():\n    async with model_breaker:\n        return await model.complete(messages)\n\nasync def call_mcp():\n    async with mcp_breaker:\n        return await mcp_client.call_tool(tool_name)\n</code></pre>"},{"location":"user-guide/error-handling/#error-recovery-strategies","title":"Error Recovery Strategies","text":""},{"location":"user-guide/error-handling/#1-graceful-degradation","title":"1. Graceful Degradation","text":"<pre><code>from pydantic_agent.errors import ModelBackendError\n\nasync def get_response(query: str) -&gt; str:\n    try:\n        # Try primary model\n        result = await primary_agent.run(query)\n        return result.output\n    except ModelBackendError:\n        # Fall back to simpler model\n        result = await fallback_agent.run(query)\n        return result.output\n</code></pre>"},{"location":"user-guide/error-handling/#2-retry-with-backoff","title":"2. Retry with Backoff","text":"<pre><code>import asyncio\nfrom pydantic_agent.errors import RateLimitError\n\nasync def resilient_call(agent, query):\n    for attempt in range(3):\n        try:\n            return await agent.run(query)\n        except RateLimitError as e:\n            if attempt &lt; 2:\n                await asyncio.sleep(e.retry_after or 1.0)\n            else:\n                raise\n</code></pre>"},{"location":"user-guide/error-handling/#3-circuit-breaker-with-fallback","title":"3. Circuit Breaker with Fallback","text":"<pre><code>from pydantic_agent.errors import CircuitBreaker\n\nbreaker = CircuitBreaker(\"api\", failure_threshold=3)\n\nasync def call_with_fallback(query):\n    try:\n        async with breaker:\n            return await primary_api(query)\n    except Exception:\n        if breaker.is_open:\n            return await cached_response(query)\n        raise\n</code></pre>"},{"location":"user-guide/error-handling/#configuration-reference","title":"Configuration Reference","text":""},{"location":"user-guide/error-handling/#errorrecoveryconfig_1","title":"ErrorRecoveryConfig","text":"Option Type Default Description <code>retry_level</code> int 2 Retry aggressiveness (1-3) <code>max_retries</code> int 3 Maximum retry attempts <code>base_wait</code> float 1.0 Initial wait between retries <code>max_wait</code> float 30.0 Maximum wait between retries <code>exponential_base</code> float 2.0 Exponential backoff base <code>jitter</code> bool True Add random jitter to waits"},{"location":"user-guide/error-handling/#circuitbreaker-options","title":"CircuitBreaker Options","text":"Option Type Default Description <code>name</code> str Required Unique breaker identifier <code>failure_threshold</code> int 5 Failures before opening <code>timeout</code> float 30.0 Seconds to stay open <code>success_threshold</code> int 2 Successes to close from half-open"},{"location":"user-guide/error-handling/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/error-handling/#1-use-specific-exceptions","title":"1. Use Specific Exceptions","text":"<pre><code># Good - handle specific errors\ntry:\n    result = await agent.run(query)\nexcept RateLimitError:\n    await asyncio.sleep(60)\nexcept AuthenticationError:\n    refresh_token()\nexcept ModelBackendError:\n    use_fallback()\n\n# Avoid - catching everything\ntry:\n    result = await agent.run(query)\nexcept Exception:\n    pass  # Don't do this\n</code></pre>"},{"location":"user-guide/error-handling/#2-log-errors-for-debugging","title":"2. Log Errors for Debugging","text":"<pre><code>import logging\n\nlogger = logging.getLogger(__name__)\n\ntry:\n    result = await agent.run(query)\nexcept AgentError as e:\n    logger.error(f\"Agent error: {e}\", exc_info=True)\n    raise\n</code></pre>"},{"location":"user-guide/error-handling/#3-set-appropriate-timeouts","title":"3. Set Appropriate Timeouts","text":"<pre><code>settings = AgentSettings(\n    model_backend={\n        \"timeout\": 30.0,  # Request timeout\n    },\n    retry={\n        \"max_wait\": 60.0,  # Max backoff wait\n    },\n)\n</code></pre>"},{"location":"user-guide/error-handling/#next-steps","title":"Next Steps","text":"<ul> <li>Observability - Monitor errors and performance</li> <li>CircuitBreaker API - Full reference</li> <li>Exceptions API - All exception types</li> </ul>"},{"location":"user-guide/mcp-integration/","title":"MCP Integration","text":"<p>Pydantic Agent supports the Model Context Protocol (MCP) for connecting to external tool servers.</p>"},{"location":"user-guide/mcp-integration/#overview","title":"Overview","text":"<p>MCP allows your agent to use tools provided by external servers:</p> <ul> <li>Stdio transport - Run MCP servers as subprocesses</li> <li>SSE transport - Connect to HTTP-based MCP servers</li> <li>Authentication - API key support for secure servers</li> </ul>"},{"location":"user-guide/mcp-integration/#quick-start","title":"Quick Start","text":"<pre><code>from pydantic_agent import Agent\nfrom pydantic_agent.mcp import MCPServerConfig, MCPClientManager\n\n# Configure MCP servers\nservers = [\n    MCPServerConfig(\n        name=\"filesystem\",\n        transport=\"stdio\",\n        command=\"npx\",\n        args=[\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/project\"],\n    ),\n]\n\n# Connect and use\nasync with MCPClientManager(servers) as manager:\n    toolsets = manager.get_toolsets()\n    agent = Agent(\"gpt-4o\", tools=toolsets)\n    result = await agent.run(\"List files in the project\")\n</code></pre>"},{"location":"user-guide/mcp-integration/#transport-types","title":"Transport Types","text":""},{"location":"user-guide/mcp-integration/#stdio-transport","title":"Stdio Transport","text":"<p>Run MCP servers as subprocesses:</p> <pre><code>MCPServerConfig(\n    name=\"filesystem\",\n    transport=\"stdio\",\n    command=\"npx\",\n    args=[\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/path\"],\n)\n\n# Or with a local command\nMCPServerConfig(\n    name=\"custom\",\n    transport=\"stdio\",\n    command=\"python\",\n    args=[\"-m\", \"my_mcp_server\"],\n)\n</code></pre>"},{"location":"user-guide/mcp-integration/#sse-transport","title":"SSE Transport","text":"<p>Connect to HTTP-based servers:</p> <pre><code>MCPServerConfig(\n    name=\"web-tools\",\n    transport=\"sse\",\n    url=\"http://localhost:8080/sse\",\n)\n</code></pre>"},{"location":"user-guide/mcp-integration/#authentication","title":"Authentication","text":""},{"location":"user-guide/mcp-integration/#api-key-authentication","title":"API Key Authentication","text":"<pre><code>from pydantic_agent.mcp import MCPServerConfig, MCPAuthConfig\n\nMCPServerConfig(\n    name=\"secure-server\",\n    transport=\"sse\",\n    url=\"https://api.example.com/mcp\",\n    auth=MCPAuthConfig(\n        type=\"api_key\",\n        key=\"my-api-key\",  # Direct key\n        header=\"Authorization\",  # Header name (default)\n    ),\n)\n</code></pre>"},{"location":"user-guide/mcp-integration/#using-environment-variables","title":"Using Environment Variables","text":"<pre><code>MCPAuthConfig(\n    type=\"api_key\",\n    key_env=\"MY_API_KEY\",  # Read from env var\n)\n\n# Or with ${} syntax\nMCPAuthConfig(\n    type=\"api_key\",\n    key=\"${MY_API_KEY}\",  # Expanded at runtime\n)\n</code></pre>"},{"location":"user-guide/mcp-integration/#mcpclientmanager","title":"MCPClientManager","text":""},{"location":"user-guide/mcp-integration/#basic-usage","title":"Basic Usage","text":"<pre><code>from pydantic_agent.mcp import MCPClientManager, MCPServerConfig\n\nmanager = MCPClientManager()\n\n# Add servers\nmanager.add_server(MCPServerConfig(\n    name=\"server1\",\n    transport=\"stdio\",\n    command=\"my-server\",\n))\n\n# Connect to all servers\nawait manager.connect_all()\n\n# Get tools for agent\ntoolsets = manager.get_toolsets()\n\n# Disconnect when done\nawait manager.disconnect_all()\n</code></pre>"},{"location":"user-guide/mcp-integration/#context-manager-recommended","title":"Context Manager (Recommended)","text":"<pre><code>async with MCPClientManager(servers) as manager:\n    toolsets = manager.get_toolsets()\n    agent = Agent(\"gpt-4o\", tools=toolsets)\n\n    # Servers are automatically connected/disconnected\n    result = await agent.run(\"Use the MCP tools\")\n</code></pre>"},{"location":"user-guide/mcp-integration/#server-status","title":"Server Status","text":"<pre><code># Check individual server\nstatus = manager.get_status(\"filesystem\")\nprint(f\"Connected: {status.connected}\")\nprint(f\"Tools: {status.tool_count}\")\n\n# Check all servers\nall_statuses = manager.get_all_statuses()\nfor name, status in all_statuses.items():\n    print(f\"{name}: {status.connected}\")\n</code></pre>"},{"location":"user-guide/mcp-integration/#getting-specific-servers","title":"Getting Specific Servers","text":"<pre><code># Get a specific server\nserver = manager.get_server(\"filesystem\")\n\n# Use server-specific tools\ntools = server.get_tools()\n</code></pre>"},{"location":"user-guide/mcp-integration/#tool-prefixing","title":"Tool Prefixing","text":"<p>Avoid name conflicts with tool prefixes:</p> <pre><code>MCPServerConfig(\n    name=\"server1\",\n    transport=\"stdio\",\n    command=\"server1\",\n    tool_prefix=\"s1_\",  # Tools become: s1_read, s1_write, etc.\n)\n\nMCPServerConfig(\n    name=\"server2\",\n    transport=\"stdio\",\n    command=\"server2\",\n    tool_prefix=\"s2_\",  # Tools become: s2_read, s2_write, etc.\n)\n</code></pre>"},{"location":"user-guide/mcp-integration/#common-mcp-servers","title":"Common MCP Servers","text":""},{"location":"user-guide/mcp-integration/#filesystem-server","title":"Filesystem Server","text":"<pre><code>MCPServerConfig(\n    name=\"filesystem\",\n    transport=\"stdio\",\n    command=\"npx\",\n    args=[\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/path/to/dir\"],\n)\n</code></pre>"},{"location":"user-guide/mcp-integration/#github-server","title":"GitHub Server","text":"<pre><code>MCPServerConfig(\n    name=\"github\",\n    transport=\"stdio\",\n    command=\"npx\",\n    args=[\"-y\", \"@modelcontextprotocol/server-github\"],\n    auth=MCPAuthConfig(\n        type=\"api_key\",\n        key_env=\"GITHUB_TOKEN\",\n    ),\n)\n</code></pre>"},{"location":"user-guide/mcp-integration/#brave-search-server","title":"Brave Search Server","text":"<pre><code>MCPServerConfig(\n    name=\"search\",\n    transport=\"stdio\",\n    command=\"npx\",\n    args=[\"-y\", \"@modelcontextprotocol/server-brave-search\"],\n    auth=MCPAuthConfig(\n        type=\"api_key\",\n        key_env=\"BRAVE_API_KEY\",\n    ),\n)\n</code></pre>"},{"location":"user-guide/mcp-integration/#configuration-reference","title":"Configuration Reference","text":""},{"location":"user-guide/mcp-integration/#mcpserverconfig","title":"MCPServerConfig","text":"Option Type Description <code>name</code> str Unique server identifier <code>transport</code> str <code>\"stdio\"</code> or <code>\"sse\"</code> <code>command</code> str Command to run (stdio only) <code>args</code> list Command arguments (stdio only) <code>url</code> str Server URL (sse only) <code>auth</code> MCPAuthConfig Authentication config <code>tool_prefix</code> str Prefix for tool names"},{"location":"user-guide/mcp-integration/#mcpauthconfig","title":"MCPAuthConfig","text":"Option Type Description <code>type</code> str Auth type (<code>\"api_key\"</code>) <code>key</code> str Direct API key <code>key_env</code> str Environment variable name <code>header</code> str HTTP header (default: <code>\"Authorization\"</code>)"},{"location":"user-guide/mcp-integration/#error-handling","title":"Error Handling","text":"<pre><code>from pydantic_agent.mcp import MCPClientManager\n\ntry:\n    async with MCPClientManager(servers) as manager:\n        toolsets = manager.get_toolsets()\nexcept ConnectionError as e:\n    print(f\"Failed to connect: {e}\")\nexcept TimeoutError as e:\n    print(f\"Connection timeout: {e}\")\n</code></pre>"},{"location":"user-guide/mcp-integration/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/mcp-integration/#1-use-context-managers","title":"1. Use Context Managers","text":"<pre><code># Good - automatic cleanup\nasync with MCPClientManager(servers) as manager:\n    ...\n\n# Avoid - manual cleanup required\nmanager = MCPClientManager(servers)\nawait manager.connect_all()\ntry:\n    ...\nfinally:\n    await manager.disconnect_all()\n</code></pre>"},{"location":"user-guide/mcp-integration/#2-handle-server-failures","title":"2. Handle Server Failures","text":"<pre><code>statuses = manager.get_all_statuses()\nfailed = [name for name, s in statuses.items() if not s.connected]\nif failed:\n    logger.warning(f\"Failed servers: {failed}\")\n</code></pre>"},{"location":"user-guide/mcp-integration/#3-use-tool-prefixes","title":"3. Use Tool Prefixes","text":"<pre><code># Prevent name conflicts between servers\nserver1 = MCPServerConfig(name=\"s1\", tool_prefix=\"s1_\", ...)\nserver2 = MCPServerConfig(name=\"s2\", tool_prefix=\"s2_\", ...)\n</code></pre>"},{"location":"user-guide/mcp-integration/#next-steps","title":"Next Steps","text":"<ul> <li>Model Backends - Connect to local models</li> <li>MCPClientManager API - Full reference</li> <li>MCPServerConfig API - Configuration reference</li> </ul>"},{"location":"user-guide/model-backends/","title":"Model Backends","text":"<p>Pydantic Agent supports local models through OpenAI-compatible APIs like Ollama, vLLM, and LM Studio.</p>"},{"location":"user-guide/model-backends/#overview","title":"Overview","text":"<p>The backends module provides:</p> <ul> <li>OpenAI-compatible adapter - Connect to any OpenAI-compatible API</li> <li>Factory functions - Quick setup for popular providers</li> <li>Model profiles - Metadata about model capabilities</li> </ul>"},{"location":"user-guide/model-backends/#quick-start","title":"Quick Start","text":""},{"location":"user-guide/model-backends/#ollama","title":"Ollama","text":"<pre><code>from pydantic_agent import Agent, AgentSettings\n\n# Option 1: Via settings\nsettings = AgentSettings(\n    model_backend={\n        \"base_url\": \"http://localhost:11434/v1\",\n        \"model\": \"llama3.2\",\n    }\n)\nagent = Agent(settings=settings)\n\n# Option 2: Via environment\n# AGENTS_MODEL_BACKEND__BASE_URL=http://localhost:11434/v1\n# AGENTS_MODEL_BACKEND__MODEL=llama3.2\n</code></pre>"},{"location":"user-guide/model-backends/#using-backend-factories","title":"Using Backend Factories","text":"<pre><code>from pydantic_agent.backends import (\n    create_ollama_backend,\n    create_vllm_backend,\n    create_lmstudio_backend,\n)\n\n# Ollama\nbackend = create_ollama_backend(\"llama3.2\")\n\n# vLLM\nbackend = create_vllm_backend(\"meta-llama/Llama-3.2-3B-Instruct\")\n\n# LM Studio\nbackend = create_lmstudio_backend()  # Uses default model\n</code></pre>"},{"location":"user-guide/model-backends/#ollama-setup","title":"Ollama Setup","text":""},{"location":"user-guide/model-backends/#installation","title":"Installation","text":"<pre><code># macOS/Linux\ncurl -fsSL https://ollama.com/install.sh | sh\n\n# Start the server\nollama serve\n\n# Pull a model\nollama pull llama3.2\n</code></pre>"},{"location":"user-guide/model-backends/#usage","title":"Usage","text":"<pre><code>from pydantic_agent import Agent, AgentSettings\n\nsettings = AgentSettings(\n    model_backend={\n        \"base_url\": \"http://localhost:11434/v1\",\n        \"model\": \"llama3.2\",\n        \"temperature\": 0.7,\n    }\n)\n\nagent = Agent(settings=settings)\nresult = agent.run_sync(\"Hello!\")\n</code></pre>"},{"location":"user-guide/model-backends/#environment-configuration","title":"Environment Configuration","text":"<pre><code>AGENTS_MODEL_BACKEND__BASE_URL=http://localhost:11434/v1\nAGENTS_MODEL_BACKEND__MODEL=llama3.2\n</code></pre>"},{"location":"user-guide/model-backends/#vllm-setup","title":"vLLM Setup","text":""},{"location":"user-guide/model-backends/#installation_1","title":"Installation","text":"<pre><code>pip install vllm\n\n# Start the server\nvllm serve meta-llama/Llama-3.2-3B-Instruct --port 8000\n</code></pre>"},{"location":"user-guide/model-backends/#usage_1","title":"Usage","text":"<pre><code>from pydantic_agent import Agent, AgentSettings\n\nsettings = AgentSettings(\n    model_backend={\n        \"base_url\": \"http://localhost:8000/v1\",\n        \"model\": \"meta-llama/Llama-3.2-3B-Instruct\",\n    }\n)\n\nagent = Agent(settings=settings)\n</code></pre>"},{"location":"user-guide/model-backends/#lm-studio-setup","title":"LM Studio Setup","text":""},{"location":"user-guide/model-backends/#installation_2","title":"Installation","text":"<ol> <li>Download LM Studio from lmstudio.ai</li> <li>Download a model through the app</li> <li>Start the local server (Settings &gt; Local Server)</li> </ol>"},{"location":"user-guide/model-backends/#usage_2","title":"Usage","text":"<pre><code>from pydantic_agent import Agent, AgentSettings\n\nsettings = AgentSettings(\n    model_backend={\n        \"base_url\": \"http://localhost:1234/v1\",\n        \"model\": \"local-model\",  # LM Studio uses the loaded model\n    }\n)\n\nagent = Agent(settings=settings)\n</code></pre>"},{"location":"user-guide/model-backends/#openai-compatible-backend","title":"OpenAI-Compatible Backend","text":"<p>For custom or other OpenAI-compatible servers:</p> <pre><code>from pydantic_agent.backends import OpenAICompatibleBackend\n\nbackend = OpenAICompatibleBackend(\n    model=\"my-model\",\n    base_url=\"http://localhost:8000/v1\",\n    api_key=\"optional-key\",\n    temperature=0.7,\n    max_tokens=4096,\n)\n</code></pre>"},{"location":"user-guide/model-backends/#model-profiles","title":"Model Profiles","text":"<p>Get information about model capabilities:</p> <pre><code>from pydantic_agent.backends import get_profile, ModelProfile\n\n# Get profile for a model\nprofile = get_profile(\"gpt-4o\")\n\nprint(f\"Context window: {profile.context_window}\")\nprint(f\"Max output: {profile.max_output_tokens}\")\nprint(f\"Supports tools: {profile.supports_tools}\")\nprint(f\"Supports vision: {profile.supports_vision}\")\nprint(f\"Provider: {profile.provider}\")\n</code></pre>"},{"location":"user-guide/model-backends/#available-profiles","title":"Available Profiles","text":"Model Context Tools Vision gpt-4o 128k Yes Yes gpt-4o-mini 128k Yes Yes gpt-4-turbo 128k Yes Yes gpt-3.5-turbo 16k Yes No claude-3-5-sonnet 200k Yes Yes claude-3-opus 200k Yes Yes llama3.2 8k No No llama3.2:70b 128k Yes No"},{"location":"user-guide/model-backends/#configuration-reference","title":"Configuration Reference","text":""},{"location":"user-guide/model-backends/#modelbackendsettings","title":"ModelBackendSettings","text":"Option Type Default Description <code>model</code> str <code>\"llama3.2\"</code> Model identifier <code>base_url</code> str <code>\"http://localhost:11434/v1\"</code> API endpoint <code>api_key</code> SecretStr None API key <code>temperature</code> float 0.7 Sampling temperature (0.0-2.0) <code>max_tokens</code> int None Max tokens to generate <code>timeout</code> float 30.0 Request timeout <code>max_retries</code> int 3 Retry attempts"},{"location":"user-guide/model-backends/#switching-between-providers","title":"Switching Between Providers","text":""},{"location":"user-guide/model-backends/#using-settings-override","title":"Using Settings Override","text":"<pre><code>from pydantic_agent import Agent, AgentSettings\n\n# Load base settings\nsettings = AgentSettings()\n\n# Override for local development\nlocal_settings = AgentSettings(\n    model_backend={\n        \"base_url\": \"http://localhost:11434/v1\",\n        \"model\": \"llama3.2\",\n    }\n)\n\n# Use appropriate settings\nagent = Agent(settings=local_settings if is_dev else settings)\n</code></pre>"},{"location":"user-guide/model-backends/#using-environment-variables","title":"Using Environment Variables","text":"<pre><code># Development (.env.local)\nAGENTS_MODEL_BACKEND__BASE_URL=http://localhost:11434/v1\nAGENTS_MODEL_BACKEND__MODEL=llama3.2\n\n# Production (.env.prod)\nAGENTS_MODEL_BACKEND__BASE_URL=https://api.openai.com/v1\nAGENTS_MODEL_BACKEND__MODEL=gpt-4o\nAGENTS_MODEL_BACKEND__API_KEY=sk-...\n</code></pre>"},{"location":"user-guide/model-backends/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/model-backends/#connection-refused","title":"Connection Refused","text":"<pre><code># Check if server is running\nimport httpx\n\ntry:\n    response = httpx.get(\"http://localhost:11434/v1/models\")\n    print(\"Server is running\")\nexcept httpx.ConnectError:\n    print(\"Server not running - start with 'ollama serve'\")\n</code></pre>"},{"location":"user-guide/model-backends/#model-not-found","title":"Model Not Found","text":"<pre><code># List available models (Ollama)\nollama list\n\n# Pull missing model\nollama pull llama3.2\n</code></pre>"},{"location":"user-guide/model-backends/#timeout-errors","title":"Timeout Errors","text":"<pre><code>settings = AgentSettings(\n    model_backend={\n        \"timeout\": 60.0,  # Increase timeout\n        \"max_retries\": 5,\n    }\n)\n</code></pre>"},{"location":"user-guide/model-backends/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/model-backends/#1-use-environment-based-configuration","title":"1. Use Environment-Based Configuration","text":"<pre><code>import os\n\nif os.getenv(\"ENV\") == \"development\":\n    settings = AgentSettings(model_backend={\"model\": \"llama3.2\"})\nelse:\n    settings = AgentSettings()  # Uses production defaults\n</code></pre>"},{"location":"user-guide/model-backends/#2-handle-model-limitations","title":"2. Handle Model Limitations","text":"<pre><code>from pydantic_agent.backends import get_profile\n\nprofile = get_profile(settings.model_backend.model)\n\nif not profile.supports_tools:\n    # Use a simpler approach without tools\n    agent = Agent(model, tools=[])\n</code></pre>"},{"location":"user-guide/model-backends/#3-monitor-local-server-health","title":"3. Monitor Local Server Health","text":"<pre><code>async def check_server_health(base_url: str) -&gt; bool:\n    async with httpx.AsyncClient() as client:\n        try:\n            await client.get(f\"{base_url}/models\", timeout=5.0)\n            return True\n        except Exception:\n            return False\n</code></pre>"},{"location":"user-guide/model-backends/#next-steps","title":"Next Steps","text":"<ul> <li>Error Handling - Handle connection failures</li> <li>Local LLM Tutorial - Step-by-step guide</li> <li>ModelBackendSettings API - Full reference</li> </ul>"},{"location":"user-guide/observability/","title":"Observability","text":"<p>Pydantic Agent provides comprehensive observability through structured logging, tracing, and OpenTelemetry integration.</p>"},{"location":"user-guide/observability/#overview","title":"Overview","text":"<p>The observability system includes:</p> <ul> <li>Structured logging - JSON and text formats with sensitive data redaction</li> <li>Request tracing - Track agent execution with spans</li> <li>OpenTelemetry - Export traces and metrics to external systems</li> </ul>"},{"location":"user-guide/observability/#logging","title":"Logging","text":""},{"location":"user-guide/observability/#basic-setup","title":"Basic Setup","text":"<pre><code>from pydantic_agent.observability import setup_logging\nfrom pydantic_agent.config import LoggingConfig\n\n# Configure logging\nconfig = LoggingConfig(\n    level=\"INFO\",\n    format=\"json\",  # or \"text\"\n    redact_sensitive=True,\n)\n\nlogger = setup_logging(config)\n</code></pre>"},{"location":"user-guide/observability/#logging-formats","title":"Logging Formats","text":""},{"location":"user-guide/observability/#text-format","title":"Text Format","text":"<pre><code>config = LoggingConfig(level=\"INFO\", format=\"text\")\n# Output: 2024-01-15 10:30:00 INFO [agent] Starting agent run\n</code></pre>"},{"location":"user-guide/observability/#json-format","title":"JSON Format","text":"<pre><code>config = LoggingConfig(level=\"INFO\", format=\"json\")\n# Output: {\"timestamp\": \"2024-01-15T10:30:00\", \"level\": \"INFO\", \"module\": \"agent\", \"message\": \"Starting agent run\"}\n</code></pre>"},{"location":"user-guide/observability/#sensitive-data-redaction","title":"Sensitive Data Redaction","text":"<p>API keys and secrets are automatically redacted:</p> <pre><code>config = LoggingConfig(redact_sensitive=True)\n\n# API keys are replaced with [REDACTED]\nlogger.info(f\"Using API key: {api_key}\")\n# Output: Using API key: [REDACTED]\n</code></pre>"},{"location":"user-guide/observability/#log-levels","title":"Log Levels","text":"Level Description DEBUG Detailed debugging information INFO General operational messages WARNING Warning messages ERROR Error messages CRITICAL Critical failures"},{"location":"user-guide/observability/#configuration","title":"Configuration","text":"<pre><code>from pydantic_agent.config import LoggingConfig\n\nconfig = LoggingConfig(\n    level=\"INFO\",\n    format=\"json\",\n    redact_sensitive=True,\n    include_timestamp=True,\n    include_module=True,\n)\n</code></pre> <p>Or via environment:</p> <pre><code>AGENTS_LOGGING__LEVEL=INFO\nAGENTS_LOGGING__FORMAT=json\nAGENTS_LOGGING__REDACT_SENSITIVE=true\n</code></pre>"},{"location":"user-guide/observability/#request-tracing","title":"Request Tracing","text":""},{"location":"user-guide/observability/#basic-tracing","title":"Basic Tracing","text":"<pre><code>from pydantic_agent.observability import RequestTracer\n\ntracer = RequestTracer()\n\n# Start a trace\ntracer.start_trace()\n\n# Create spans for operations\nwith tracer.start_span(\"agent.run\") as span:\n    span.set_attribute(\"prompt_length\", len(prompt))\n    result = await agent.run(prompt)\n    span.set_attribute(\"output_length\", len(result.output))\n\n# End trace and get data\ntrace = tracer.end_trace()\nprint(f\"Duration: {trace.duration_seconds}s\")\n</code></pre>"},{"location":"user-guide/observability/#nested-spans","title":"Nested Spans","text":"<pre><code>tracer.start_trace()\n\nwith tracer.start_span(\"workflow\") as workflow_span:\n    workflow_span.set_attribute(\"workflow_type\", \"react\")\n\n    with tracer.start_span(\"planning\") as plan_span:\n        plan_span.set_attribute(\"step\", \"plan\")\n        # Planning logic...\n\n    with tracer.start_span(\"execution\") as exec_span:\n        exec_span.set_attribute(\"step\", \"execute\")\n        # Execution logic...\n\ntrace = tracer.end_trace()\n</code></pre>"},{"location":"user-guide/observability/#span-attributes","title":"Span Attributes","text":"<pre><code>with tracer.start_span(\"api_call\") as span:\n    span.set_attribute(\"model\", \"gpt-4o\")\n    span.set_attribute(\"tokens\", 1500)\n    span.set_attribute(\"success\", True)\n    span.set_attribute(\"error\", None)\n</code></pre>"},{"location":"user-guide/observability/#accessing-trace-data","title":"Accessing Trace Data","text":"<pre><code>trace = tracer.end_trace()\n\nprint(f\"Trace ID: {trace.trace_id}\")\nprint(f\"Duration: {trace.duration_seconds}s\")\nprint(f\"Spans: {len(trace.spans)}\")\n\nfor span in trace.spans:\n    print(f\"  {span.name}: {span.duration_ms}ms\")\n    for key, value in span.attributes.items():\n        print(f\"    {key}: {value}\")\n</code></pre>"},{"location":"user-guide/observability/#opentelemetry-integration","title":"OpenTelemetry Integration","text":""},{"location":"user-guide/observability/#installation","title":"Installation","text":"<pre><code>uv add pydantic-agent[otel]\n# or\npip install pydantic-agent[otel]\n</code></pre>"},{"location":"user-guide/observability/#basic-setup_1","title":"Basic Setup","text":"<pre><code>from pydantic_agent.observability import get_otel_integration\n\notel = get_otel_integration()\n\n# Initialize with default settings\nif otel.initialize():\n    print(\"OpenTelemetry initialized\")\n</code></pre>"},{"location":"user-guide/observability/#tracing-agent-runs","title":"Tracing Agent Runs","text":"<pre><code>otel = get_otel_integration()\notel.initialize()\n\n# Trace agent execution\nwith otel.trace_agent_run(prompt, model=\"gpt-4o\") as span:\n    result = await agent.run(prompt)\n    span.set_attribute(\"tokens\", result.usage().total_tokens)\n</code></pre>"},{"location":"user-guide/observability/#custom-spans","title":"Custom Spans","text":"<pre><code>with otel.tracer.start_as_current_span(\"custom_operation\") as span:\n    span.set_attribute(\"custom_attribute\", \"value\")\n    # Your code here\n</code></pre>"},{"location":"user-guide/observability/#exporting-to-services","title":"Exporting to Services","text":""},{"location":"user-guide/observability/#jaeger","title":"Jaeger","text":"<pre><code>from opentelemetry.exporter.jaeger.thrift import JaegerExporter\nfrom opentelemetry.sdk.trace.export import BatchSpanProcessor\n\notel = get_otel_integration()\notel.initialize()\n\n# Add Jaeger exporter\njaeger_exporter = JaegerExporter(\n    agent_host_name=\"localhost\",\n    agent_port=6831,\n)\notel.add_span_processor(BatchSpanProcessor(jaeger_exporter))\n</code></pre>"},{"location":"user-guide/observability/#otlp-grafana-honeycomb-etc","title":"OTLP (Grafana, Honeycomb, etc.)","text":"<pre><code>from opentelemetry.exporter.otlp.proto.grpc.trace_exporter import OTLPSpanExporter\nfrom opentelemetry.sdk.trace.export import BatchSpanProcessor\n\notel = get_otel_integration()\notel.initialize()\n\notlp_exporter = OTLPSpanExporter(\n    endpoint=\"https://otlp.example.com:4317\",\n)\notel.add_span_processor(BatchSpanProcessor(otlp_exporter))\n</code></pre>"},{"location":"user-guide/observability/#configuration_1","title":"Configuration","text":"<pre><code>from pydantic_agent.config import ObservabilityConfig\n\nconfig = ObservabilityConfig(\n    enable_tracing=True,\n    enable_metrics=True,\n    service_name=\"my-agent-service\",\n    service_version=\"1.0.0\",\n)\n</code></pre> <p>Or via environment:</p> <pre><code>AGENTS_OBSERVABILITY__ENABLE_TRACING=true\nAGENTS_OBSERVABILITY__SERVICE_NAME=my-agent-service\nOTEL_EXPORTER_OTLP_ENDPOINT=https://otlp.example.com:4317\n</code></pre>"},{"location":"user-guide/observability/#combining-all-features","title":"Combining All Features","text":"<pre><code>import asyncio\nfrom pydantic_agent import Agent, AgentSettings\nfrom pydantic_agent.observability import setup_logging, RequestTracer, get_otel_integration\nfrom pydantic_agent.config import LoggingConfig\n\nasync def main():\n    # Setup logging\n    logging_config = LoggingConfig(level=\"INFO\", format=\"json\")\n    logger = setup_logging(logging_config)\n\n    # Setup OpenTelemetry\n    otel = get_otel_integration()\n    otel.initialize()\n\n    # Setup request tracing\n    tracer = RequestTracer()\n\n    # Create agent\n    agent = Agent(\"gpt-4o\")\n\n    # Execute with full observability\n    tracer.start_trace()\n\n    with otel.trace_agent_run(\"Hello\", model=\"gpt-4o\"):\n        with tracer.start_span(\"agent.run\") as span:\n            result = await agent.run(\"Hello\")\n            span.set_attribute(\"tokens\", result.usage().total_tokens)\n\n    trace = tracer.end_trace()\n    logger.info(f\"Completed in {trace.duration_seconds}s\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"user-guide/observability/#configuration-reference","title":"Configuration Reference","text":""},{"location":"user-guide/observability/#loggingconfig","title":"LoggingConfig","text":"Option Type Default Description <code>level</code> str <code>\"INFO\"</code> Log level <code>format</code> str <code>\"text\"</code> Output format (<code>text</code>, <code>json</code>) <code>redact_sensitive</code> bool <code>True</code> Redact API keys <code>include_timestamp</code> bool <code>True</code> Include timestamps <code>include_module</code> bool <code>True</code> Include module names"},{"location":"user-guide/observability/#observabilityconfig","title":"ObservabilityConfig","text":"Option Type Default Description <code>enable_tracing</code> bool <code>False</code> Enable OpenTelemetry tracing <code>enable_metrics</code> bool <code>False</code> Enable OpenTelemetry metrics <code>service_name</code> str <code>\"pydantic-agent\"</code> Service name for traces <code>service_version</code> str <code>\"1.0.0\"</code> Service version"},{"location":"user-guide/observability/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/observability/#1-use-structured-logging-in-production","title":"1. Use Structured Logging in Production","text":"<pre><code>config = LoggingConfig(\n    level=\"INFO\",\n    format=\"json\",  # Easy to parse by log aggregators\n    redact_sensitive=True,\n)\n</code></pre>"},{"location":"user-guide/observability/#2-add-context-to-spans","title":"2. Add Context to Spans","text":"<pre><code>with tracer.start_span(\"operation\") as span:\n    span.set_attribute(\"user_id\", user_id)\n    span.set_attribute(\"request_id\", request_id)\n    span.set_attribute(\"model\", model_name)\n</code></pre>"},{"location":"user-guide/observability/#3-monitor-key-metrics","title":"3. Monitor Key Metrics","text":"<pre><code># Track in spans\nspan.set_attribute(\"tokens_used\", usage.total_tokens)\nspan.set_attribute(\"cost_usd\", cost)\nspan.set_attribute(\"latency_ms\", latency)\n</code></pre>"},{"location":"user-guide/observability/#next-steps","title":"Next Steps","text":"<ul> <li>Error Handling - Handle and log errors</li> <li>Logging API - Full reference</li> <li>Tracing API - Tracing reference</li> <li>OpenTelemetry API - OTel reference</li> </ul>"},{"location":"user-guide/token-tracking/","title":"Token Tracking","text":"<p>Pydantic Agent automatically tracks token usage and estimates costs across all agent runs.</p>"},{"location":"user-guide/token-tracking/#overview","title":"Overview","text":"<p>Every time you run an agent, token usage is recorded:</p> <ul> <li>Prompt tokens - Tokens in the input (messages + system prompt)</li> <li>Completion tokens - Tokens in the model's response</li> <li>Total tokens - Combined count</li> <li>Request count - Number of API calls</li> </ul>"},{"location":"user-guide/token-tracking/#built-in-tracking","title":"Built-in Tracking","text":"<p>Token tracking is always enabled:</p> <pre><code>from pydantic_agent import Agent\n\nagent = Agent(\"gpt-4o\")\n\n# Run some queries\nagent.run_sync(\"Hello!\")\nagent.run_sync(\"Tell me about Python\")\nagent.run_sync(\"What are decorators?\")\n\n# Get aggregate usage\nusage = agent.get_usage()\nprint(f\"Total tokens: {usage.total_tokens}\")\nprint(f\"Prompt tokens: {usage.prompt_tokens}\")\nprint(f\"Completion tokens: {usage.completion_tokens}\")\nprint(f\"Requests: {usage.request_count}\")\n</code></pre>"},{"location":"user-guide/token-tracking/#cost-estimation","title":"Cost Estimation","text":"<p>Get estimated costs based on model pricing:</p> <pre><code># Get total cost\ncost = agent.get_cost()\nprint(f\"Estimated cost: ${cost:.4f}\")\n\n# Get detailed breakdown\nbreakdown = agent.get_cost_breakdown()\nprint(f\"Prompt cost: ${breakdown.prompt_cost:.4f}\")\nprint(f\"Completion cost: ${breakdown.completion_cost:.4f}\")\nprint(f\"Total cost: ${breakdown.total_cost:.4f}\")\nprint(f\"Model: {breakdown.model}\")\n</code></pre>"},{"location":"user-guide/token-tracking/#default-pricing","title":"Default Pricing","text":"<p>Pydantic Agent includes default pricing for common models:</p> Model Input (per 1M) Output (per 1M) gpt-4o $2.50 $10.00 gpt-4o-mini $0.15 $0.60 gpt-4-turbo $10.00 $30.00 gpt-3.5-turbo $0.50 $1.50 claude-3-5-sonnet $3.00 $15.00 claude-3-opus $15.00 $75.00 Local models $0.00 $0.00"},{"location":"user-guide/token-tracking/#custom-cost-rates","title":"Custom Cost Rates","text":"<p>Set custom rates via settings:</p> <pre><code>from pydantic_agent import AgentSettings\n\nsettings = AgentSettings(\n    cost_rates={\n        \"my-custom-model\": 0.001,  # Per 1000 tokens\n    }\n)\n</code></pre> <p>Or via environment:</p> <pre><code>AGENTS_COST_RATES__MY_MODEL=0.001\n</code></pre>"},{"location":"user-guide/token-tracking/#usage-history","title":"Usage History","text":"<p>Get per-request usage details:</p> <pre><code>history = agent.get_usage_history()\n\nfor record in history:\n    print(f\"Time: {record.timestamp}\")\n    print(f\"Prompt tokens: {record.prompt_tokens}\")\n    print(f\"Completion tokens: {record.completion_tokens}\")\n    print(f\"Total: {record.total_tokens}\")\n    print(f\"Model: {record.model}\")\n    if record.tool_name:\n        print(f\"Tool: {record.tool_name}\")\n    print(\"---\")\n</code></pre>"},{"location":"user-guide/token-tracking/#token-counting","title":"Token Counting","text":"<p>Count tokens for arbitrary text:</p> <pre><code># Count tokens in text\ncount = agent.get_token_count(\"Hello, how are you today?\")\nprint(f\"Tokens: {count}\")\n\n# Count current context\ncontext_tokens = agent.get_token_count()  # No argument = current context\nprint(f\"Context tokens: {context_tokens}\")\n</code></pre>"},{"location":"user-guide/token-tracking/#reset-tracking","title":"Reset Tracking","text":"<pre><code># Reset usage tracking (keeps context)\nagent.reset_tracking()\n\n# Reset everything (context + tracking)\nagent.reset_all()\n</code></pre>"},{"location":"user-guide/token-tracking/#standalone-token-utilities","title":"Standalone Token Utilities","text":"<p>For advanced use cases, use the token modules directly:</p>"},{"location":"user-guide/token-tracking/#tokencounter","title":"TokenCounter","text":"<pre><code>from pydantic_agent.tokens import TokenCounter\n\ncounter = TokenCounter(encoding=\"cl100k_base\")\n\n# Count tokens in text\ncount = counter.count(\"Hello, world!\")\n\n# Count tokens in messages\nmessages = [\n    {\"role\": \"user\", \"content\": \"Hello\"},\n    {\"role\": \"assistant\", \"content\": \"Hi there!\"},\n]\ncount = counter.count_messages(messages)\n</code></pre>"},{"location":"user-guide/token-tracking/#usagetracker","title":"UsageTracker","text":"<pre><code>from pydantic_agent.tokens import UsageTracker\n\ntracker = UsageTracker()\n\n# Record usage\ntracker.record_usage(\n    input_tokens=100,\n    output_tokens=50,\n    model=\"gpt-4o\",\n)\n\n# Get summary\nsummary = tracker.get_summary()\nprint(f\"Total: {summary.total_tokens}\")\n\n# Get history\nhistory = tracker.get_history()\n\n# Reset\ntracker.reset()\n</code></pre>"},{"location":"user-guide/token-tracking/#costestimator","title":"CostEstimator","text":"<pre><code>from pydantic_agent.tokens import CostEstimator\n\nestimator = CostEstimator()\n\n# Estimate cost\ncost = estimator.estimate(\n    input_tokens=1000,\n    output_tokens=500,\n    model=\"gpt-4o\",\n)\nprint(f\"Cost: ${cost.total_cost:.4f}\")\n\n# Get rate for a model\nrate = estimator.get_rate(\"gpt-4o\")\n\n# Set custom rate\nestimator.set_rate(\"my-model\", 0.002)\n\n# Get all rates\nall_rates = estimator.get_all_rates()\n</code></pre>"},{"location":"user-guide/token-tracking/#integration-with-workflows","title":"Integration with Workflows","text":"<p>Workflows track usage through the agent:</p> <pre><code>from pydantic_agent import Agent\nfrom pydantic_agent.workflows import ReActWorkflow\n\nagent = Agent(\"gpt-4o\")\nworkflow = ReActWorkflow(agent=agent)\n\nresult = await workflow.run(\"Research Python best practices\")\n\n# Access usage through workflow\nusage = workflow.get_token_usage()\ncost = workflow.get_cost()\nprint(f\"Workflow cost: ${cost:.4f}\")\n</code></pre>"},{"location":"user-guide/token-tracking/#monitoring-usage","title":"Monitoring Usage","text":""},{"location":"user-guide/token-tracking/#logging-usage","title":"Logging Usage","text":"<pre><code>import logging\n\nlogging.basicConfig(level=logging.INFO)\n\nagent = Agent(\"gpt-4o\")\nagent.run_sync(\"Hello\")\n\n# Usage is logged automatically\n# INFO: Request completed: 45 tokens, $0.0001\n</code></pre>"},{"location":"user-guide/token-tracking/#usage-callbacks","title":"Usage Callbacks","text":"<p>Monitor usage in real-time with hooks:</p> <pre><code>from pydantic_agent import WorkflowHooks\n\ndef log_usage(state, step):\n    usage = state.context.get(\"usage\", {})\n    print(f\"Step {step.step_number} used {usage.get('tokens', 0)} tokens\")\n\nhooks = WorkflowHooks(on_step_complete=log_usage)\n</code></pre>"},{"location":"user-guide/token-tracking/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/token-tracking/#1-monitor-costs-in-production","title":"1. Monitor Costs in Production","text":"<pre><code># After each run\nresult = agent.run_sync(query)\ncost = agent.get_cost()\n\nif cost &gt; budget_limit:\n    logger.warning(f\"Cost ${cost:.4f} exceeded budget ${budget_limit}\")\n</code></pre>"},{"location":"user-guide/token-tracking/#2-reset-tracking-periodically","title":"2. Reset Tracking Periodically","text":"<pre><code># Per-session tracking\ndef handle_session(user_id):\n    agent.reset_tracking()\n\n    # Process requests...\n\n    # Log session usage\n    usage = agent.get_usage()\n    log_user_usage(user_id, usage)\n</code></pre>"},{"location":"user-guide/token-tracking/#3-use-cheaper-models-for-high-volume","title":"3. Use Cheaper Models for High Volume","text":"<pre><code># Route based on task complexity\nif is_simple_task(query):\n    agent = Agent(\"gpt-4o-mini\")  # Cheaper\nelse:\n    agent = Agent(\"gpt-4o\")  # More capable\n</code></pre>"},{"location":"user-guide/token-tracking/#next-steps","title":"Next Steps","text":"<ul> <li>Context Management - Manage token usage with compaction</li> <li>Cost Estimation API - Full reference</li> <li>UsageTracker API - Detailed tracking</li> </ul>"},{"location":"user-guide/tools/","title":"Working with Tools","text":"<p>Tools give your agent the ability to interact with external systems, files, and execute code.</p>"},{"location":"user-guide/tools/#built-in-tools","title":"Built-in Tools","text":"<p>Pydantic Agent includes a set of production-ready tools:</p>"},{"location":"user-guide/tools/#filesystem-tools","title":"Filesystem Tools","text":"Tool Description <code>read_file</code> Read contents of a file <code>write_file</code> Write or overwrite a file <code>append_file</code> Append content to a file <code>list_directory</code> List directory contents with metadata <code>file_info</code> Get file metadata (size, modified, created) <code>delete_file</code> Delete a file <code>move_file</code> Move or rename a file <code>copy_file</code> Copy a file"},{"location":"user-guide/tools/#search-tools","title":"Search Tools","text":"Tool Description <code>glob_search</code> Find files matching a glob pattern <code>grep_search</code> Search file contents with regex"},{"location":"user-guide/tools/#shell-tools","title":"Shell Tools","text":"Tool Description <code>run_bash</code> Execute shell commands"},{"location":"user-guide/tools/#using-built-in-tools","title":"Using Built-in Tools","text":"<pre><code>from pydantic_agent import Agent\nfrom pydantic_agent.tools import (\n    read_file,\n    write_file,\n    list_directory,\n    glob_search,\n    grep_search,\n    run_bash,\n)\n\n# Create agent with tools\nagent = Agent(\n    \"gpt-4o\",\n    tools=[read_file, write_file, list_directory, glob_search, grep_search, run_bash],\n)\n\n# The agent can now use these tools\nresult = agent.run_sync(\"List all Python files in the current directory\")\n</code></pre>"},{"location":"user-guide/tools/#tool-examples","title":"Tool Examples","text":""},{"location":"user-guide/tools/#file-operations","title":"File Operations","text":"<pre><code>from pydantic_agent.tools import read_file, write_file, list_directory, file_info\n\n# Read a file\ncontent = read_file(\"config.json\")\n\n# Write a file\nwrite_file(\"output.txt\", \"Hello, World!\")\n\n# List directory contents\nentries = list_directory(\"/project\", recursive=True)\nfor entry in entries:\n    print(f\"{entry.name}: {entry.size} bytes\")\n\n# Get file metadata\ninfo = file_info(\"README.md\")\nprint(f\"Size: {info.size}, Modified: {info.modified}\")\n</code></pre>"},{"location":"user-guide/tools/#search-operations","title":"Search Operations","text":"<pre><code>from pydantic_agent.tools import glob_search, grep_search\n\n# Find files by pattern\npy_files = glob_search(\"**/*.py\", root_dir=\"/project\")\nprint(f\"Found {len(py_files)} Python files\")\n\n# Search file contents\nmatches = grep_search(\n    pattern=r\"def \\w+\\(\",\n    path=\"/project\",\n    file_pattern=\"*.py\",\n    context_lines=2,\n)\nfor match in matches:\n    print(f\"{match.file}:{match.line}: {match.content}\")\n</code></pre>"},{"location":"user-guide/tools/#shell-commands","title":"Shell Commands","text":"<pre><code>from pydantic_agent.tools import run_bash\n\n# Run a command\nresult = run_bash(\"ls -la\", timeout=30)\nprint(result.stdout)\n\nif result.return_code != 0:\n    print(f\"Error: {result.stderr}\")\n\n# Check if command timed out\nif result.timed_out:\n    print(\"Command timed out\")\n</code></pre>"},{"location":"user-guide/tools/#creating-custom-tools","title":"Creating Custom Tools","text":""},{"location":"user-guide/tools/#using-the-decorator","title":"Using the Decorator","text":"<pre><code>from pydantic_agent import Agent\n\nagent = Agent(\"gpt-4o\")\n\n@agent.tool\ndef calculate(expression: str) -&gt; str:\n    \"\"\"\n    Evaluate a mathematical expression.\n\n    Args:\n        expression: A valid Python math expression like \"2 + 2\"\n\n    Returns:\n        The result as a string\n    \"\"\"\n    try:\n        return str(eval(expression))\n    except Exception as e:\n        return f\"Error: {e}\"\n\n@agent.tool\nasync def fetch_url(url: str) -&gt; str:\n    \"\"\"Fetch content from a URL.\"\"\"\n    import httpx\n    async with httpx.AsyncClient() as client:\n        response = await client.get(url)\n        return response.text[:1000]  # First 1000 chars\n</code></pre>"},{"location":"user-guide/tools/#using-tool_plain","title":"Using tool_plain","text":"<p>Use <code>tool_plain</code> when you don't need context:</p> <pre><code>@agent.tool_plain\ndef get_current_time() -&gt; str:\n    \"\"\"Get the current date and time.\"\"\"\n    from datetime import datetime\n    return datetime.now().isoformat()\n\n@agent.tool_plain\ndef random_number(min_val: int = 1, max_val: int = 100) -&gt; int:\n    \"\"\"Generate a random number in the given range.\"\"\"\n    import random\n    return random.randint(min_val, max_val)\n</code></pre>"},{"location":"user-guide/tools/#standalone-tool-functions","title":"Standalone Tool Functions","text":"<p>Create tools as standalone functions:</p> <pre><code>def my_tool(query: str) -&gt; str:\n    \"\"\"Process a query.\"\"\"\n    return f\"Processed: {query}\"\n\n# Register with agent\nagent = Agent(\"gpt-4o\", tools=[my_tool])\n</code></pre>"},{"location":"user-guide/tools/#tool-best-practices","title":"Tool Best Practices","text":""},{"location":"user-guide/tools/#clear-docstrings","title":"Clear Docstrings","text":"<p>The docstring is sent to the model, so make it clear:</p> <pre><code>@agent.tool\ndef search_database(\n    query: str,\n    limit: int = 10,\n    offset: int = 0,\n) -&gt; list[dict]:\n    \"\"\"\n    Search the database for matching records.\n\n    Args:\n        query: The search query string\n        limit: Maximum number of results to return (default: 10)\n        offset: Number of results to skip for pagination (default: 0)\n\n    Returns:\n        A list of matching records as dictionaries\n\n    Example:\n        search_database(\"user\", limit=5) returns up to 5 user records\n    \"\"\"\n    # Implementation\n    ...\n</code></pre>"},{"location":"user-guide/tools/#error-handling","title":"Error Handling","text":"<p>Return meaningful errors instead of raising exceptions:</p> <pre><code>@agent.tool\ndef read_config(path: str) -&gt; str:\n    \"\"\"Read a configuration file.\"\"\"\n    try:\n        with open(path) as f:\n            return f.read()\n    except FileNotFoundError:\n        return f\"Error: File '{path}' not found\"\n    except PermissionError:\n        return f\"Error: Permission denied for '{path}'\"\n    except Exception as e:\n        return f\"Error reading file: {e}\"\n</code></pre>"},{"location":"user-guide/tools/#type-hints","title":"Type Hints","text":"<p>Always use type hints for parameters and return values:</p> <pre><code>from typing import Optional\n\n@agent.tool\ndef format_data(\n    data: dict,\n    format: str = \"json\",\n    indent: Optional[int] = 2,\n) -&gt; str:\n    \"\"\"Format data in the specified format.\"\"\"\n    ...\n</code></pre>"},{"location":"user-guide/tools/#security-sandbox","title":"Security Sandbox","text":"<p>Restrict filesystem operations to a safe directory:</p> <pre><code>from pydantic_agent.tools.filesystem import FilesystemSecurity\n\n# Create security context\nsecurity = FilesystemSecurity(\n    sandbox_mode=True,\n    base_directory=\"/safe/project/path\",\n    allowed_extensions=[\".txt\", \".json\", \".py\", \".md\"],\n)\n\n# Tools will respect the sandbox\nfrom pydantic_agent.tools import read_file, write_file\n\n# This works - within sandbox\ncontent = read_file(\"data.txt\", security=security)\n\n# This fails - outside sandbox\ncontent = read_file(\"/etc/passwd\", security=security)  # Raises error\n</code></pre>"},{"location":"user-guide/tools/#security-options","title":"Security Options","text":"Option Type Description <code>sandbox_mode</code> bool Enable sandbox restrictions <code>base_directory</code> str Root directory for all operations <code>allowed_extensions</code> list File extensions that can be accessed"},{"location":"user-guide/tools/#tool-registry","title":"Tool Registry","text":"<p>For organizing many tools:</p> <pre><code>from pydantic_agent.tools import ToolRegistry\n\nregistry = ToolRegistry()\n\n# Register tools\nregistry.register(read_file)\nregistry.register(write_file)\nregistry.register(my_custom_tool)\n\n# Get all tools\nall_tools = registry.get_all()\n\n# Use with agent\nagent = Agent(\"gpt-4o\", tools=all_tools)\n</code></pre>"},{"location":"user-guide/tools/#next-steps","title":"Next Steps","text":"<ul> <li>Context Management - Manage conversation history</li> <li>Workflows - Orchestrate multi-step tool usage</li> <li>Creating Custom Tools Tutorial - Step-by-step guide</li> </ul>"},{"location":"user-guide/workflows/","title":"Workflows","text":"<p>Workflows provide orchestration patterns for multi-step agent execution. The built-in ReAct workflow implements the Reasoning and Acting paradigm.</p>"},{"location":"user-guide/workflows/#overview","title":"Overview","text":"<p>Workflows extend agent capabilities beyond single-turn interactions:</p> <ul> <li>Multi-step execution - Chain multiple agent calls</li> <li>Iterative refinement - Loop until goals are achieved</li> <li>Structured reasoning - Thought-Action-Observation patterns</li> <li>State tracking - Monitor progress and intermediate results</li> <li>Hooks - Observability callbacks for monitoring</li> </ul>"},{"location":"user-guide/workflows/#react-workflow","title":"ReAct Workflow","text":"<p>The ReAct (Reasoning and Acting) workflow implements an iterative loop:</p> <ol> <li>Thought - Agent reasons about the current state</li> <li>Action - Agent calls a tool</li> <li>Observation - Tool result is added to context</li> <li>Repeat until <code>final_answer</code> is called</li> </ol>"},{"location":"user-guide/workflows/#basic-usage","title":"Basic Usage","text":"<pre><code>from pydantic_agent import Agent\nfrom pydantic_agent.workflows import ReActWorkflow, ReActConfig\nfrom pydantic_agent.tools import read_file, run_bash, grep_search\n\n# Create agent with tools\nagent = Agent(\n    \"gpt-4o\",\n    tools=[read_file, run_bash, grep_search],\n)\n\n# Create workflow\nworkflow = ReActWorkflow(agent=agent)\n\n# Run the workflow\nresult = await workflow.run(\"Find and explain the bug in src/utils.py\")\n\nprint(f\"Success: {result.success}\")\nprint(f\"Answer: {result.output}\")\nprint(f\"Iterations: {result.total_iterations}\")\n</code></pre>"},{"location":"user-guide/workflows/#synchronous-usage","title":"Synchronous Usage","text":"<pre><code>result = workflow.run_sync(\"Analyze the codebase structure\")\n</code></pre>"},{"location":"user-guide/workflows/#accessing-the-reasoning-trace","title":"Accessing the Reasoning Trace","text":"<pre><code>result = await workflow.run(\"Research Python decorators\")\n\n# Get scratchpad entries\nfor entry in result.state.context.scratchpad:\n    print(f\"[{entry.entry_type.upper()}] {entry.content}\")\n\n# Or use convenience method\nprint(workflow.get_reasoning_trace())\n</code></pre>"},{"location":"user-guide/workflows/#react-configuration","title":"ReAct Configuration","text":"<pre><code>from pydantic_agent.workflows import ReActConfig\n\nconfig = ReActConfig(\n    # Iteration limits\n    max_iterations=15,\n    max_steps=50,\n\n    # Timeouts\n    timeout_seconds=300.0,\n    step_timeout_seconds=30.0,\n\n    # Reasoning visibility\n    expose_reasoning=True,\n    reasoning_prefix=\"Thought: \",\n    action_prefix=\"Action: \",\n    observation_prefix=\"Observation: \",\n\n    # Termination\n    final_answer_tool_name=\"final_answer\",\n\n    # Context management\n    auto_compact_in_workflow=True,\n    compact_threshold_ratio=0.8,\n\n    # Behavior tuning\n    max_consecutive_thoughts=3,  # Force action after 3 thoughts\n    tool_retry_count=2,\n)\n\nworkflow = ReActWorkflow(agent=agent, config=config)\n</code></pre>"},{"location":"user-guide/workflows/#react-hooks","title":"ReAct Hooks","text":"<p>Monitor workflow execution with hooks:</p> <pre><code>from pydantic_agent.workflows import ReActHooks\n\ndef on_thought(state, thought):\n    print(f\"Thinking: {thought[:100]}...\")\n\ndef on_action(state, tool_name, tool_args):\n    print(f\"Acting: {tool_name}({tool_args})\")\n\ndef on_observation(state, content, is_error):\n    status = \"ERROR\" if is_error else \"OK\"\n    print(f\"Observed [{status}]: {content[:100]}...\")\n\nhooks = ReActHooks(\n    # ReAct-specific hooks\n    on_thought=on_thought,\n    on_action=on_action,\n    on_observation=on_observation,\n    on_compaction=lambda r: print(f\"Compacted: {r.removed_count} messages\"),\n\n    # Base workflow hooks\n    on_workflow_start=lambda s: print(\"Starting...\"),\n    on_workflow_complete=lambda r: print(f\"Done: {r.success}\"),\n    on_iteration_start=lambda s, i: print(f\"Iteration {i}\"),\n)\n\nworkflow = ReActWorkflow(agent=agent, hooks=hooks)\n</code></pre>"},{"location":"user-guide/workflows/#custom-workflows","title":"Custom Workflows","text":"<p>Create custom workflows by extending the <code>Workflow</code> base class:</p> <pre><code>from pydantic_agent import Agent, Workflow, WorkflowConfig, WorkflowState, WorkflowResult\n\nclass PlanExecuteWorkflow(Workflow[None, str, dict]):\n    \"\"\"A Plan-and-Execute workflow pattern.\"\"\"\n\n    def __init__(\n        self,\n        planner: Agent,\n        executor: Agent,\n        config: WorkflowConfig | None = None,\n    ):\n        super().__init__(config=config)\n        self.planner = planner\n        self.executor = executor\n\n    @property\n    def name(self) -&gt; str:\n        return \"plan_execute\"\n\n    def _create_initial_state(self, prompt: str) -&gt; WorkflowState[dict]:\n        return WorkflowState(context={\n            \"prompt\": prompt,\n            \"plan\": [],\n            \"results\": [],\n        })\n\n    async def _execute(\n        self,\n        prompt: str,\n        state: WorkflowState[dict],\n        deps=None,\n    ) -&gt; str:\n        # Step 1: Create a plan\n        plan_result = await self.planner.run(\n            f\"Create a step-by-step plan to: {prompt}\"\n        )\n        state.context[\"plan\"] = plan_result.output.split(\"\\n\")\n\n        # Step 2: Execute each step\n        for i, step in enumerate(state.context[\"plan\"]):\n            if not step.strip():\n                continue\n\n            state.iteration_count += 1\n            if state.iteration_count &gt; self._config.max_iterations:\n                break\n\n            result = await self.executor.run(step)\n            state.context[\"results\"].append(result.output)\n\n        # Step 3: Synthesize results\n        synthesis = await self.planner.run(\n            f\"Summarize these results: {state.context['results']}\"\n        )\n\n        return synthesis.output\n</code></pre>"},{"location":"user-guide/workflows/#using-custom-workflows","title":"Using Custom Workflows","text":"<pre><code>planner = Agent(\"gpt-4o\", system_prompt=\"You create detailed plans.\")\nexecutor = Agent(\"gpt-4o\", tools=[read_file, run_bash])\n\nworkflow = PlanExecuteWorkflow(\n    planner=planner,\n    executor=executor,\n    config=WorkflowConfig(max_iterations=20),\n)\n\nresult = await workflow.run(\"Refactor the authentication module\")\n</code></pre>"},{"location":"user-guide/workflows/#workflow-configuration","title":"Workflow Configuration","text":""},{"location":"user-guide/workflows/#workflowconfig-options","title":"WorkflowConfig Options","text":"Option Type Default Description <code>max_steps</code> int 50 Maximum workflow steps <code>max_iterations</code> int 10 Maximum iterations per step <code>timeout_seconds</code> float 300.0 Total workflow timeout <code>step_timeout_seconds</code> float 30.0 Per-step timeout <code>enable_hooks</code> bool True Enable hook callbacks <code>track_state</code> bool True Track detailed state history"},{"location":"user-guide/workflows/#reactconfig-additional-options","title":"ReActConfig Additional Options","text":"Option Type Default Description <code>expose_reasoning</code> bool True Include thoughts in output <code>reasoning_prefix</code> str <code>\"Thought: \"</code> Prefix for thoughts <code>action_prefix</code> str <code>\"Action: \"</code> Prefix for actions <code>observation_prefix</code> str <code>\"Observation: \"</code> Prefix for observations <code>final_answer_tool_name</code> str <code>\"final_answer\"</code> Termination tool <code>auto_compact_in_workflow</code> bool True Auto-compact context <code>compact_threshold_ratio</code> float 0.8 Compaction trigger ratio <code>max_consecutive_thoughts</code> int 3 Max thoughts before action <code>tool_retry_count</code> int 2 Retries for failed tools"},{"location":"user-guide/workflows/#workflow-hooks","title":"Workflow Hooks","text":"<p>All 8 base hooks:</p> <pre><code>from pydantic_agent import WorkflowHooks\n\nhooks = WorkflowHooks(\n    # Workflow lifecycle\n    on_workflow_start=lambda state: ...,\n    on_workflow_complete=lambda result: ...,\n    on_workflow_error=lambda state, error: ...,\n\n    # Step lifecycle\n    on_step_start=lambda state, step_num, step_type: ...,\n    on_step_complete=lambda state, step: ...,\n    on_step_error=lambda state, step, error: ...,\n\n    # Iteration lifecycle\n    on_iteration_start=lambda state, iteration: ...,\n    on_iteration_complete=lambda state, iteration: ...,\n)\n</code></pre>"},{"location":"user-guide/workflows/#workflow-results","title":"Workflow Results","text":"<pre><code>result = await workflow.run(\"task\")\n\n# Check success\nif result.success:\n    print(f\"Output: {result.output}\")\nelse:\n    print(f\"Error: {result.error}\")\n\n# Access state\nprint(f\"Steps: {result.total_steps}\")\nprint(f\"Iterations: {result.total_iterations}\")\nprint(f\"Duration: {result.duration_seconds}s\")\nprint(f\"Termination: {result.termination_reason}\")\n\n# Access detailed state\nstate = result.state\nfor step in state.steps:\n    print(f\"Step {step.step_number}: {step.description}\")\n    print(f\"  Duration: {step.duration_seconds}s\")\n    print(f\"  Success: {step.success}\")\n</code></pre>"},{"location":"user-guide/workflows/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/workflows/#1-set-appropriate-limits","title":"1. Set Appropriate Limits","text":"<pre><code>config = ReActConfig(\n    max_iterations=10,  # Prevent infinite loops\n    timeout_seconds=120.0,  # Overall timeout\n    step_timeout_seconds=20.0,  # Per-step timeout\n)\n</code></pre>"},{"location":"user-guide/workflows/#2-use-hooks-for-monitoring","title":"2. Use Hooks for Monitoring","text":"<pre><code>def monitor_cost(state, step):\n    # Track cost per step\n    logger.info(f\"Step {step.step_number} cost: ${step.metadata.get('cost', 0):.4f}\")\n\nhooks = WorkflowHooks(on_step_complete=monitor_cost)\n</code></pre>"},{"location":"user-guide/workflows/#3-handle-failures-gracefully","title":"3. Handle Failures Gracefully","text":"<pre><code>result = await workflow.run(\"complex task\")\n\nif not result.success:\n    if result.termination_reason == \"max_iterations\":\n        # Try with more iterations or simpler task\n        pass\n    elif result.termination_reason == \"timeout\":\n        # Task too complex\n        pass\n</code></pre>"},{"location":"user-guide/workflows/#next-steps","title":"Next Steps","text":"<ul> <li>ReAct Tutorial - Deep dive into ReAct</li> <li>Workflow Patterns - Design patterns</li> <li>ReActWorkflow API - Full reference</li> </ul>"}]}